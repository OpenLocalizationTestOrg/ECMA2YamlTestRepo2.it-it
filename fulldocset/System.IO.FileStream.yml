### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Fornisce un <xref:System.IO.Stream>per un file di supporto sincrone e asincrone, lettura e operazioni di scrittura.</xref:System.IO.Stream>       Per esaminare il codice sorgente di .NET Framework per questo tipo, vedere il [origine riferimento](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura specificata."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>viene chiamato, l&quot;handle viene chiuso e viene ridotto il numero di handle del file.</xref:System.IO.Stream.Close%2A>       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Un handle di file per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>non è un campo di <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura specificata."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>viene chiamato, l&quot;handle viene chiuso e viene ridotto il numero di handle del file.</xref:System.IO.Stream.Close%2A>       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Un handle di file per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>non è un campo di <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con la modalità di creazione e al percorso specificata."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - il flusso è stato chiuso."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contiene un valore non valido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura specificata e la dimensione del buffer."
  remarks: "`FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A> In alternativa, leggere e scrivere l&quot;handle prima di chiamare il `FileStream` costruttore.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Un handle di file per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Oggetto <xref href=&quot;System.IO.FileAccess&quot;> </xref> costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il <code> handle </code> parametro è un handle non valido.       - o - <code> handle </code> parametro è un handle sincrono ed è stato usato in modo asincrono."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> bufferSize </code> parametro è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura e <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> proprietà dell&quot;istanza."
  remarks: "Il `FileStream` oggetto viene assegnato l&quot;accesso specificato al file. Sarà il proprietario dell&quot;handle come specificato. Se l&quot;handle, una chiamata a questo processo è proprietario di <xref:System.IO.Stream.Close%2A>metodo comporterà la chiusura di handle e il numero di handle del file viene decrementato.</xref:System.IO.Stream.Close%2A> Il `FileStream` oggetto ha le dimensioni predefinite del buffer di 4096 byte.       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima utilizzando l&quot;handle ed evitare di chiamare metodi diversi da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Un handle di file per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;handle di file è di proprietà da questo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> dell&quot;istanza; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>non è un campo di <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione e l&quot;autorizzazione di lettura/scrittura."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che determina come è possibile accedere dal file di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. Determina anche i valori restituiti dal <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. <xref:System.IO.FileStream.CanSeek*>è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` specifica un file su disco.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contiene un valore non valido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura, dimensione del buffer e lo stato sincrono o asincrono."
  remarks: "Impostare il `isAsync` parametro `true` per aprire l&quot;handle di file in modo asincrono. Quando il parametro è `true`, prevede l&quot;utilizzo di flusso dei / o sovrapposte per eseguire operazioni sui file in modo asincrono. Tuttavia, il parametro non deve essere `true` per chiamare il <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A>metodo.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando il `isAsync` parametro `false` e si chiama la lettura asincrona e le operazioni di scrittura, il thread UI ancora non viene bloccato, ma l&quot;operazione effettiva dei / o viene eseguita in modo sincrono.       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A> In alternativa, leggere e scrivere l&quot;handle prima di chiamare il `FileStream` costruttore.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Handle di file per il file che <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;handle è stato aperto in modo asincrono (vale a dire in sovrapposizione modalità i/o); in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il <code> handle </code> parametro è un handle non valido.       - o - <code> handle </code> parametro è un handle sincrono ed è stato usato in modo asincrono."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> bufferSize </code> parametro è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> proprietà dell&quot;istanza e la dimensione del buffer."
  remarks: "Il `FileStream` oggetto viene assegnato l&quot;accesso specificato al file. Sarà il proprietario dell&quot;handle come specificato. Se questo `FileStream` proprietario dell&quot;handle, una chiamata al <xref:System.IO.Stream.Close%2A>metodo comporterà la chiusura di handle.</xref:System.IO.Stream.Close%2A> In particolare, il numero di handle del file viene decrementato. Il `FileStream` oggetto ha le dimensioni del buffer specificato.       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A> In alternativa, leggere e scrivere l&quot;handle prima di chiamare il `FileStream` costruttore.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Handle di file per il file che <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;handle di file è di proprietà da questo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> dell&quot;istanza; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, l&quot;autorizzazione di lettura/scrittura e autorizzazione di condivisione."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che determina come è possibile accedere dal file di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. Determina anche i valori restituiti dal <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. <xref:System.IO.FileStream.CanSeek*>è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` specifica un file su disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - Windows 98 o Windows 98 Second Edition, è in esecuzione il sistema e <code> share </code> è impostato su <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contiene un valore non valido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe per l&quot;handle di file specificato, con l&quot;autorizzazione di lettura/scrittura specificata, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> istanza proprietà dimensione del buffer e lo stato sincrono o asincrono."
  remarks: "Il `FileStream` oggetto viene assegnato l&quot;accesso specificato al file. Sarà il proprietario dell&quot;handle come specificato. Se questo `FileStream` proprietario dell&quot;handle, una chiamata al <xref:System.IO.Stream.Close%2A>metodo comporterà la chiusura di handle.</xref:System.IO.Stream.Close%2A> In particolare, il numero di handle del file viene decrementato. Il `FileStream` oggetto ha le dimensioni del buffer specificato.       `FileStream`si presuppone che controllo esclusivo l&quot;handle. Lettura, scrittura o ricerca durante una `FileStream` contiene inoltre un handle potrebbe causare il danneggiamento dei dati. Per garantire la protezione dati, chiamare <xref:System.IO.FileStream.Flush%2A>prima di utilizzare l&quot;handle ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato utilizzando l&quot;handle.</xref:System.IO.FileStream.Flush%2A> In alternativa, leggere e scrivere l&quot;handle prima di chiamare il `FileStream` costruttore.       `FileShare.Read`il valore predefinito è pensata per quegli <xref:System.IO.FileStream>costruttori senza un `FileShare` parametro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un&quot;eccezione generata.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Handle di file per il file che <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che imposta il <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;handle di file è di proprietà da questo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> dell&quot;istanza; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;handle è stato aperto in modo asincrono (vale a dire in sovrapposizione modalità i/o); in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>è minore di <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> o maggiore di <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> o <code>bufferSize</code> è minore o uguale a 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "L&quot;handle è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio un errore del disco.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;handle di file specificato, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e l&quot;handle di file è impostato per l&quot;accesso in sola lettura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, lettura/scrittura e condivisione, autorizzazione e la dimensione del buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che determina come è possibile accedere dal file di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. Determina anche i valori restituiti dal <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. <xref:System.IO.FileStream.CanSeek*>è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` specifica un file su disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo o zero.       - oppure - <code>mode</code>, <code>access</code>, o <code>share</code> contengono un valore non valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - Windows 98 o Windows 98 Second Edition, è in esecuzione il sistema e <code> share </code> è impostato su <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, lettura/scrittura e autorizzazione di condivisione, buffer lo stato di dimensione e sincrono o asincrono."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che determina come è possibile accedere dal file di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. Determina anche i valori restituiti dal <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. <xref:System.IO.FileStream.CanSeek*>è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` specifica un file su disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096..."
    - id: useAsync
      type: System.Boolean
      description: "Specifica se usare i/o asincroni o sincroni. Si noti tuttavia che il sistema operativo sottostante non supportino i/o asincrono, pertanto quando si specifica <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, l&quot;handle potrebbe essere aperto in modalità sincrona a seconda della piattaforma. Quando è aperto in modalità asincrona, il <> </> *> e <> </> *> metodi offrono prestazioni migliori in grandi letture o scritture, ma potrebbero essere molto più lenti per piccole letture o scritture. Se l&quot;applicazione è progettata per sfruttare i vantaggi dei / o asincrone, impostare il `useAsync` parametro <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Utilizzo corretto dei / o asincroni è possibile velocizzare per le applicazioni come un fattore pari a 10, ma il relativo utilizzo senza riprogettare l&quot;applicazione per i/o asincrono può ridurre le prestazioni le operazioni come fattore di 10."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo o zero.       - oppure - <code>mode</code>, <code>access</code>, o <code>share</code> contengono un valore non valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - Windows 98 o Windows 98 Second Edition, è in esecuzione il sistema e <code> share </code> è impostato su <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, lettura/scrittura e condivisione di autorizzazione, l&quot;accesso consentito ad altri FileStream nello stesso file, la dimensione del buffer e opzioni aggiuntive del file."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: access
      type: System.IO.FileAccess
      description: "Costante che determina come è possibile accedere dal file di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. Determina anche i valori restituiti dal <> </> *> e <> </> *> le proprietà del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto. <xref:System.IO.FileStream.CanSeek*>è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` specifica un file su disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Un valore che specifica opzioni aggiuntive del file."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo o zero.       - oppure - <code>mode</code>, <code>access</code>, o <code>share</code> contengono un valore non valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura.       - oppure - <xref href=&quot;System.IO.FileOptions&quot;> </xref> specificato per <code> options </code>, ma la crittografia dei file non è supportata sulla piattaforma corrente."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Il percorso specificato, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, i diritti di accesso e autorizzazione di condivisione, le opzioni di dimensioni e altri file di buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Costante che determina i diritti di accesso da utilizzare durante la creazione di regole di accesso e controllo per il file."
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Costante che specifica opzioni aggiuntive del file."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo o zero.       - oppure - <code>mode</code>, <code>access</code>, o <code>share</code> contengono un valore non valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Il sistema operativo corrente non è Windows NT o versione successiva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura.       - oppure - <xref href=&quot;System.IO.FileOptions&quot;> </xref> specificato per <code> options </code>, ma la crittografia dei file non è supportata sulla piattaforma corrente."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Specificato <code> path </code>, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.FileStream&quot;> </xref> classe con il percorso specificato, la modalità di creazione, i diritti di accesso e condivisione di autorizzazione, la dimensione del buffer, opzioni aggiuntive del file, controllo di accesso e sicurezza di controllo."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Un percorso relativo o assoluto per il file che corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> sarà incapsulato dall&quot;oggetto."
    - id: mode
      type: System.IO.FileMode
      description: "Costante che determina come aprire o creare il file."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Costante che determina i diritti di accesso da utilizzare durante la creazione di regole di accesso e controllo per il file."
    - id: share
      type: System.IO.FileShare
      description: "Costante che determina la modalità di condivisione file da parte dei processi."
    - id: bufferSize
      type: System.Int32
      description: "Un valore positivo <xref:System.Int32>valore maggiore di 0 che indica le dimensioni del buffer.</xref:System.Int32> Le dimensioni del buffer predefinita sono 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Costante che specifica opzioni aggiuntive del file."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Costante che determina il controllo di accesso e sicurezza per il file di controllo."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>è una stringa vuota (&quot;&quot;), contiene solo spazi vuoti o contiene uno o più caratteri non validi.       - oppure - <code>path</code> fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>fa riferimento a un dispositivo non basate su file, ad esempio &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, e così via in un ambiente non NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo o zero.       - oppure - <code>mode</code>, <code>access</code>, o <code>share</code> contengono un valore non valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Impossibile trovare il file, ad esempio quando <code> mode </code> è <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e il file specificato da <code> path </code> non esiste. Il file deve esistere in queste modalità."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Errore dei / o, ad esempio specificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando il file specificato da <code> path </code> esiste già, si è verificato.       - oppure - il flusso è stato chiuso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Il percorso specificato non è valido, ad esempio si trova in un&quot;unità non mappata."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il <code> access </code> richiesto non è consentito dal sistema operativo per l&quot;oggetto specificato <code> path </code>, ad esempio quando <code> access </code> è <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e il file o la directory è impostato per l&quot;accesso in sola lettura.       - oppure - <xref href=&quot;System.IO.FileOptions&quot;> </xref> specificato per <code> options </code>, ma la crittografia dei file non è supportata sulla piattaforma corrente."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Specificato <code> path </code>, nome del file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows, i percorsi devono contenere meno di 248 caratteri e i nomi di file devono essere meno di 260 caratteri."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Il sistema operativo corrente non è Windows NT o versione successiva."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Avvia un&quot;operazione di lettura asincrona. (È consigliabile utilizzare <xref:System.IO.FileStream.ReadAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio BeginRead e <xref:System.IO.FileStream.EndRead%2A>per implementare operazioni asincrone sui file.</xref:System.IO.FileStream.EndRead%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>deve essere chiamato esattamente una volta per ogni chiamata a BeginRead.</xref:System.IO.FileStream.EndRead%2A> Impossibile terminare un processo di lettura prima di iniziare la lettura di un altro può causare un comportamento indesiderato, ad esempio i deadlock.       <xref:System.IO.FileStream>fornisce due modalità diverse di funzionamento: i/o sincrone e asincrone.</xref:System.IO.FileStream> Mentre è possibile utilizzare una, risorse del sistema operativo sottostante potrebbero consentire l&quot;accesso in una sola di queste modalità. Per impostazione predefinita, <xref:System.IO.FileStream>viene aperto l&quot;handle del sistema operativo in modo sincrono.</xref:System.IO.FileStream> In Windows, ciò rallenta metodi asincroni. Se si utilizzano metodi asincroni, utilizzare il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>costruttore.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanRead%2A>proprietà per determinare se l&quot;istanza corrente supporta la lettura.</xref:System.IO.FileStream.CanRead%2A> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente BeginRead. Gli errori che si verificano durante una richiesta di lettura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e diventano visibili dopo una chiamata a <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>deve essere chiamato con questo <xref:System.IAsyncResult>per verificare il numero di byte letti.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Più richieste asincrone contemporanee rendono incerto l&quot;ordine di completamento della richiesta.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Il buffer per leggere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in `array` in corrispondenza del quale iniziare la lettura."
    - id: numBytes
      type: System.Int32
      description: "Numero massimo di byte da leggere."
    - id: userCallback
      type: System.AsyncCallback
      description: "Il metodo da chiamare quando l&quot;operazione di lettura asincrona viene completata."
    - id: stateObject
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica richiesta di lettura asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Oggetto che fa riferimento alla lettura asincrona."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La lunghezza della matrice meno <code> offset </code> è minore di <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>numBytes</code> è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Tentativo di lettura asincrona oltre la fine del file."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Avvia un&quot;operazione di scrittura asincrona. (È consigliabile utilizzare <xref:System.IO.FileStream.WriteAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio BeginWrite e <xref:System.IO.FileStream.EndWrite%2A>per implementare operazioni asincrone sui file.</xref:System.IO.FileStream.EndWrite%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>da BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>verrà bloccata finché non viene completata l&quot;operazione dei / o.</xref:System.IO.FileStream.EndWrite%2A>       Questo metodo esegue l&quot;override <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>fornisce due modalità diverse di funzionamento: i/o sincrone e asincrone.</xref:System.IO.FileStream> Mentre è possibile utilizzare una, risorse del sistema operativo sottostante potrebbero consentire l&quot;accesso in una sola di queste modalità. Per impostazione predefinita, <xref:System.IO.FileStream>viene aperto l&quot;handle del sistema operativo in modo sincrono.</xref:System.IO.FileStream> In Windows, ciò rallenta metodi asincroni. Se si utilizzano metodi asincroni, utilizzare il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>costruttore.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente BeginWrite. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e diventano visibili dopo una chiamata a <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Più richieste asincrone contemporanee rendono incerto l&quot;ordine di completamento della richiesta.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Buffer contenente i dati da scrivere nel flusso corrente."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in base zero in `array` in corrispondenza del quale iniziare la copia dei byte nel flusso corrente."
    - id: numBytes
      type: System.Int32
      description: "Numero massimo di byte da scrivere."
    - id: userCallback
      type: System.AsyncCallback
      description: "Il metodo da chiamare quando l&quot;operazione di scrittura asincrona viene completata."
    - id: stateObject
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa richiesta particolare di scrittura asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Oggetto che fa riferimento alla scrittura asincrona."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>la lunghezza di meno <code>offset</code> è minore di <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>numBytes</code> è negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è chiuso."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la lettura."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la lettura, le chiamate al <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>e <xref:System.IO.FileStream.BeginRead%2A>i metodi generano un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la lettura. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o è stato aperto con accesso in sola scrittura."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la ricerca."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la ricerca, le chiamate a <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>e <xref:System.IO.FileStream.Seek%2A>Genera un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la ricerca. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o se il <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> è stato costruito da un handle del sistema operativo, ad esempio un pipe o un output alla console."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la scrittura."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la scrittura, una chiamata a <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, o <xref:System.IO.FileStream.WriteByte%2A>Genera un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la scrittura; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o è stato aperto con accesso in sola lettura."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Rilascia le risorse non gestite usate dal <xref href=&quot;System.IO.FileStream&quot;> </xref> e facoltativamente rilascia le risorse gestite."
  remarks: "Questo metodo viene chiamato dal metodo pubblico <xref:System.ComponentModel.Component.Dispose%2A>metodo e <xref:System.Object.Finalize%2A>metodo.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>richiama il metodo Dispose protetto con il `disposing` parametro impostato su `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>richiama Dispose con `disposing` impostato su `false`.</xref:System.Object.Finalize%2A>       Quando il `disposing` parametro `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.IO.FileStream>riferimenti.</xref:System.IO.FileStream> Questo metodo richiama il <xref:System.ComponentModel.Component.Dispose%2A>metodo di ciascun oggetto cui viene fatto riferimento.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per rilasciare le risorse gestite e non gestite. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> per rilasciare solo le risorse non gestite."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Attende che l&quot;operazione di lettura asincrono in sospeso da completare. (È consigliabile utilizzare <xref:System.IO.FileStream.ReadAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.FileStream.BeginRead%2A>ed EndRead per implementare operazioni asincrone sui file.</xref:System.IO.FileStream.BeginRead%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       EndRead deve essere chiamato esattamente per ogni chiamata a <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> Impossibile terminare un processo di lettura prima di iniziare la lettura di un altro può causare un comportamento indesiderato, ad esempio i deadlock.       Questo metodo esegue l&quot;override di <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       EndRead può essere chiamato su ogni <xref:System.IAsyncResult> <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> La chiamata a EndRead indica il numero di byte letti dal flusso. EndRead verrà bloccata finché non viene completata l&quot;operazione dei / o."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Il riferimento alla richiesta asincrona in sospeso da attendere."
    return:
      type: System.Int32
      description: "Il numero di byte letti dal flusso, tra 0 e il numero di byte richiesto. I flussi restituiscono 0 solo alla fine del flusso, in caso contrario, si devono bloccare fino a quando non è disponibile almeno 1 byte."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Questo <xref:System.IAsyncResult>oggetto non è stato creato chiamando <xref:System.IO.FileStream.BeginRead*>su questa classe.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead viene chiamato più volte."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o si è verificato un errore interno."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Termina un&quot;operazione di scrittura asincrona, rimanendo bloccato fino a quando non è stata completata l&quot;operazione dei / o. (È consigliabile utilizzare <xref:System.IO.FileStream.WriteAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.FileStream.BeginWrite%2A>ed EndWrite per implementare operazioni asincrone sui file.</xref:System.IO.FileStream.BeginWrite%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Questo metodo esegue l&quot;override di <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       EndWrite deve essere chiamato esattamente una volta ogni <xref:System.IAsyncResult> <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> EndWrite verrà bloccata finché non viene completata l&quot;operazione dei / o."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "La richiesta dei / o asincrona in sospeso."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Questo <xref:System.IAsyncResult>oggetto non è stato creato chiamando <xref:System.IO.Stream.BeginWrite*>su questa classe.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite viene chiamato più volte."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o si è verificato un errore interno."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Garantisce che le risorse vengano liberate e altre operazioni di pulizia vengono eseguite quando il garbage collector recupera la <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "Il garbage collector chiama `Finalize` quando l&quot;oggetto corrente è pronto per essere completato. `Finalize`Chiude il `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Cancella i buffer del flusso e fa sì che tutti i dati memorizzati nel buffer in cui scrivere il file."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Quando si chiama il metodo Flush, il buffer dei / o del sistema operativo viene inoltre scaricato.       Il codificatore del flusso non viene svuotato a meno che non chiama scaricare in modo esplicito o eliminare l&quot;oggetto. Impostazione <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>per `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà svuotato.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.       Poiché un buffer può essere utilizzato per la lettura o scrittura, scaricamento esegue le seguenti due funzioni:: tutti i dati scritti in precedenza per il buffer viene copiati il file e il buffer viene cancellato tranne lo stato del codificatore.      -Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>è `true` e dati sono stati copiati in precedenza dal file nel buffer per la lettura, la posizione corrente all&quot;interno del file viene applicata il numero di byte letti nel buffer.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> Il buffer viene quindi cancellato.       Utilizzo di <xref:System.IO.FileStream.Flush%28System.Boolean%29>overload del metodo quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi vengono scritti su disco.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è chiuso."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Cancella i buffer del flusso e fa sì che tutti i dati memorizzati nel buffer in cui scrivere il file e Cancella tutti i buffer di file intermedi."
  remarks: "Utilizzare questo overload quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi sia scritti su disco.       Quando si chiama il metodo Flush, il buffer dei / o del sistema operativo viene inoltre scaricato."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Per scaricare tutti i buffer di file intermedio. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Cancella tutti i buffer del flusso, determina la scrittura di dati da scrivere nel dispositivo sottostante e monitora le richieste di annullamento in modo asincrono."
  remarks: "Quando si chiama il metodo FlushAsync, il buffer dei / o del sistema operativo viene inoltre scaricato.       Se l&quot;operazione viene annullata prima del completamento, l&quot;attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus>valore per il <xref:System.Threading.Tasks.Task.Status%2A>proprietà.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se l&quot;handle del file viene eliminato, l&quot;attività restituita contiene il <xref:System.ObjectDisposedException>eccezioni nel <xref:System.Threading.Tasks.Task.Exception%2A>proprietà.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Attività che rappresenta l&quot;operazione di scaricamento asincrona."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> oggetto che incapsula le voci di elenco (ACL) di controllo di accesso per il file descritto dall&quot;oggetto corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> oggetto."
  remarks: "Mentre la <xref:System.IO.FileStream>classe e GetAccessControl possono essere utilizzate per recuperare le voci di elenco (ACL) di controllo di accesso di un file esistente, è consigliabile utilizzare <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>del metodo, è più facile da utilizzare.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Utilizzare il metodo GetAccessControl per recuperare le voci ACL per un file.       Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche per il file specificato. Per ulteriori informazioni, vedere [procedura: aggiungere o rimuovere voci dell&quot;elenco di controllo di accesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Oggetto che incapsula le impostazioni di controllo di accesso per il file descritto dall&quot;oggetto corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> oggetto."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il file viene chiuso."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;apertura del file."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Non è stato possibile trovare il file."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Questa operazione non è supportata sulla piattaforma corrente.       oppure il chiamante non dispone dell&quot;autorizzazione richiesta."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene l&quot;handle di file del sistema operativo per il file corrente <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> incapsulata dall&quot;oggetto."
  remarks: "Questa proprietà è un handle del sistema operativo per l&quot;utilizzo con chiamate di sistema operativo-fornita dal sistema (ad esempio `ReadFile` in Windows). Non funzionerà con funzioni della libreria C che richiedono un descrittore di file, ad esempio `fread`.       L&quot;handle del sistema operativo può essere stato aperto in modo sincrono o asincrono, a seconda di quale `FileStream` costruttore è stato chiamato. Utilizzare il <xref:System.IO.FileStream.IsAsync%2A>proprietà per determinare se questo handle è stato aperto in modo asincrono.</xref:System.IO.FileStream.IsAsync%2A> In Win32, ciò significa che l&quot;handle è stato aperto per operazioni dei / o sovrapposte e richiede parametri diversi per `ReadFile` e `WriteFile`.      > [!CAUTION] > Il danneggiamento dei dati può verificarsi se un `FileStream` viene creato, viene passato al relativo handle, alcune operazioni Sposta puntatore del file dell&quot;handle e quindi il `FileStream` viene usato di nuovo. Più thread non è possibile scrivere in modo sicuro nello stesso file contemporaneamente, e `FileStream` buffering codice presuppone che controlli esclusivamente l&quot;handle. `FileStream`potrebbe generare un <xref:System.IO.IOException>Se `FileStream` rileva che un altro processo è stato spostato il puntatore del file.</xref:System.IO.IOException> Per evitare questo problema, non scrivere dati in una parte del file che `FileStream` potrebbe avere memorizzato nel buffer e ripristinare il puntatore del file nel percorso in cui si trovava al momento dell&quot;ultima chiamati ai metodi in `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "L&quot;handle di file del sistema operativo per il file incapsulato dall&quot;oggetto <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> oggetto, oppure -1 se il <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> è stata chiusa."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Il chiamante non dispone dell&quot;autorizzazione richiesta."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> è stato aperto in modo asincrono o sincrono."
  remarks: "Il `IsAsync` proprietà rileva se il `FileStream` handle è stato aperto in modo asincrono, consentendo il codice per utilizzare il <xref:System.IO.FileStream.Handle%2A>proprietà correttamente.</xref:System.IO.FileStream.Handle%2A> In Win32 `IsAsync` su true indica che l&quot;handle è stato aperto per i/o sovrapposte e pertanto richiede parametri diversi per `ReadFile` e `WriteFile`.       Si specifica questo valore quando si crea un&quot;istanza di <xref:System.IO.FileStream>classe utilizzando un costruttore che ha un `isAsync`, `useAsync`, o `options` parametro.</xref:System.IO.FileStream> Quando la proprietà è `true`, prevede l&quot;utilizzo di flusso dei / o sovrapposte per eseguire operazioni sui file in modo asincrono. Tuttavia, la proprietà IsAsync non deve essere `true` per chiamare il <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A>metodo.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando la proprietà IsAsync è `false` e si chiama la lettura asincrona e le operazioni di scrittura, il thread UI ancora non viene bloccato, ma l&quot;operazione effettiva dei / o viene eseguita in modo sincrono."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> è stato aperto in modo asincrono; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene la lunghezza in byte del flusso."
  remarks: "Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Valore long che rappresenta la lunghezza del flusso in byte."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>Per questo flusso è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o, ad esempio il file viene chiuso."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Impedisce ad altri processi di leggere o scrivere la <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Bloccando l&quot;intervallo di un flusso di file offre i thread dell&quot;accesso esclusivo processo blocco di intervallo del flusso di file.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Inizio dell&quot;intervallo da bloccare. Il valore di questo parametro deve essere uguale o maggiore di zero (0)."
    - id: length
      type: System.Int64
      description: "Intervallo da bloccare."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>o <code>length</code> è negativo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il file viene chiuso."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il processo non è possibile accedere al file perché un altro processo ha bloccato una parte del file."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene il nome del <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> che è stato passato al costruttore."
  remarks: "Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Stringa che rappresenta il nome di <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene o imposta la posizione corrente del flusso."
  remarks: "La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata.  Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano.  In Microsoft Windows NT e versioni più recenti, i dati aggiunti alla fine del file sono impostati su zero.  In Microsoft Windows 98 o versioni precedenti, i dati aggiunti alla fine del file non sono impostati su zero, che significa che i dati eliminati in precedenza è visibile nel flusso. L&quot;impostazione della posizione del flusso su un valore grande oltre la fine del flusso in Windows 98 o versione precedente potrebbe viene generata un&quot;eccezione.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "La posizione corrente del flusso."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la ricerca."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentativo di impostare la posizione su un valore negativo."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Tentativo di ricerca oltre la fine di un flusso che non supporta questa."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Legge un blocco di byte dal flusso e scrive i dati in un determinato buffer."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       Il `offset` parametro fornisce l&quot;offset del byte in `array` (indice del buffer) in corrispondenza del quale iniziare la lettura e `count` parametro fornisce il numero massimo di byte da leggere dal flusso corrente. Il valore restituito è il numero effettivo di byte letti, oppure zero se viene raggiunta la fine del flusso. Se l&quot;operazione di lettura ha esito positivo, la posizione corrente del flusso viene anticipata per il numero di byte letti. Se si verifica un&quot;eccezione, la posizione corrente del flusso viene modificata.       Il metodo Read restituisce zero solo dopo il raggiungimento della fine del flusso. In caso contrario, lettura legge sempre almeno un byte dal flusso prima della restituzione. Se non sono disponibili dati dal flusso dopo una chiamata a lettura, il metodo verrà bloccato fino a quando non può essere restituito almeno un byte di dati. Un&quot;implementazione è gratuita restituire un numero di byte rispetto a quello richiesto, anche se non è stata raggiunta la fine del flusso.       Utilizzare <xref:System.IO.BinaryReader>per la lettura dei tipi di dati primitivi.</xref:System.IO.BinaryReader>       Non interrompere un thread che sta eseguendo un&quot;operazione di lettura. Anche se può sembrare che l&quot;applicazione eseguita correttamente dopo aver sbloccato il thread, l&quot;interruzione può ridurre le prestazioni e affidabilità dell&quot;applicazione.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Quando questo metodo viene restituito, contiene la matrice di byte specificata con i valori compresi tra `offset` e (`offset`  +  `count` - 1`)` sostituiti dai byte letti dall&quot;origine corrente."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in `array` al quale verranno inseriti i byte letti."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da leggere."
    return:
      type: System.Int32
      description: "Il numero totale di byte letti nel buffer. Questo potrebbe essere minore del numero di byte richiesti se tale numero di byte non sono attualmente disponibile oppure zero se viene raggiunta la fine del flusso."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la lettura."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrivono un intervallo non valido in <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Legge in modo asincrono una sequenza di byte dal flusso corrente, fa avanzare la posizione all&quot;interno del flusso del numero di byte letti e monitora le richieste di annullamento."
  remarks: "Il metodo ReadAsync consente di eseguire operazioni sui file di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app o [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app in cui un&quot;operazione di flusso richiede molto tempo è possibile bloccare il thread UI e rendere la tua app vengono visualizzati come se non funziona. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.       Utilizzare il <xref:System.IO.FileStream.CanRead%2A>proprietà per determinare se l&quot;istanza corrente supporta la lettura.</xref:System.IO.FileStream.CanRead%2A>       Se l&quot;operazione viene annullata prima del completamento, l&quot;attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus>valore per il <xref:System.Threading.Tasks.Task.Status%2A>proprietà.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se l&quot;handle del file viene eliminato, l&quot;attività restituita contiene il <xref:System.ObjectDisposedException>eccezioni nel <xref:System.Threading.Tasks.Task.Exception%2A>proprietà.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Buffer in cui scrivere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in `buffer` in corrispondenza del quale iniziare la scrittura dei dati dal flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da leggere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operazione di lettura di un&quot;attività che rappresenta asincrona. Il valore di <code> TResult </code> parametro contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere inferiore al numero di byte richiesti se il numero di byte attualmente disponibili è minore del numero di richiesto o può essere 0 (zero) se è stata raggiunta la fine del flusso."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La somma di <code> offset </code> e <code> count </code> è maggiore della lunghezza del buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la lettura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il flusso è attualmente in uso da un&quot;operazione di lettura precedente."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Legge un byte dal file e fa avanzare di un byte la posizione di lettura."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanRead%2A>proprietà per determinare se l&quot;istanza corrente supporta la lettura.</xref:System.IO.FileStream.CanRead%2A> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Byte, cast su un <xref:System.Int32>, oppure -1 se è stata raggiunta la fine del flusso.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso corrente supporta la lettura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso corrente è chiuso."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> oggetto che rappresenta l&quot;handle di file del sistema operativo per il file che corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> incapsulata dall&quot;oggetto."
  remarks: "La proprietà SafeFileHandle automaticamente Scarica il flusso e imposta la posizione corrente del flusso su 0.  In questo modo il file da spostare o la posizione del flusso per essere ripristinato da un altro flusso usando SafeFileHandle restituita da questa proprietà."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Oggetto che rappresenta l&quot;handle di file del sistema operativo per il file che corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> incapsulata dall&quot;oggetto."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Imposta la posizione corrente del flusso sul valore specificato."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>proprietà per determinare se l&quot;istanza corrente supporta la ricerca.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       È possibile effettuare ricerche in qualsiasi posizione oltre la lunghezza del flusso. Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano. In Windows NT e versioni successive, i dati aggiunti alla fine del file sono impostati su zero. In Windows 98 o versioni precedenti, non è impostati su zero, il che significa che i dati eliminati in precedenza è visibile nel flusso di dati aggiunti alla fine del file.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Punto relativo a `origin` da cui iniziare la ricerca."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Specifica l&quot;inizio, fine o la posizione corrente come punto di riferimento per `offset`, usando un valore di tipo <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "La nuova posizione nel flusso."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la ricerca, ad esempio se il <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> viene costruito da un pipe o la console di output."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La ricerca viene tentata prima dell&quot;inizio del flusso."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Applica le voci di elenco (ACL) di accesso controllo descritte da un <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> oggetto per il file descritto dall&quot;oggetto corrente <xref href=&quot;System.IO.FileStream&quot;> </xref> oggetto."
  remarks: "Mentre la <xref:System.IO.FileStream>classe e SetAccessControl può essere utilizzato in un file esistente, è possibile utilizzare il <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>il metodo è più facile da utilizzare.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Il metodo SetAccessControl applica voci di elenco (ACL) di controllo di accesso a un file che rappresenta l&quot;elenco ACL non ereditato.      > [!CAUTION] > L&quot;ACL specificato per il `fileSecurity` parametro sostituisce l&quot;ACL per il file esistente. Per aggiungere autorizzazioni per un nuovo utente, utilizzare il <xref:System.IO.FileStream.GetAccessControl%2A>eseguire il metodo per ottenere l&quot;ACL esistente, modificarlo e quindi utilizzare SetAccessControl per applicarlo al file.</xref:System.IO.FileStream.GetAccessControl%2A>       Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche per il file specificato. Per ulteriori informazioni, vedere [procedura: aggiungere o rimuovere voci dell&quot;elenco di controllo di accesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Oggetto che descrive una voce ACL da applicare al file corrente."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il file viene chiuso."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Impossibile trovare o modificare il file."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Il processo corrente non dispone di accesso per aprire il file."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Imposta la lunghezza del flusso sul valore specificato."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Se il valore specificato è minore della lunghezza corrente del flusso, il flusso viene troncato. In questo scenario, se la posizione corrente è maggiore della lunghezza di nuovo, la posizione corrente viene spostata l&quot;ultimo byte del flusso. Se il valore specificato è maggiore della lunghezza corrente del flusso, il flusso viene esteso e la posizione corrente rimane invariato. Se il flusso è espanso, il contenuto del flusso tra il vecchio e la nuova lunghezza non è definito.       Un flusso deve supportare sia la ricerca per la scrittura `SetLength` a funzionare.      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanWrite%2A>proprietà per determinare se l&quot;istanza corrente supporta la scrittura e <xref:System.IO.FileStream.CanSeek%2A>proprietà per determinare se la ricerca è supportata.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanWrite%2A>e <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Nuova lunghezza del flusso."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura e ricerca."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentativo di impostare il <code> value </code> parametro su un valore minore di 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Consente l&quot;accesso ad altri processi a tutto o parte di un file bloccato in precedenza."
  remarks: "Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Inizio dell&quot;intervallo da sbloccare."
    - id: length
      type: System.Int64
      description: "L&quot;intervallo da sbloccare."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>o <code>length</code> è negativo."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Scrive un blocco di byte nel flusso di file."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       Il `offset` parametro fornisce l&quot;offset del byte in `array` (indice del buffer) in corrispondenza del quale iniziare la copia e `count` parametro fornisce il numero di byte che verranno scritti nel flusso. Se l&quot;operazione di scrittura ha esito positivo, la posizione corrente del flusso viene anticipata per il numero di byte scritti. Se si verifica un&quot;eccezione, la posizione corrente del flusso viene modificata.      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanWrite%2A>proprietà per determinare se l&quot;istanza corrente supporta la scrittura.</xref:System.IO.FileStream.CanWrite%2A> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Non interrompere un thread che sta eseguendo un&quot;operazione di scrittura. Anche se può sembrare che l&quot;applicazione eseguita correttamente dopo aver sbloccato il thread, l&quot;interruzione può ridurre le prestazioni e affidabilità dell&quot;applicazione.       Per un elenco di file comuni e le operazioni di directory, vedere [comuni attività dei / o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Buffer contenente i dati da scrivere nel flusso."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in base zero in `array` da cui iniziare la copia dei byte nel flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da scrivere."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrivono un intervallo non valido in <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è chiuso."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "L&quot;istanza del flusso corrente supporta la scrittura."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Scrive una sequenza di byte nel flusso corrente, fa avanzare la posizione corrente nel flusso del numero di byte scritti e monitora le richieste di annullamento in modo asincrono."
  remarks: "Il metodo WriteAsync consente di eseguire operazioni sui file di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app o [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app in cui un&quot;operazione di flusso richiede molto tempo è possibile bloccare il thread UI e rendere la tua app vengono visualizzati come se non funziona. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.       Utilizzare il <xref:System.IO.FileStream.CanWrite%2A>proprietà per determinare se l&quot;istanza corrente supporta la lettura.</xref:System.IO.FileStream.CanWrite%2A>       Se l&quot;operazione viene annullata prima del completamento, l&quot;attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus>valore per il <xref:System.Threading.Tasks.Task.Status%2A>proprietà.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se l&quot;handle del file viene eliminato, l&quot;attività restituita contiene il <xref:System.ObjectDisposedException>eccezioni nel <xref:System.Threading.Tasks.Task.Exception%2A>proprietà.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Buffer in cui scrivere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in base zero in `buffer` da cui iniziare la copia dei byte nel flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da scrivere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Un&quot;attività che rappresenta l&quot;operazione di scrittura asincrona."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La somma di <code> offset </code> e <code> count </code> è maggiore della lunghezza del buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il flusso è attualmente in uso da un&quot;operazione di scrittura precedente."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Scrive un byte nella posizione corrente nel flusso di file."
  remarks: "Questo metodo esegue l&quot;override <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Utilizzare `WriteByte` per scrivere un byte in un `FileStream` in modo efficiente. Se il flusso è chiuso o non accessibile in scrittura, verrà generata un&quot;eccezione.      > [!NOTE] > Utilizzare il <xref:System.IO.FileStream.CanWrite%2A>proprietà per determinare se l&quot;istanza corrente supporta la scrittura.</xref:System.IO.FileStream.CanWrite%2A> Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Byte da scrivere nel flusso."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è chiuso."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
