### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Rappresenta una raccolta first-in First-Out di oggetti."
  remarks: "Questa classe implementa una coda come matrice circolare. Gli oggetti archiviati in una coda vengono inseriti in un&quot;entità finale e rimossi da altra.       Le code e stack sono utili quando è necessaria l&quot;archiviazione temporanea per le informazioni; ovvero, quando si potrebbe desiderare di eliminare un elemento dopo aver recuperato il relativo valore. Coda può essere utilizzata se è necessario accedere alle informazioni nello stesso ordine in cui sono archiviate nella raccolta. Utilizzare <xref:System.Collections.Stack>se è necessario accedere alle informazioni in ordine inverso.</xref:System.Collections.Stack> Utilizzare <xref:System.Collections.Concurrent.ConcurrentQueue%601>o <xref:System.Collections.Concurrent.ConcurrentStack%601>se è necessario accedere alla raccolta da più thread contemporaneamente.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       Le tre operazioni principali possono essere eseguite in una coda e i relativi elementi:- <xref:System.Collections.Queue.Enqueue%2A>aggiunge un elemento alla fine della coda.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>Rimuove l&quot;elemento meno recente dall&quot;inizio della coda.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>restituisce l&quot;elemento meno recente all&quot;inizio della coda senza rimuoverlo dalla coda.</xref:System.Collections.Queue.Peek%2A>       La capacità di una coda è il numero di elementi che della coda può contenere. Se gli elementi vengono aggiunti a una coda, la capacità viene aumentata automaticamente in base alle necessità, tramite riallocazione.  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la coda viene costruita. Il fattore di crescita predefinito è 2.0. La capacità della coda aumenterà sempre di almeno un minimo di quattro elementi, indipendentemente dal fattore di crescita. Ad esempio, una coda con un fattore di crescita pari a 1,0 aumenterà sempre capacità da quattro quando è necessaria una maggiore capacità.       Coda accetta `null` come un valore valido e consente elementi duplicati.       Per la versione generica di questa raccolta, vedere<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Queue&quot;> </xref> classe che è vuota, ha la capacità iniziale predefinita e utilizza il fattore di crescita predefinito."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi di <xref:System.Collections.Queue>può contenere.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Quando gli elementi vengono aggiunti a un <xref:System.Collections.Queue>, incrementata automaticamente in base alle necessità, tramite riallocazione.</xref:System.Collections.Queue>  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue>       Questo costruttore è un&quot;operazione o (1)."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Queue&quot;> </xref> classe che contiene gli elementi copiati dalla raccolta specificata, ha la stessa capacità iniziale come numero di elementi copiati e Usa il fattore di crescita predefinito."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi di <xref:System.Collections.Queue>può contenere.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Quando gli elementi vengono aggiunti a un <xref:System.Collections.Queue>, incrementata automaticamente in base alle necessità, tramite riallocazione.</xref:System.Collections.Queue>  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue>       Gli elementi vengono copiati nello <xref:System.Collections.Queue>nello stesso ordine in cui vengono letti dalla <xref:System.Collections.IEnumerator> <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       Questo costruttore è un&quot;operazione O (`n`) operazione, in cui `n` è il numero di elementi in `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "Il <xref:System.Collections.ICollection>per copiare gli elementi.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Queue&quot;> </xref> classe che è vuota, ha la capacità iniziale specificata e il fattore di crescita predefinito."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi di <xref:System.Collections.Queue>può contenere.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Quando gli elementi vengono aggiunti a un <xref:System.Collections.Queue>, incrementata automaticamente in base alle necessità, tramite riallocazione.</xref:System.Collections.Queue>  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue>       Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale si elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l&quot;aggiunta di elementi a <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Questo costruttore è un&quot;operazione O (`n`) operazione, in cui `n` è `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Il numero iniziale di elementi che la <xref href=&quot;System.Collections.Queue&quot;> </xref> può contenere."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>è minore di zero."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Queue&quot;> </xref> classe che è vuota, ha la capacità iniziale specificata e Usa il fattore di crescita specificato."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi di <xref:System.Collections.Queue>può contenere.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Quando gli elementi vengono aggiunti a un <xref:System.Collections.Queue>, incrementata automaticamente in base alle necessità, tramite riallocazione.</xref:System.Collections.Queue>  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue> La capacità del <xref:System.Collections.Queue>aumenterà sempre un valore minimo, indipendentemente dal fattore di crescita; un fattore di crescita pari a 1,0 non impedirà il <xref:System.Collections.Queue>aumento delle dimensioni.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale si elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l&quot;aggiunta di elementi a <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Questo costruttore è un&quot;operazione O (`n`) operazione, in cui `n` è `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Il numero iniziale di elementi che la <xref href=&quot;System.Collections.Queue&quot;> </xref> può contenere."
    - id: growFactor
      type: System.Single
      description: "Il fattore per cui la capacità del <xref href=&quot;System.Collections.Queue&quot;> </xref> viene espanso."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>è minore di zero.       - oppure - <code>growFactor</code> è minore di 1,0 o maggiore di 10.0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Rimuove tutti gli oggetti dal <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.</xref:System.Collections.Queue.Count%2A>       La capacità rimane invariata. Per reimpostare la capacità di <xref:System.Collections.Queue>chiamare <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> </xref:System.Collections.Queue> L&quot;eliminazione di un oggetto vuoto <xref:System.Collections.Queue>Imposta la capacità del <xref:System.Collections.Queue>per la capacità predefinita.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Crea una copia superficiale del <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Una copia superficiale di un insieme copia solo gli elementi della raccolta, indipendentemente che siano tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a. I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nella raccolta originale.       Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Una copia dei riferimenti di <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Determina se un elemento è incluso il <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Questo metodo determina l&quot;uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>metodi su `obj` per determinare se `item` esiste.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>metodi il `obj` parametro per gli oggetti nella raccolta.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Il <xref:System.Object>per individuare il <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> Il valore può essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copie di <xref href=&quot;System.Collections.Queue&quot;> </xref> elementi a un oggetto esistente unidimensionali <xref:System.Array>, a partire dall&quot;indice di matrice specificato.</xref:System.Array>"
  remarks: "Gli elementi vengono copiati lo <xref:System.Array>nello stesso ordine in cui l&quot;enumeratore scorre la <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Array>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Oggetto unidimensionale <xref:System.Array>che rappresenta la destinazione degli elementi copiati da <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> Il <xref:System.Array>deve avere un&quot;indicizzazione in base zero.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "Indice in base zero `array` da cui avviare la copia."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>è minore di zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>è multidimensionale.       - oppure - il numero di elementi nell&quot;origine <xref href=&quot;System.Collections.Queue&quot;> </xref> è maggiore dello spazio disponibile da <code>index</code> alla fine della destinazione <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "Il tipo di origine <xref href=&quot;System.Collections.Queue&quot;> </xref> non può essere eseguire automaticamente il cast al tipo della destinazione <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene il numero di elementi contenuti nella <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi che la <xref:System.Collections.Queue>archiviabili.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Conteggio indica il numero di elementi effettivamente contenuti nella <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       La capacità di un <xref:System.Collections.Queue>è sempre maggiore di o uguale al conteggio.</xref:System.Collections.Queue> Se il conteggio supera la capacità durante l&quot;aggiunta di elementi, la capacità viene automaticamente aumentata tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi. La nuova capacità è determinata moltiplicando la capacità corrente per il fattore di crescita, viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue> La capacità del <xref:System.Collections.Queue>aumenterà sempre un valore minimo, indipendentemente dal fattore di crescita; un fattore di crescita pari a 1,0 non impedirà il <xref:System.Collections.Queue>aumento delle dimensioni.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il recupero del valore di questa proprietà è un&quot;operazione o (1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Il numero di elementi contenuti nella <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Rimuove e restituisce l&quot;oggetto all&quot;inizio del <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Questo metodo è analogo al <xref:System.Collections.Queue.Peek%2A>metodo, ma <xref:System.Collections.Queue.Peek%2A>non modifica la <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`può essere aggiunto al <xref:System.Collections.Queue>come valore.</xref:System.Collections.Queue> Per distinguere tra un valore null e la fine del <xref:System.Collections.Queue>, controllare il <xref:System.Collections.Queue.Count%2A>proprietà o intercettare il <xref:System.InvalidOperationException>, che viene generato quando il <xref:System.Collections.Queue>è vuoto.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Questo metodo è un&quot;operazione o (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "L&quot;oggetto che viene rimosso dall&quot;inizio di <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref href=&quot;System.Collections.Queue&quot;> </xref> è vuoto."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Aggiunge un oggetto alla fine di <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "La capacità di un <xref:System.Collections.Queue>è il numero di elementi di <xref:System.Collections.Queue>può contenere.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Quando gli elementi vengono aggiunti a un <xref:System.Collections.Queue>, incrementata automaticamente in base alle necessità, tramite riallocazione.</xref:System.Collections.Queue>  È possibile diminuire la capacità chiamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Il fattore di crescita è il numero per cui la capacità corrente viene moltiplicata quando è necessaria una maggiore capacità.  Il fattore di crescita viene determinato quando la <xref:System.Collections.Queue>viene costruito.</xref:System.Collections.Queue> La capacità del <xref:System.Collections.Queue>aumenterà sempre un valore minimo, indipendentemente dal fattore di crescita; un fattore di crescita pari a 1,0 non impedirà il <xref:System.Collections.Queue>aumento delle dimensioni.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Se <xref:System.Collections.Queue.Count%2A>è minore della capacità della matrice interna, questo metodo è un&quot;operazione o (1).</xref:System.Collections.Queue.Count%2A> Se la matrice interna deve essere riallocata per consentire il nuovo elemento, questo metodo diventa un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Oggetto da aggiungere per il <xref href=&quot;System.Collections.Queue&quot;> </xref>. Il valore può essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce un enumeratore che scorre la <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Il `foreach` istruzione del linguaggio c# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, l&quot;utilizzo `foreach` è consigliabile, anziché la modifica diretta dell&quot;enumeratore.       È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non possono essere utilizzati per modificare la raccolta sottostante.       Inizialmente l&quot;enumeratore è posizionato prima del primo elemento nella raccolta. <xref:System.Collections.IEnumerator.Reset%2A>riporta l&quot;enumeratore in questa posizione.</xref:System.Collections.IEnumerator.Reset%2A>  In questa posizione, <xref:System.Collections.IEnumerator.Current%2A>è definito.</xref:System.Collections.IEnumerator.Current%2A> Pertanto, è necessario chiamare <xref:System.Collections.IEnumerator.MoveNext%2A>per passare l&quot;enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A>o <xref:System.Collections.IEnumerator.Reset%2A>viene chiamato.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>imposta <xref:System.Collections.IEnumerator.Current%2A>all&quot;elemento successivo.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>raggiunge la fine della raccolta, l&quot;enumeratore è posizionato dopo l&quot;ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A>restituisce `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando l&quot;enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A>restituire anche `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se l&quot;ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A>restituito `false`, <xref:System.Collections.IEnumerator.Current%2A>è definito.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Per impostare <xref:System.Collections.IEnumerator.Current%2A>il primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A>seguito dal <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Un enumeratore rimane valido fino a quando la raccolta rimane invariata. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l&quot;enumeratore viene invalidato e il relativo comportamento sarà indefinito.       L&quot;enumeratore non dispone di accesso esclusivo alla raccolta. Pertanto, l&quot;enumerazione di una raccolta non è quindi una procedura thread-safe.  Per garantire la protezione dei thread durante l&quot;enumerazione, è possibile bloccare la raccolta per l&quot;intera enumerazione.  Per consentire la raccolta a cui accedere da più thread per la lettura e scrittura, è necessario implementare la propria sincronizzazione.       Questo metodo è un&quot;operazione o (1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene un valore che indica se l&quot;accesso per il <xref href=&quot;System.Collections.Queue&quot;> </xref> è sincronizzato (thread-safe)."
  remarks: "Per garantire la thread-safe di <xref:System.Collections.Queue>, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <xref:System.Collections.Queue.Synchronized%2A>metodo.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;accesso al <xref href=&quot;System.Collections.Queue&quot;> </xref> è sincronizzato (thread-safe); in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce l&quot;oggetto all&quot;inizio del <xref href=&quot;System.Collections.Queue&quot;> </xref> senza rimuoverlo."
  remarks: "Questo metodo è analogo al <xref:System.Collections.Queue.Dequeue%2A>metodo, ma l&quot;anteprima non modifica la <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`può essere aggiunto al <xref:System.Collections.Queue>come valore.</xref:System.Collections.Queue> Per distinguere tra un valore null e la fine del <xref:System.Collections.Queue>, controllare il <xref:System.Collections.Queue.Count%2A>proprietà o intercettare il <xref:System.InvalidOperationException>, che viene generato quando il <xref:System.Collections.Queue>è vuoto.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Questo metodo è un&quot;operazione o (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "L&quot;oggetto all&quot;inizio del <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref href=&quot;System.Collections.Queue&quot;> </xref> è vuoto."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce un nuovo <xref href=&quot;System.Collections.Queue&quot;> </xref> che esegue il wrapping di coda originale e thread-safe."
  remarks: "Il wrapper restituito da questo metodo blocca la coda prima di eseguire un&quot;operazione in modo che venga eseguita in modo thread-safe.       Per garantire la thread-safe di <xref:System.Collections.Queue>, tutte le operazioni devono essere eseguite solo tramite questo wrapper.</xref:System.Collections.Queue>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "Il <xref href=&quot;System.Collections.Queue&quot;> </xref> per la sincronizzazione."
    return:
      type: System.Collections.Queue
      description: "Oggetto <xref href=&quot;System.Collections.Queue&quot;> </xref> wrapper sincronizzato (thread-safe)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene un oggetto che può essere utilizzato per sincronizzare l&quot;accesso al <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Per creare una versione sincronizzata del <xref:System.Collections.Queue>, utilizzare il <xref:System.Collections.Queue.Synchronized%2A>metodo.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> Tuttavia, le classi derivate possono fornire una propria versione sincronizzata del <xref:System.Collections.Queue>utilizzando la proprietà SyncRoot.</xref:System.Collections.Queue> Il codice di sincronizzazione deve essere eseguite nella radice di sincronizzazione del <xref:System.Collections.Queue>, non direttamente sulla <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente il <xref:System.Collections.Queue>oggetto.</xref:System.Collections.Queue>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Oggetto che può essere utilizzato per sincronizzare l&quot;accesso al <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copie di <xref href=&quot;System.Collections.Queue&quot;> </xref> elementi in una nuova matrice."
  remarks: "Il <xref:System.Collections.Queue>non viene modificato.</xref:System.Collections.Queue> L&quot;ordine degli elementi nella nuova matrice è identico all&quot;ordine degli elementi dall&quot;inizio del <xref:System.Collections.Queue>alla fine.</xref:System.Collections.Queue>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Nuova matrice contenente gli elementi copiati dal <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Imposta la capacità sul numero effettivo di elementi di <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una coda se nessun nuovo elemento verrà aggiunto alla coda.       Per reimpostare un <xref:System.Collections.Queue>lo stato iniziale, chiamare il metodo di <xref:System.Collections.Queue.Clear%2A>prima del metodo TrimToSize.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> L&quot;eliminazione di un oggetto vuoto <xref:System.Collections.Queue>Imposta la capacità del <xref:System.Collections.Queue>per la capacità predefinita.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il <xref href=&quot;System.Collections.Queue&quot;> </xref> è di sola lettura."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
