### YamlMime:ManagedReference
items:
- uid: System.Messaging.XmlMessageFormatter
  id: XmlMessageFormatter
  children:
  - System.Messaging.XmlMessageFormatter.#ctor
  - System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  - System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  - System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  - System.Messaging.XmlMessageFormatter.Clone
  - System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  - System.Messaging.XmlMessageFormatter.TargetTypeNames
  - System.Messaging.XmlMessageFormatter.TargetTypes
  - System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  langs:
  - csharp
  name: XmlMessageFormatter
  nameWithType: XmlMessageFormatter
  fullName: System.Messaging.XmlMessageFormatter
  type: Class
  summary: "Serializza e deserializza oggetti da o verso il corpo di un messaggio, utilizzando il formato XML in base alla definizione di schema XSD."
  remarks: "L&quot;oggetto XmlMessageFormatter è il formattatore predefinito che un&quot;istanza di <xref:System.Messaging.MessageQueue>viene utilizzato per serializzare i messaggi scritti nella coda.</xref:System.Messaging.MessageQueue> Quando si crea un&quot;istanza di <xref:System.Messaging.MessageQueue>, un&quot;istanza di XmlMessageFormatter viene creata e associata a <xref:System.Messaging.MessageQueue>.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue> È possibile specificare un formattatore differente creandolo nel codice e assegnarlo alla <xref:System.Messaging.MessageQueue.Formatter%2A>proprietà del <xref:System.Messaging.MessageQueue>.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Formatter%2A>       Istanza di una coda predefinita XmlMessageFormatter consente di scrivere nella coda, ma non può essere utilizzato per leggere dalla coda fino a quando non si imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>proprietà sul formattatore.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> È possibile impostare uno o entrambi i valori nell&quot;istanza del formattatore predefinito oppure è possibile creare una nuova istanza del formattatore e impostare i valori automaticamente tramite il passaggio come argomenti in appropriata <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>costruttore.</xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>       Quando si specifica <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>richiede che ogni voce sia completa, specificando il nome dell&quot;assembly.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.       Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> In questo modo il formattatore interpretare il corpo del messaggio.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell&quot;applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un&quot;eccezione quando viene letto il messaggio.       L&quot;oggetto XmlMessageFormatter è un componente fondamentale della messaggistica accoppiamento basato su XML. Utilizza l&quot;utilità XSD.exe che viene utilizzato il formato XML per generare schemi XML, ad esempio quando si utilizza l&quot;utilità per serializzare una classe utilizzata dall&quot;applicazione. La classe deve avere un costruttore predefinito.       Viene utilizzato il formato nuovamente il processo inverso quando l&quot;utilità genera una classe in base allo schema distribuito per descrivere i dati della classe. L&quot;utilizzo dell&quot;utilità e dello schema XML generato consente di evitare ridistribuire i file ogni volta che una classe viene ricompilata dopo che è stata modificata l&quot;implementazione della classe. Fino a quando lo schema non viene modificato sul client o server, le altre modifiche su entrambi i lati non influisce sugli altri."
  example:
  - "The following code example includes three pieces of code: a server component, an order class, and client code. The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages. The schema is an XML formatted file that describes the \"shape\" of the class. This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.  \n  \n The following code example represents a server component that receives orders through a message queue. The body of the message should be an order object whose schema matches the Order.cs class below. The server process or application deserializes the order.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#1](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_1.vb)]\n [!code-cpp[Classic XmlMessageFormatter Example#1](~/add/codesnippet/cpp/t-system.messaging.xmlme_1.cpp)]\n [!code-cs[Classic XmlMessageFormatter Example#1](~/add/codesnippet/csharp/t-system.messaging.xmlme_1.cs)]  \n  \n The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#2](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_2.vb)]\n [!code-cs[Classic XmlMessageFormatter Example#2](~/add/codesnippet/csharp/t-system.messaging.xmlme_2.cs)]\n [!code-cpp[Classic XmlMessageFormatter Example#2](~/add/codesnippet/cpp/t-system.messaging.xmlme_2.cpp)]  \n  \n Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body. The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body. The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.  \n  \n When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema. It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class). This new order class is used to serialize the order into the message body.  \n  \n The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue. The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility. An order is sent to the Orders queue on the local computer.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#3](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_3.vb)]\n [!code-cpp[Classic XmlMessageFormatter Example#3](~/add/codesnippet/cpp/t-system.messaging.xmlme_3.cpp)]\n [!code-cs[Classic XmlMessageFormatter Example#3](~/add/codesnippet/csharp/t-system.messaging.xmlme_3.cs)]  \n  \n After the schema is generated from the order class on the server, you can modify the class. Unless the schema changes, you do not need to redistribute the schema. After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified. The two classes have become loosely coupled."
  syntax:
    content: 'public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter'
  inheritance:
  - System.Object
  implements:
  - System.ICloneable
  - System.Messaging.IMessageFormatter
  inheritedMembers: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor
  id: '#ctor'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter()
  nameWithType: XmlMessageFormatter.XmlMessageFormatter()
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> set di tipi di classe, senza destinazione."
  remarks: "Questo overload del costruttore viene utilizzato più frequentemente durante la scrittura in coda, come tipi di destinazione non sono necessari durante la scrittura.       Per leggere un messaggio da una coda utilizzando un&quot;istanza di <xref:System.Messaging.XmlMessageFormatter>creato utilizzando il costruttore, è necessario impostare il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>proprietà affinché il formattatore sappia quali tipi deserializzare.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter>       Quando si crea un nuovo <xref:System.Messaging.MessageQueue>, valore predefinito è <xref:System.Messaging.XmlMessageFormatter>istanza viene creata, senza il set di tipi di destinazione.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue> Come con un formattatore creato utilizzando il costruttore, è necessario impostare i tipi di destinazione per l&quot;istanza del formattatore se si desidera leggere dalla coda."
  syntax:
    content: public XmlMessageFormatter ();
    parameters: []
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  id: '#ctor(System.String[])'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter(String[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> (classe), l&quot;impostazione di tipi di destinazione passati come matrice di valori stringa (completo)."
  remarks: "I costruttori con parametri di tipo di destinazione vengono utilizzati più frequentemente durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.       Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>proprietà per i valori della matrice passato tramite il `targetTypeNames` parametro.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> L&quot;impostazione di questa proprietà consente un <xref:System.Messaging.MessageQueue>usando questa <xref:System.Messaging.XmlMessageFormatter>istanza per leggere i messaggi contenenti oggetti di determinati tipi.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue>       Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> In questo modo il formattatore interpretare il corpo del messaggio.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La scelta di quale utilizzare è specifico dell&quot;applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un&quot;eccezione in fase di lettura."
  example:
  - >-
    [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.xmlme_1.cpp)]
     [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.xmlme_1.cs)]
     [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.xmlme_1.vb)]
  syntax:
    content: public XmlMessageFormatter (string[] targetTypeNames);
    parameters:
    - id: targetTypeNames
      type: System.String[]
      description: "Matrice di tipo <xref:System.String>che specifica il set dei tipi possibili che verranno deserializzati dal formattatore dal messaggio fornito.</xref:System.String> Questi valori devono essere completi, ad esempio, &quot;MyOrders, MyOrdersAssemblyName&quot;."
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>targetTypeNames</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  id: '#ctor(System.Type[])'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter(Type[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> (classe), l&quot;impostazione di tipi di destinazione passati come matrice di tipi di oggetto."
  remarks: "I costruttori con parametri di tipo di destinazione vengono utilizzati più frequentemente durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.       Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>proprietà per i valori della matrice passato tramite il `targetTypes` parametro.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> L&quot;impostazione di questa proprietà consente un <xref:System.Messaging.MessageQueue>usando questa <xref:System.Messaging.XmlMessageFormatter>istanza per leggere i messaggi contenenti oggetti di tipi specificati.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue>       Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> In questo modo il formattatore interpretare il corpo del messaggio.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La scelta di quale utilizzare è specifico dell&quot;applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un&quot;eccezione in fase di lettura.       Quando si specifica <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>richiede che ogni voce sia completa, specificando il nome dell&quot;assembly.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.       Quando si utilizza <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, è possibile aggiungere ogni oggetto (ad esempio, `MyClass`) all&quot;elenco nel modo descritto dal codice c# seguente.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>      ```   TargetTypes = new Type[]{typeof(MyClass)}   ```"
  syntax:
    content: public XmlMessageFormatter (Type[] targetTypes);
    parameters:
    - id: targetTypes
      type: System.Type[]
      description: "Matrice di tipo <xref:System.Type>che specifica il set dei tipi possibili che verranno deserializzati dal formattatore dal messaggio fornito.</xref:System.Type>"
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>targetTypes</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  id: CanRead(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: CanRead(Message)
  nameWithType: XmlMessageFormatter.CanRead(Message)
  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Determina se il formattatore può deserializzare il messaggio."
  remarks: "Quando viene chiamato CanRead, il formattatore tenta di determinare se che è possibile deserializzare il contenuto del messaggio. Il formattatore può deserializzare il messaggio solo se il tipo nel corpo del messaggio ha lo stesso schema di uno dei tipi nella matrice rappresentata dal <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>proprietà.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Proprietà CanRead restituisce `false` nei due casi seguenti:-il messaggio non è stato formattato utilizzando <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>      -Lo schema del corpo del messaggio non è compreso tra quelli elencati nella <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>proprietà.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano al formattatore i tipi di oggetti deve essere in grado di deserializzare.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Se qualsiasi tipo mancante nell&quot;elenco, ma è stato trovato all&quot;interno del messaggio, proprietà CanRead restituisce `false`."
  syntax:
    content: public bool CanRead (System.Messaging.Message message);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "Il <xref href=&quot;System.Messaging.Message&quot;> </xref> da controllare."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il formattatore XML può deserializzare il messaggio. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.XmlMessageFormatter.CanRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Né il <> </> *> né <> </> *> proprietà è stata impostata."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Clone
  id: Clone
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Clone()
  nameWithType: XmlMessageFormatter.Clone()
  fullName: System.Messaging.XmlMessageFormatter.Clone()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Crea un&quot;istanza di <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> classe il cui lettura/scrittura proprietà (il set di tipi di destinazione) sono le stesse corrente <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> istanza."
  remarks: "Questo metodo crea una copia del formattatore e inizializza tutte le proprietà con valori di questo <xref:System.Messaging.XmlMessageFormatter>oggetto.</xref:System.Messaging.XmlMessageFormatter>"
  syntax:
    content: public object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Oggetto le cui proprietà sono identiche a quelle del <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> istanza, ma i cui metadati non specificano deve essere un&quot;istanza della classe del formattatore."
  overload: System.Messaging.XmlMessageFormatter.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  id: Read(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Read(Message)
  nameWithType: XmlMessageFormatter.Read(Message)
  fullName: System.Messaging.XmlMessageFormatter.Read(Message)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Legge il contenuto del messaggio indicato e crea un oggetto che contiene il messaggio deserializzato."
  remarks: "Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Una di queste proprietà deve essere impostata prima che il messaggio può essere deserializzato.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       I tipi di destinazione non è necessario specificare per scrivere nella coda."
  syntax:
    content: public object Read (System.Messaging.Message message);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "Il <xref href=&quot;System.Messaging.Message&quot;> </xref>, in formato XML da deserializzare."
    return:
      type: System.Object
      description: "Il messaggio deserializzato."
  overload: System.Messaging.XmlMessageFormatter.Read*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Né il <> </> *> né <> </> *> proprietà è stata impostata.       - oppure - istanza serializzata nel corpo del messaggio non è conforme ad alcuno degli schemi rappresentati dai tipi di <> </> *> e <> </> *> proprietà."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames
  id: TargetTypeNames
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Specifica il set dei tipi possibili che verranno deserializzati dal formattatore dal messaggio fornito."
  remarks: "Entrambi i TargetTypeNames e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> In questo modo il formattatore interpretare il corpo del messaggio.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell&quot;applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un&quot;eccezione quando viene letto il messaggio.       TargetTypeNames richiede che ogni voce sia completo, che specifica il nome dell&quot;assembly. Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.       I tipi di destinazione sono necessari durante la lettura dalla coda. Il TargetTypeNames e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>proprietà non è necessario impostare la scrittura nella coda.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>"
  syntax:
    content: public string[] TargetTypeNames { get; set; }
    return:
      type: System.String[]
      description: "Matrice di tipo <xref:System.String>che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</xref:System.String>"
  overload: System.Messaging.XmlMessageFormatter.TargetTypeNames*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "La proprietà TargetTypeNames <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.TargetTypes
  id: TargetTypes
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
  fullName: System.Messaging.XmlMessageFormatter.TargetTypes
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Specifica il set dei tipi possibili che verranno deserializzati dal formattatore dal messaggio fornito."
  remarks: "Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e TargetTypes indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> In questo modo il formattatore interpretare il corpo del messaggio.       L&quot;istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A>metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e legge il corpo del messaggio al suo interno.</xref:System.Messaging.MessageQueue.Receive%2A>       Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell&quot;applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un&quot;eccezione quando viene letto il messaggio.       I tipi di destinazione sono necessari durante la lettura dalla coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>e TargetTypes proprietà non è necessario impostare per scrivere nella coda.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Quando si specifica TargetTypes anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Quando si utilizza TargetTypes, è possibile aggiungere ogni oggetto (ad esempio, `MyClass`) per l&quot;elenco nel modo illustrato nel codice c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`."
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.xmlme_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.xmlme_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.xmlme_1.vb)]"
  syntax:
    content: public Type[] TargetTypes { get; set; }
    return:
      type: System.Type[]
      description: "Matrice di tipo <xref:System.Type>che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</xref:System.Type>"
  overload: System.Messaging.XmlMessageFormatter.TargetTypes*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "La proprietà TargetTypes <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  id: Write(System.Messaging.Message,System.Object)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Write(Message,Object)
  nameWithType: XmlMessageFormatter.Write(Message,Object)
  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Serializza un oggetto nel corpo del messaggio."
  remarks: "Non è necessario specificare i tipi di destinazione devono essere durante la lettura di scrivere nella coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>è utilizzata dal formattatore solo durante la deserializzazione di un messaggio.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Il <xref:System.Messaging.XmlMessageFormatter>utilizza il <xref:System.Xml.Serialization.XmlSerializer>(classe), che definisce ciò che può essere serializzato.</xref:System.Xml.Serialization.XmlSerializer> </xref:System.Messaging.XmlMessageFormatter> Solo le proprietà pubbliche e i campi pubblici possono essere serializzate. Strutture, le strutture con matrici e le matrici di strutture sono tutte serializzabili, purché non utilizzano lo stile codificato con il protocollo SOAP."
  syntax:
    content: public void Write (System.Messaging.Message message, object obj);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "Il <xref href=&quot;System.Messaging.Message&quot;> </xref> cui <xref:System.Messaging.Message.Body*>proprietà conterrà l&quot;oggetto serializzato.</xref:System.Messaging.Message.Body*>"
    - id: obj
      type: System.Object
      description: "Il <xref:System.Object>da serializzare nel corpo del messaggio.</xref:System.Object>"
  overload: System.Messaging.XmlMessageFormatter.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Messaging.XmlMessageFormatter.#ctor
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter()
  nameWithType: XmlMessageFormatter.XmlMessageFormatter()
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter(String[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter(Type[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])
- uid: System.Type[]
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: CanRead(Message)
  nameWithType: XmlMessageFormatter.CanRead(Message)
  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message
  parent: System.Messaging
  isExternal: false
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
- uid: System.Messaging.XmlMessageFormatter.Clone
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Clone()
  nameWithType: XmlMessageFormatter.Clone()
  fullName: System.Messaging.XmlMessageFormatter.Clone()
- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Read(Message)
  nameWithType: XmlMessageFormatter.Read(Message)
  fullName: System.Messaging.XmlMessageFormatter.Read(Message)
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames
- uid: System.Messaging.XmlMessageFormatter.TargetTypes
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
  fullName: System.Messaging.XmlMessageFormatter.TargetTypes
- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Write(Message,Object)
  nameWithType: XmlMessageFormatter.Write(Message,Object)
  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)
- uid: System.Messaging.XmlMessageFormatter.#ctor*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter
  nameWithType: XmlMessageFormatter.XmlMessageFormatter
- uid: System.Messaging.XmlMessageFormatter.CanRead*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: CanRead
  nameWithType: XmlMessageFormatter.CanRead
- uid: System.Messaging.XmlMessageFormatter.Clone*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Clone
  nameWithType: XmlMessageFormatter.Clone
- uid: System.Messaging.XmlMessageFormatter.Read*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Read
  nameWithType: XmlMessageFormatter.Read
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
- uid: System.Messaging.XmlMessageFormatter.TargetTypes*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
- uid: System.Messaging.XmlMessageFormatter.Write*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Write
  nameWithType: XmlMessageFormatter.Write
