### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Fornisce il flusso di dati sottostante per l&quot;accesso alla rete."
  remarks: "La classe NetworkStream fornisce metodi per l&quot;invio e ricezione di dati su <xref:System.Net.Sockets.SocketType>socket in modalità di blocco.</xref:System.Net.Sockets.SocketType> Per ulteriori informazioni sul blocco e non bloccante <xref:System.Net.Sockets.Socket>s, vedere [utilizzando un Socket Client asincrono](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> È possibile utilizzare la classe NetworkStream per trasferimenti di dati sincroni e asincroni. Per ulteriori informazioni sulla comunicazione sincrona e asincrona, vedere [Sockets](~/add/includes/ajax-current-ext-md.md).       Per creare un oggetto NetworkStream, è necessario fornire un <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> connesso È inoltre possibile specificare quali <xref:System.IO.FileAccess>l&quot;autorizzazione di NetworkStream è su fornito <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> Per impostazione predefinita, la chiusura di NetworkStream non chiude fornito <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Se si desidera NetworkStream dispongano dell&quot;autorizzazione per chiudere l&quot;oggetto fornito <xref:System.Net.Sockets.Socket>, è necessario specificare `true` per il valore di `ownsSocket` parametro.</xref:System.Net.Sockets.Socket>       Utilizzare il <xref:System.Net.Sockets.NetworkStream.Write%2A>e <xref:System.Net.Sockets.NetworkStream.Read%2A>metodi per singolo semplice di thread i/o di blocco sincrono.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Se si desidera elaborare il / o con thread separati, è consigliabile utilizzare il <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>e <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>, metodi o <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>e <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metodi per la comunicazione.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Il NetworkStream non supporta l&quot;accesso casuale al flusso di dati di rete. Il valore di <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>proprietà, che indica se il flusso supporta la ricerca, è sempre `false`; la lettura della <xref:System.Net.Sockets.NetworkStream.Position%2A>proprietà, la lettura di <xref:System.Net.Sockets.NetworkStream.Length%2A>proprietà o chiamare il <xref:System.Net.Sockets.NetworkStream.Seek%2A>metodo genererà un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Operazioni di lettura e scrittura possono essere eseguite contemporaneamente in un&quot;istanza della classe NetworkStream senza la necessità di sincronizzazione. Fino a quando è presente un solo thread univoci per le operazioni di scrittura e un thread univoco per le operazioni di lettura, non vi sarà alcuna interferenza incrociata tra lettura e scrittura thread e sincronizzazione non è obbligatorio."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Crea una nuova istanza di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe per specificato <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Viene creato con accesso in lettura/scrittura al <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> specificato</xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Non è proprietario il sottostante <xref:System.Net.Sockets.Socket>questa operazione chiamando il <xref:System.Net.Sockets.NetworkStream.Close%2A>metodo non comporta la chiusura di <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Il <xref:System.Net.Sockets.Socket>che di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> verrà utilizzato per inviare e ricevere dati.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il <code> socket </code> parametro non è connesso.       - o - <xref:System.Net.Sockets.Socket.SocketType*>proprietà del <code> socket </code> parametro non è &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - o - <code> socket </code> parametro è in uno stato."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe per l&quot;oggetto specificato <xref:System.Net.Sockets.Socket>con l&quot;oggetto specificato <xref:System.Net.Sockets.Socket>proprietà.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Viene creato con accesso in lettura/scrittura al <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> specificato</xref:System.Net.Sockets.NetworkStream> Se il valore di `ownsSocket` parametro `true`, <xref:System.Net.Sockets.NetworkStream>acquisisce la proprietà dell&quot;oggetto sottostante <xref:System.Net.Sockets.Socket>e chiamare il <xref:System.Net.Sockets.NetworkStream.Close%2A>metodo chiude anche sottostante <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Il <xref:System.Net.Sockets.Socket>che di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> verrà utilizzato per inviare e ricevere dati.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Impostare su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> per indicare che il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> assumerà la proprietà del <xref:System.Net.Sockets.Socket>; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il <code> socket </code> parametro non è connesso.       il valore di - oppure - il <xref:System.Net.Sockets.Socket.SocketType*>proprietà del <code> socket </code> parametro non è &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - o - <code> socket </code> parametro è in uno stato."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Crea una nuova istanza di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe per l&quot;oggetto specificato <xref:System.Net.Sockets.Socket>con i diritti di accesso specificato.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Viene creato con l&quot;accesso specificato al <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> specificato</xref:System.Net.Sockets.NetworkStream> Con questo costruttore, <xref:System.Net.Sockets.NetworkStream>non è proprietario il sottostante <xref:System.Net.Sockets.Socket>pertanto la chiamata di <xref:System.Net.Sockets.NetworkStream.Close%2A>metodo non comporta la chiusura di <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> sottostante</xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Il `access` parametro imposta la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>proprietà di <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> e</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Se si specifica <xref:System.IO.FileAccess>, quindi il <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Write%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se si specifica <xref:System.IO.FileAccess>, quindi il <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Read%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se si specifica <xref:System.IO.FileAccess>, entrambe le chiamate al metodo sono consentite.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Il <xref:System.Net.Sockets.Socket>che di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> verrà utilizzato per inviare e ricevere dati.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Combinazione bit per bit del <xref href=&quot;System.IO.FileAccess&quot;> </xref> valori che specificano il tipo di accesso concesso al <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> su fornito <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il <code> socket </code> parametro non è connesso.       - o - <xref:System.Net.Sockets.Socket.SocketType*>proprietà del <code> socket </code> parametro non è &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - o - <code> socket </code> parametro è in uno stato."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Crea una nuova istanza di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe per l&quot;oggetto specificato <xref:System.Net.Sockets.Socket>con i diritti di accesso e il valore specificato <xref:System.Net.Sockets.Socket>proprietario.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Viene creato con accesso in lettura/scrittura al <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> specificato</xref:System.Net.Sockets.NetworkStream> Se il valore del `ownsSocket` parametro `true`, <xref:System.Net.Sockets.NetworkStream>acquisisce la proprietà dell&quot;oggetto sottostante <xref:System.Net.Sockets.Socket>e chiamando il <xref:System.Net.Sockets.NetworkStream.Close%2A>metodo chiude anche sottostante <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Il `access` parametro imposta la <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>proprietà di <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> e</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Se si specifica <xref:System.IO.FileAccess>, quindi il <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Write%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se si specifica <xref:System.IO.FileAccess>, quindi il <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Read%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se si specifica <xref:System.IO.FileAccess>, entrambe le chiamate al metodo sono consentite.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Il <xref:System.Net.Sockets.Socket>che di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> verrà utilizzato per inviare e ricevere dati.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Combinazione bit per bit del <xref href=&quot;System.IO.FileAccess&quot;> </xref> valori che specifica il tipo di accesso concesso al <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> su fornito <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Impostare su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> per indicare che il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> assumerà la proprietà del <xref:System.Net.Sockets.Socket>; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il <code> socket </code> parametro non è connesso.       - o - <xref:System.Net.Sockets.Socket.SocketType*>proprietà del <code> socket </code> parametro non è &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - o - <code> socket </code> parametro è in uno stato."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Inizia una lettura asincrona dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Il metodo BeginRead inizia la lettura asincrona dei dati dal buffer di rete in ingresso. La chiamata al metodo BeginRead offre la possibilità di ricevere i dati all&quot;interno di un thread di esecuzione separato.       È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback>delegato e passare il nome per il metodo BeginRead.</xref:System.AsyncCallback> Nel caso minimo, il `state` parametro deve contenere <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Dal momento che ottenere i dati ricevuti all&quot;interno del metodo di callback, è necessario creare una classe o struttura per contenere un buffer di lettura e qualsiasi altra informazione utile. Passare l&quot;istanza di classe o struttura al metodo BeginRead attraverso il `state` parametro.       Il metodo di callback deve chiamare il <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metodo.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Quando viene chiamato il metodo BeginRead, il sistema attende fino a quando non vengono ricevuti i dati o si verifica un errore e quindi il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e i blocchi della <xref:System.Net.Sockets.NetworkStream.EndRead%2A>fino a quando l&quot;oggetto fornito <xref:System.Net.Sockets.NetworkStream>legge i dati o genera un&quot;eccezione.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Se si desidera che il thread originale viene bloccato dopo aver chiamato il metodo BeginRead, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A>metodo.</xref:System.Threading.WaitHandle.WaitOne%2A> Chiamare <xref:System.Threading.EventWaitHandle.Set%2A>quando si desidera che il thread originale per continuare l&quot;esecuzione del metodo di callback.</xref:System.Threading.EventWaitHandle.Set%2A> Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/add/includes/ajax-current-ext-md.md).       Il metodo BeginRead legge tutti i dati disponibili, fino al numero di byte specificato da di `size` parametro.      > [!NOTE] > Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> In questo caso, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Leggere e scrivere le operazioni possono essere eseguite simultaneamente in un&quot;istanza del <xref:System.Net.Sockets.NetworkStream>classe senza la necessità di sincronizzazione.</xref:System.Net.Sockets.NetworkStream> Fino a quando è presente un solo thread univoci per le operazioni di scrittura e un thread univoco per le operazioni di lettura, non vi sarà alcuna interferenza incrociata tra lettura e scrittura thread e sincronizzazione non è obbligatorio."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Matrice di tipo <xref:System.Byte>che costituisce la posizione in memoria per archiviare i dati letti da di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Il percorso in `buffer` per iniziare l&quot;archiviazione dei dati."
    - id: size
      type: System.Int32
      description: "Il numero di byte da cui leggere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Il <xref:System.AsyncCallback>delegato che viene eseguita al termine di BeginRead.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Oggetto che contiene dati aggiuntivi definiti dall&quot;utente."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta la chiamata asincrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> offset </code> parametro è minore di 0.       - o - <code> offset </code> è maggiore della lunghezza del parametro di <code> buffer </code> parametro.       - o - <code> size </code> è minore di 0.       - o - <code> size </code> è maggiore della lunghezza di <code> buffer </code> meno il valore del <code> offset </code> parametro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>       oppure si è verificato un errore durante la lettura dalla rete.       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Inizia una scrittura asincrona in un flusso."
  remarks: "Il metodo BeginWrite avvia un&quot;operazione asincrona di invio all&quot;host remoto. La chiamata al metodo BeginWrite offre la possibilità di inviare dati in un thread di esecuzione separato.       È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback>delegato e passare il nome per il metodo BeginWrite.</xref:System.AsyncCallback> Nel caso minimo, il `state` parametro deve contenere <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.NetworkStream>e le altre informazioni richieste.</xref:System.Net.Sockets.NetworkStream> Passare l&quot;istanza di classe o struttura per il metodo BeginWrite tramite il `state` parametro.       Il metodo di callback deve implementare il <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metodo.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Quando viene chiamato il metodo BeginWrite, il sistema utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>fino a quando il <xref:System.Net.Sockets.NetworkStream>Invia il numero di byte richiesti o genera un&quot;eccezione.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Se si desidera che il thread originale viene bloccato dopo aver chiamato il metodo BeginWrite, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A>metodo.</xref:System.Threading.WaitHandle.WaitOne%2A> Chiamare <xref:System.Threading.EventWaitHandle.Set%2A>quando si desidera che il thread originale per continuare l&quot;esecuzione del metodo di callback.</xref:System.Threading.EventWaitHandle.Set%2A> Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> In questo caso, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Leggere e scrivere le operazioni possono essere eseguite simultaneamente in un&quot;istanza del <xref:System.Net.Sockets.NetworkStream>classe senza la necessità di sincronizzazione.</xref:System.Net.Sockets.NetworkStream> Fino a quando è presente un solo thread univoci per le operazioni di scrittura e un thread univoco per le operazioni di lettura, non vi sarà alcuna interferenza incrociata tra lettura e scrittura thread e sincronizzazione non è obbligatorio."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Matrice di tipo <xref:System.Byte>che contiene i dati in cui scrivere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Il percorso in `buffer` per iniziare l&quot;invio dei dati."
    - id: size
      type: System.Int32
      description: "Il numero di byte da scrivere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Il <xref:System.AsyncCallback>delegato che viene eseguita al termine BeginWrite.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Oggetto che contiene dati aggiuntivi definiti dall&quot;utente."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta la chiamata asincrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> offset </code> parametro è minore di 0.       - o - <code> offset </code> è maggiore della lunghezza del parametro <code> buffer </code>.       - o - <code> size </code> parametro è minore di 0.       - o - <code> size </code> è maggiore della lunghezza del parametro <code> buffer </code> meno il valore del <code> offset </code> parametro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>       oppure si è verificato un errore durante la scrittura nella rete.       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene un valore che indica se il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> supporta la lettura."
  remarks: "Se è CanRead `true`, <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Read%2A>(metodo).</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Specificare l&quot; appropriato <xref:System.IO.FileAccess>valore nel costruttore per impostare la lettura e scrittura di <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> enumerato</xref:System.IO.FileAccess> La proprietà CanRead viene impostata quando il <xref:System.Net.Sockets.NetworkStream>viene inizializzato.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se i dati possono essere letti dal flusso. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene un valore che indica se il flusso supporta la ricerca. Questa proprietà non è attualmente supportata. Questa proprietà restituisce sempre <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>in tutti i casi, per indicare che <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> non è possibile cercare una posizione specifica nel flusso."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Indica se le proprietà di timeout sono utilizzabili per <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Questa proprietà è presente perché ereditata da <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>in tutti i casi."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene un valore che indica se il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> supporta la scrittura."
  remarks: "Se è CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Write%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Specificare l&quot; appropriato <xref:System.IO.FileAccess>valore nel costruttore per impostare la lettura e scrittura di <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> enumerato</xref:System.IO.FileAccess> La proprietà CanWrite viene impostata quando il <xref:System.Net.Sockets.NetworkStream>viene inizializzato.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se è possibile scrivere i dati per il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Chiude il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> trascorso il tempo specificato per consentire l&quot;invio di dati."
  remarks: "Il metodo Close libera risorse gestite e non con <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Se il <xref:System.Net.Sockets.NetworkStream>proprietario sottostante <xref:System.Net.Sockets.Socket>, anche chiuso.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Se una <xref:System.Net.Sockets.NetworkStream>è stata associata a un oggetto <xref:System.Net.Sockets.TcpClient>il metodo Close verrà chiusa la connessione TCP, ma non dispose associati <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "Intero con segno a 32 bit che specifica il numero di millisecondi di attesa per l&quot;invio dei dati rimanenti prima della chiusura."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> timeout </code> parametro è minore di -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene un valore che indica se i dati sono disponibili per il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> da leggere."
  remarks: "Utilizzare la proprietà DataAvailable per determinare se i dati sono pronti per la lettura. Se è DataAvailable `true`, una chiamata a <xref:System.Net.Sockets.NetworkStream.Read%2A>restituisce immediatamente.</xref:System.Net.Sockets.NetworkStream.Read%2A> Se l&quot;host remoto Arresta o chiude la connessione, DataAvailable può generare un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se i dati sono disponibili nel flusso da leggere. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Utilizzare il &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rilascia le risorse non gestite usate dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> e facoltativamente rilascia le risorse gestite."
  remarks: "Questo metodo viene chiamato dal metodo pubblico `Dispose` (metodo) e <xref:System.Object.Finalize%2A>metodo.</xref:System.Object.Finalize%2A> `Dispose`richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A>richiama `Dispose` con `disposing` impostato su `false`.</xref:System.Object.Finalize%2A>       Quando il `disposing` parametro `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.Net.Sockets.NetworkStream>riferimenti.</xref:System.Net.Sockets.NetworkStream> Questo metodo richiama il `Dispose` metodo di ciascun oggetto cui viene fatto riferimento."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per rilasciare le risorse gestite e non gestite. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> per rilasciare solo le risorse non gestite."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Gestisce la fine della lettura asincrona."
  remarks: "Il metodo EndRead completa l&quot;operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metodo.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Prima di chiamare <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback>delegare.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>restituisce.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Il metodo di callback deve accettare il <xref:System.IAsyncResult>restituito dal <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metodo come parametro.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       All&quot;interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A>proprietà del <xref:System.IAsyncResult>per ottenere l&quot;oggetto di stato passato al <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metodo.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Estrarre la ricezione <xref:System.Net.Sockets.NetworkStream>dall&quot;oggetto di stato.</xref:System.Net.Sockets.NetworkStream> Dopo aver ottenuto il <xref:System.Net.Sockets.NetworkStream>, chiamare il metodo EndRead per completare l&quot;operazione di lettura e restituire il numero di byte letti.</xref:System.Net.Sockets.NetworkStream>       Il metodo EndRead si blocca fino a quando non sono disponibili dati. Il metodo EndRead legge tutti i dati disponibili fino al numero di byte specificato il `size` parametro del <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metodo.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Se l&quot;host remoto viene arrestato il <xref:System.Net.Sockets.Socket>tutti i dati disponibili e la connessione è stato ricevuto, il metodo EndRead viene completato immediatamente e restituisce zero byte.</xref:System.Net.Sockets.Socket>       Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A>proprietà del <xref:System.IAsyncResult>ed estrarre il buffer contenuto nell&quot;oggetto di stato risultante.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> In questo caso, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta una chiamata asincrona.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Numero di byte letti dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Gestisce la fine di una scrittura asincrona."
  remarks: "EndWrite completa l&quot;operazione di invio asincrono avviata <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Prima di chiamare <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback>delegare.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>restituisce.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Il metodo di callback deve accettare il <xref:System.IAsyncResult>restituito dal <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metodo come parametro.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       All&quot;interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A>proprietà di `IAsyncResult` parametro per ottenere il <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> Dopo aver ottenuto il <xref:System.Net.Sockets.NetworkStream>, è possibile chiamare il metodo EndWrite per completare l&quot;operazione di invio e restituire il numero di byte inviati.</xref:System.Net.Sockets.NetworkStream>       Il metodo EndWrite si blocca fino a quando il numero richiesto di byte inviato.      > [!NOTE] > Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> In questo caso, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Il <xref:System.IAsyncResult>che rappresenta la chiamata asincrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>       oppure si è verificato un errore durante la scrittura in rete.       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rilascia tutte le risorse usate dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Questo metodo esegue l&quot;override di <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Il codice dell&quot;applicazione non deve chiamare questo metodo. un oggetto <xref:System.Object.Finalize%2A>metodo viene richiamato automaticamente durante l&quot;operazione di garbage collection, a meno che la finalizzazione del garbage collector non è stata disabilitata da una chiamata al <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>metodo.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Per ulteriori informazioni sull&quot;utilizzo del metodo Finalize, vedere [metodi Finalize e distruttori](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [la pulizia di risorse non gestite](~/add/includes/ajax-current-ext-md.md), e [si esegue l&quot;override del metodo Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Scarica i dati dal flusso. Questo metodo è riservato per utilizzi futuri."
  remarks: "Implementa il metodo Flush il <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>metodo; tuttavia, poiché <xref:System.Net.Sockets.NetworkStream>non è memorizzato nel buffer, non ha alcun effetto sui flussi di rete.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Chiamare il metodo non genera un&quot;eccezione."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Scarica i dati dal flusso come operazione asincrona."
  remarks: "Questa operazione non verrà bloccata. L&quot;oggetto restituito <xref:System.Threading.Tasks.Task>oggetto verrà completato dopo che i dati sono stati scaricati dal flusso per il <xref:System.Net.Sockets.NetworkStream>istanza.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token di annullamento usato per propagare la notifica che l&quot;operazione deve essere annullata."
    return:
      type: System.Threading.Tasks.Task
      description: "Restituisce <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Oggetto dell&quot;attività che rappresenta l&quot;operazione asincrona."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene la lunghezza dei dati disponibili nel flusso. Questa proprietà non è attualmente supportata e genera sempre un <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "La lunghezza dei dati disponibili nel flusso."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualsiasi uso di questa proprietà."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene o imposta la posizione corrente nel flusso. Questa proprietà non è attualmente supportata e genera sempre un <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "La posizione corrente nel flusso."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualsiasi uso di questa proprietà."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Legge i dati dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Questo metodo legge i dati nel `buffer` parametro e restituisce il numero di byte letti. Se non sono disponibili dati per la lettura, il metodo Read restituisce 0. L&quot;operazione di lettura legge tutti i dati disponibili, fino al numero di byte specificato da di `size` parametro. Se l&quot;host remoto chiude la connessione e tutti i dati disponibili è stato ricevuto, il metodo di lettura viene completata immediatamente e restituirà zero byte.      > [!NOTE] > Verificare se il <xref:System.Net.Sockets.NetworkStream>è leggibile chiamando la <xref:System.Net.Sockets.NetworkStream.CanRead%2A>proprietà.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Se si tenta di leggere da un oggetto <xref:System.Net.Sockets.NetworkStream>che non sono leggibili, si otterrà un <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> In questo caso, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Matrice di tipo <xref:System.Byte>che costituisce la posizione in memoria per archiviare i dati letti da di <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Il percorso in `buffer` iniziare l&quot;archiviazione dei dati."
    - id: size
      type: System.Int32
      description: "Il numero di byte da cui leggere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Numero di byte letti dal <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> offset </code> parametro è minore di 0.       - o - <code> offset </code> è maggiore della lunghezza del parametro <code> buffer </code>.       - o - <code> size </code> parametro è minore di 0.       - o - <code> size </code> è maggiore della lunghezza del parametro <code> buffer </code> meno il valore del <code> offset </code> parametro.       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sottostante <xref:System.Net.Sockets.Socket>viene chiuso.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso.       oppure si è verificato un errore durante la lettura dalla rete."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene o imposta un valore che indica se il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> possono essere letti."
  remarks: "È necessario derivare la <xref:System.Net.Sockets.NetworkStream>classe per utilizzare la proprietà leggibile.</xref:System.Net.Sockets.NetworkStream> Se è leggibile `true`, <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Read%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> È inoltre possibile determinare se un <xref:System.Net.Sockets.NetworkStream>verificando accessibile pubblicamente <xref:System.Net.Sockets.NetworkStream.CanRead%2A>proprietà.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       La proprietà leggibile viene impostata quando il <xref:System.Net.Sockets.NetworkStream>viene inizializzato.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per indicare che il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> può essere letto; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene o imposta la quantità di tempo che un&quot;operazione di lettura di blocchi in attesa di dati."
  remarks: "Se l&quot;operazione di lettura non viene completata entro il tempo specificato da questa proprietà, l&quot;operazione di lettura genera un <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Questa proprietà viene applicata solo alle letture sincrone eseguite chiamando il <xref:System.Net.Sockets.NetworkStream.Read%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Read%2A> Questa proprietà non influisce sul letture asincrone eseguite chiamando il <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metodo.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "Oggetto <xref:System.Int32>che specifica la quantità di tempo, espresso in millisecondi, che deve trascorrere prima che un&quot;operazione di lettura ha esito negativo.</xref:System.Int32> Il valore predefinito, <xref:System.Threading.Timeout.Infinite>, specifica che l&quot;operazione di lettura non è scaduta.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il valore specificato è minore o uguale a zero e non è <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Imposta la posizione corrente del flusso sul valore specificato. Questo metodo non è attualmente supportato e genera sempre un <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Questo parametro non viene usato."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Questo parametro non viene usato."
    return:
      type: System.Int64
      description: "Posizione nel flusso."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualsiasi uso di questa proprietà."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Imposta la lunghezza del flusso. Questo metodo genera sempre un <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Questo parametro non viene usato."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualsiasi uso di questa proprietà."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene il sottostante <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Classi che derivano da <xref:System.Net.Sockets.NetworkStream>possono utilizzare questa proprietà per ottenere il sottostante <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Utilizzare sottostante <xref:System.Net.Sockets.Socket>restituito dalla proprietà Socket se è necessario accedere oltre a quelli che <xref:System.Net.Sockets.NetworkStream>fornisce.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Questa proprietà è accessibile solo tramite questa classe o una classe derivata."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "Oggetto <xref:System.Net.Sockets.Socket>che rappresenta la connessione di rete sottostante.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Scrive i dati per il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Il metodo di scrittura inizia in corrispondenza `offset` e invia `size` byte dal contenuto di `buffer` alla rete. Il metodo di scrittura si blocca fino a quando non viene inviato il numero di byte richiesto o un <xref:System.Net.Sockets.SocketException>viene generata un&quot;eccezione.</xref:System.Net.Sockets.SocketException> Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>proprietà per ottenere il codice di errore specifico, fare riferimento alla documentazione relativa ai codici di errore dell&quot;API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell&quot;errore.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Verificare se il <xref:System.Net.Sockets.NetworkStream>è scrivibile accedendo il <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>proprietà.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Se si tenta di scrivere in un oggetto <xref:System.Net.Sockets.NetworkStream>che è non modificabile, si otterrà un <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Se si riceve un oggetto <xref:System.IO.IOException>controllare la <xref:System.Exception.InnerException%2A>proprietà per determinare se è stata causata da un <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Matrice di tipo <xref:System.Byte>che contiene i dati in cui scrivere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Il percorso in `buffer` da cui iniziare la scrittura dei dati."
    - id: size
      type: System.Int32
      description: "Il numero di byte da scrivere il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <code> offset </code> parametro è minore di 0.       - o - <code> offset </code> è maggiore della lunghezza del parametro <code> buffer </code>.       - o - <code> size </code> parametro è minore di 0.       - o - <code> size </code> è maggiore della lunghezza del parametro <code> buffer </code> meno il valore del <code> offset </code> parametro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore durante la scrittura nella rete.       oppure si è verificato un errore durante l&quot;accesso al socket. Per ulteriori informazioni, vedere la sezione Osservazioni."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> è chiuso.       oppure si è verificato un errore durante la lettura dalla rete."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene un valore che indica se il <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> sia accessibile in scrittura."
  remarks: "È necessario derivare la <xref:System.Net.Sockets.NetworkStream>classe da utilizzare la proprietà Writeable.</xref:System.Net.Sockets.NetworkStream> Se è modificabile `true`, <xref:System.Net.Sockets.NetworkStream>consente le chiamate per il <xref:System.Net.Sockets.NetworkStream.Write%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> È inoltre possibile determinare se un <xref:System.Net.Sockets.NetworkStream>sia accessibile in scrittura controllando accessibile pubblicamente <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>proprietà.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       La proprietà Writeable viene impostata quando il <xref:System.Net.Sockets.NetworkStream>viene inizializzato.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se è possibile scrivere dati nel flusso. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ottiene o imposta la quantità di tempo che un&quot;operazione di scrittura si blocca in attesa di dati."
  remarks: "Se l&quot;operazione di scrittura viene completata entro il tempo specificato da questa proprietà, l&quot;operazione di scrittura genera un <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Questa proprietà influisce su operazioni di scrittura sincrona solo eseguite mediante una chiamata di <xref:System.Net.Sockets.NetworkStream.Write%2A>metodo.</xref:System.Net.Sockets.NetworkStream.Write%2A> Questa proprietà non influisce sul scritture asincrone eseguite chiamando il <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metodo.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "Oggetto <xref:System.Int32>che specifica la quantità di tempo, espresso in millisecondi, che deve trascorrere prima che un&quot;operazione di scrittura ha esito negativo.</xref:System.Int32> Il valore predefinito, <xref:System.Threading.Timeout.Infinite>, specifica che l&quot;operazione di scrittura non è scaduta.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il valore specificato è minore o uguale a zero e non è <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
