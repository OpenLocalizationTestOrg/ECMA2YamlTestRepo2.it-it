### YamlMime:ManagedReference
items:
- uid: System.ServiceProcess.ServiceBase
  id: ServiceBase
  children:
  - System.ServiceProcess.ServiceBase.#ctor
  - System.ServiceProcess.ServiceBase.AutoLog
  - System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  - System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  - System.ServiceProcess.ServiceBase.CanPauseAndContinue
  - System.ServiceProcess.ServiceBase.CanShutdown
  - System.ServiceProcess.ServiceBase.CanStop
  - System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  - System.ServiceProcess.ServiceBase.EventLog
  - System.ServiceProcess.ServiceBase.ExitCode
  - System.ServiceProcess.ServiceBase.MaxNameLength
  - System.ServiceProcess.ServiceBase.OnContinue
  - System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  - System.ServiceProcess.ServiceBase.OnPause
  - System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  - System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  - System.ServiceProcess.ServiceBase.OnShutdown
  - System.ServiceProcess.ServiceBase.OnStart(System.String[])
  - System.ServiceProcess.ServiceBase.OnStop
  - System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  - System.ServiceProcess.ServiceBase.ServiceHandle
  - System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  - System.ServiceProcess.ServiceBase.ServiceName
  - System.ServiceProcess.ServiceBase.Stop
  langs:
  - csharp
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
  type: Class
  summary: "Fornisce una classe base per un servizio che sarà disponibili come parte di un&quot;applicazione di servizio. ServiceBase deve essere derivato da quando si crea una nuova classe di servizio."
  remarks: "Derive from ServiceBase when defining your service class in a service application. Any useful service overrides the [OnStart(String\\[\\])](assetId:///M:System.ServiceProcess.ServiceBase.OnStart(System.String[])?qualifyHint=False&autoUpgrade=True) and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods. For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.  \n  \n A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account. The service can run without any user being logged on to the computer.  \n  \n By default, services run under the System account, which is not the same as the Administrator account. You cannot change the rights of the System account. Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.  \n  \n An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service. The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system. The installer also associates each service with an event log that you can use to record service commands. The `main()` function in the executable defines which services should run. The current working directory of the service is the system directory, not the directory in which the executable is located.  \n  \n When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable. However, running the service is not the same as running the executable. The executable only loads the service. The service is accessed (for example, started and stopped) through the Service Control Manager.  \n  \n The executable calls the ServiceBase derived class's constructor the first time you call Start on the service. The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes. The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.  \n  \n The Service Control Manager (SCM) provides a way to interact with the service. You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service. The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands. Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class. If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.  \n  \n You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface. You can automate the tasks available in the console. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.  \n  \n You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in ServiceBase. However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden. The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method. The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the ServiceBase object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.  \n  \n You can use `InstallUtil.exe` to install services on your system.  \n  \n> [!NOTE]\n>  You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log. Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging."
  syntax:
    content: >-
      [System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))]

      public class ServiceBase : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.#ctor
  id: '#ctor'
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
  type: Constructor
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Crea una nuova istanza di <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> classe."
  remarks: "Non creare un&quot;istanza della <xref:System.ServiceProcess.ServiceBase>classe.</xref:System.ServiceProcess.ServiceBase> Al contrario, derivano dalle <xref:System.ServiceProcess.ServiceBase>e creare un&quot;istanza di classe derivata.</xref:System.ServiceProcess.ServiceBase> Il valore minimo è necessario implementare nel costruttore per una classe ereditata da <xref:System.ServiceProcess.ServiceBase>consiste nell&quot;impostare il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>nel componente.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> </xref:System.ServiceProcess.ServiceBase> Altre elaborazioni non sono specificamente richiesto nel costruttore. È necessario gestire la maggior parte di inizializzazione in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>piuttosto che nel costruttore.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> In caso contrario, non è garantito che quando si riavvia un servizio dopo che è stato interrotto gli oggetti verranno reinizializzati.       Se si esegue l&quot;override del costruttore nella classe derivata, chiamare il costruttore di classe di base nel codice.       Il <xref:System.ServiceProcess.ServiceBase>costruttore imposta <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>a `true`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> </xref:System.ServiceProcess.ServiceBase> Se non si desidera registrare automaticamente le chiamate al servizio da Gestione controllo servizi (SCM), impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>a `false`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>       Se il file eseguibile contiene un singolo servizio, il sistema chiama il costruttore del servizio quando viene selezionato da Gestione controllo servizi, avvio e viene eseguito il distruttore se viene chiamato.       Se il file eseguibile contiene più servizi, chiamare Start su un servizio fa sì che il costruttore da chiamare per tutti i servizi nell&quot;eseguibile, ma solo il servizio specificato è stato avviato. Quando tutti i servizi siano stati arrestati, non singolarmente quando ogni servizio viene arrestato, i distruttori per i servizi vengono eseguiti insieme.      > [!NOTE] > Se si sostituisce il costruttore della classe base, è necessario chiamarlo in modo esplicito nel costruttore della classe derivata."
  syntax:
    content: public ServiceBase ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.AutoLog
  id: AutoLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica se i comandi Start, Stop, Pause e continua nel registro eventi di report."
  remarks: "Impostare AutoLog `true` indica al servizio per utilizzare il registro eventi applicazione per i report non riuscite di comando, nonché informazioni sulle modifiche di stato per Start, Stop, Pause e Continue eventi sul servizio. Il nome del servizio viene utilizzato come <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>.</xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> del log       Per registrare le informazioni in un log eventi personalizzato anziché nel registro applicazioni, impostare AutoLog `false` e scrivere le istruzioni all&quot;interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>la registrazione per il log appropriato.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>      > [!NOTE] > <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>Che fornisce la stringa di origine per il log eventi, deve essere impostata prima che il servizio tenta di scrivere nel registro eventi.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Tentativo di accedere al registro eventi prima di imposta il nome dell&quot;origine genera un&quot;eccezione."
  syntax:
    content: public bool AutoLog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per fornire le informazioni nel log eventi. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.AutoLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  id: CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta un valore che indica se il servizio può gestire le notifiche delle modifiche dello stato dell&quot;alimentazione di computer."
  remarks: "Quando cambia lo stato di alimentazione del computer, Gestione controllo servizi (SCM) consente di verificare se il servizio accetta comandi evento power utilizzando il valore di e.       Se è e `true`, il comando viene passato al servizio e <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>metodo viene chiamato se definito.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>non è implementata nella classe derivata, SCM gestisce l&quot;evento di risparmio energia tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName>metodo.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>"
  syntax:
    content: public bool CanHandlePowerEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il servizio gestisce lo stato di alimentazione di computer le modifiche indicate nella <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> (classe), in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Questa proprietà viene modificata dopo l&quot;avvio del servizio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  id: CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta un valore che indica se il servizio può gestire gli eventi di modifica di sessione ricevuti da una sessione di Terminal Server."
  syntax:
    content: public bool CanHandleSessionChangeEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il servizio può gestire eventi di modifica della sessione di Terminal Server; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Questa proprietà viene modificata dopo l&quot;avvio del servizio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  id: CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta un valore che indica se il servizio può essere sospesa e ripresa."
  remarks: "Impostare il valore della proprietà CanPauseAndContinue nel costruttore per il servizio.       Quando un servizio viene sospesa, arresta quanto accade. Quando si continua del servizio (tramite Gestione controllo servizi o a livello di codice), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>viene eseguito.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       L&quot;invio di una richiesta di sospensione per il servizio, è possibile risparmiare risorse di sistema. Sospensione potrebbe non rilasciare tutte le risorse di sistema, l&quot;interruzione. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>spesso vengono implementati per eseguire operazioni di elaborazione minore e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A></xref:System.ServiceProcess.ServiceBase.OnPause%2A>       Quando CanPauseAndContinue è `true`, eseguire l&quot;override <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>per specificare l&quot;elaborazione che deve verificarsi quando Gestione controllo servizi (SCM) passa una richiesta di sospensione o continuazione al servizio.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve essere implementato per annullare l&quot;elaborazione in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se è CanPauseAndContinue `false`, SCM non passerà sospensione o continua richieste al servizio, pertanto il <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>metodi non verranno chiamati anche se sono implementate.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando è CanPauseAndContinue `false`."
  syntax:
    content: public bool CanPauseAndContinue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il servizio può essere sospeso; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il servizio è già stato avviato. La proprietà CanPauseAndContinue non può essere modificata dopo l&quot;avvio del servizio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  id: CanShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta un valore che indica se il servizio deve ricevere notifica quando il sistema è in corso l&quot;arresto."
  remarks: "Se è CanShutdown `true`, il servizio riceve una notifica quando il sistema è in corso l&quot;arresto. Al momento della chiusura, il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>metodo viene chiamato se è stato implementato nella classe derivata.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>      > [!NOTE] > Solo il sistema deve provocare il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>metodo da eseguire; il servizio può essere chiamato, ma questa operazione è sconsigliata.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>"
  syntax:
    content: public bool CanShutdown { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il servizio deve essere notificato quando il sistema è in fase di chiusura; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.  Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanShutdown*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il servizio è già stato avviato. La proprietà CanShutdown non può essere modificata dopo l&quot;avvio del servizio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanStop
  id: CanStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta un valore che indica se il servizio può essere arrestato dopo averlo avviato."
  remarks: "Quando viene chiamato su un servizio, Gestione controllo servizi (SCM) consente di verificare se il servizio accetta tali comandi utilizzando il valore di CanStop. Per la maggior parte dei servizi, il valore di CanStop è `true`, ma alcuni servizi del sistema operativo, ad esempio, consente all&quot;utente di arrestarli.       Se è CanStop `true`, il comando di interruzione viene passato al servizio e <xref:System.ServiceProcess.ServiceBase.OnStop%2A>metodo viene chiamato se è definito.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A>non è implementata nella classe derivata, il gestore SCM gestisce il comando di interruzione tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName>metodo.</xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnStop%2A>"
  syntax:
    content: public bool CanStop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il servizio può essere arrestato e <xref:System.ServiceProcess.ServiceBase.OnStop*>metodo chiamato; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.ServiceProcess.ServiceBase.OnStop*>"
  overload: System.ServiceProcess.ServiceBase.CanStop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il servizio è già stato avviato. La proprietà CanStop non può essere modificata dopo l&quot;avvio del servizio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Elimina le risorse (ad eccezione di memoria) utilizzate per il <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref>."
  remarks: "Chiamare il metodo Dispose della classe derivata (e attraverso di esso, nel <xref:System.ServiceProcess.ServiceBase>classe) quando si è terminato di utilizzare la classe derivata.</xref:System.ServiceProcess.ServiceBase> Il metodo Dispose lascia la classe derivata in uno stato inutilizzabile. Dopo aver chiamato Dispose, è necessario rilasciare tutti i riferimenti alla classe derivata e <xref:System.ServiceProcess.ServiceBase>in modo che la memoria occupata può essere recuperata tramite garbage collection.</xref:System.ServiceProcess.ServiceBase>      > [!NOTE] > Sempre chiami Dispose prima di rilasciare l&quot;ultimo riferimento alla classe derivata da <xref:System.ServiceProcess.ServiceBase>.</xref:System.ServiceProcess.ServiceBase> In caso contrario, le risorse <xref:System.ServiceProcess.ServiceBase>e verrà utilizza la classe derivata non verranno liberate finché l&quot;operazione di garbage collection chiama i distruttori degli oggetti.</xref:System.ServiceProcess.ServiceBase>       <xref:System.ServiceProcess.ServiceBase.OnStop%2A>viene spesso implementato per elaborare il codice in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinata con una chiamata al metodo Dispose.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se si sceglie di eseguire questa operazione nella classe derivata, è facoltativa per implementare <xref:System.ServiceProcess.ServiceBase.OnStart%2A>allocare qualsiasi rilasciato Dispose.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per rilasciare le risorse gestite e non gestite. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> per rilasciare solo le risorse non gestite."
  overload: System.ServiceProcess.ServiceBase.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.EventLog
  id: EventLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene un registro eventi che è possibile utilizzare per scrivere la notifica delle chiamate di comando di servizio, ad esempio Start e Stop, nel registro eventi dell&quot;applicazione."
  remarks: "Il costruttore inizializza la proprietà EventLog a un&quot;istanza con il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName>set di proprietà.</xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> L&quot;origine è il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>del servizio, e il log è log. applicazione del computer</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Questi valori vengono impostati automaticamente e non possono essere modificati per la registrazione automatica dei comandi di servizio.       Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>è `true`, Start, Stop, Pause, continua e comandi personalizzati vengono registrati automaticamente nel log eventi dell&quot;applicazione.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> È possibile utilizzare la proprietà EventLog per scrivere messaggi aggiuntivi in tale registro anche. Il componente chiama <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>utilizzo di questo membro EventLog.</xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>       Per registrare le informazioni in un log eventi personalizzato anziché nel registro applicazioni, impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>a `false` e scrivere le istruzioni all&quot;interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>la registrazione per il log appropriato.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public virtual System.Diagnostics.EventLog EventLog { get; }
    return:
      type: System.Diagnostics.EventLog
      description: "Un <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> istanza la cui origine è registrato nel registro applicazioni."
  overload: System.ServiceProcess.ServiceBase.EventLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ExitCode
  id: ExitCode
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta il codice di uscita per il servizio."
  remarks: "Impostare la proprietà ExitCode su un valore diverso da zero prima di arrestare il servizio per indicare un errore in Gestione controllo servizi."
  syntax:
    content: public int ExitCode { get; set; }
    return:
      type: System.Int32
      description: "Il codice di uscita per il servizio."
  overload: System.ServiceProcess.ServiceBase.ExitCode*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  id: MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
  type: Field
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica la dimensione massima per un nome di servizio."
  remarks: "ServiceName e DisplayName hanno limitazioni di dimensione che devono essere osservate quando si impostano le proprietà della classe del servizio."
  syntax:
    content: public const int MaxNameLength = 80;
    return:
      type: System.Int32
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnContinue
  id: OnContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementato in una classe derivata, OnContinue viene eseguito quando un comando di continuazione viene inviato al servizio da Gestione controllo servizi (SCM). Specifica le azioni da intraprendere quando un servizio riprende il normale funzionamento dopo essere stato sospeso."
  remarks: "Implementare OnContinue per riflettere la risposta dell&quot;applicazione per <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> Quando si continua del servizio (tramite la console servizi o a livello di codice), il OnContinue viene eseguita l&quot;elaborazione e il servizio diventa nuovamente attivo.       OnContinue deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>proprietà `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>è `false`, SCM non passerà sospensione o continua richieste al servizio, pertanto il <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e metodi OnContinue non verranno chiamati anche se sono implementate.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>è `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnContinue ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnContinue*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  id: OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito OnCustomCommand quando Gestione controllo servizi (SCM) passa un comando personalizzato per il servizio. Specifica le azioni da intraprendere quando si verifica un comando con il valore del parametro specificato."
  remarks: "OnCustomCommand consente di specificare funzionalità aggiuntive oltre all&quot;avvio, arresto, sospensione e continuazione dei servizi.       Gestione controllo servizi non esamina il comando personalizzato per verificare se il servizio supporta il `command` parametro passato. Il comando personalizzato passa direttamente al servizio. Se il servizio non riconosce il `command` parametro, non esegue alcuna operazione.       Comandi personalizzati sono attivati da un <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>istruzione in un <xref:System.ServiceProcess.ServiceController>componente.</xref:System.ServiceProcess.ServiceController> </xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> Usare un&quot;istruzione switch o se... Then per gestire i comandi personalizzati definiti nel servizio.       Gli unici valori per un comando personalizzato che è possibile definire nell&quot;applicazione in uso o utilizzare in OnCustomCommand sono quelli compresi tra 128 e 255. Gli integer sotto 128 corrispondono ai valori riservati al sistema.       Se il <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>proprietà `true`, comandi personalizzati, analogamente a tutti gli altri comandi, scriveranno voci nel registro eventi per segnalare se l&quot;esecuzione del metodo ha avuto esito positivo o negativo.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: protected virtual void OnCustomCommand (int command);
    parameters:
    - id: command
      type: System.Int32
      description: "Il messaggio di comando inviato al servizio."
  overload: System.ServiceProcess.ServiceBase.OnCustomCommand*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPause
  id: OnPause
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito quando un comando di sospensione viene inviato al servizio da Gestione controllo servizi (SCM). Specifica le azioni da intraprendere quando un servizio viene sospeso."
  remarks: "Utilizzare OnPause per specificare l&quot;elaborazione che si verifica quando il servizio riceve un comando di sospensione. OnPause deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>proprietà `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Quando si continua un servizio sospeso (tramite la console servizi o a livello di codice), il <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>viene eseguita l&quot;elaborazione e il servizio diventa nuovamente attivo.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Il comando pausa consente solo l&quot;applicazione rispondere a un evento specifico. OnPause non esegue alcuna operazione per il servizio che non si definisce per l&quot;esecuzione.       L&quot;invio di una richiesta di sospensione per il servizio, è possibile risparmiare risorse di sistema perché Pause non è necessario rilasciare tutte le risorse di sistema. Ad esempio, se il processo, la sospensione di un servizio, anziché l&quot;arresto possibile consentire i thread rimangano aperti, sono state aperte thread non dovranno quindi riallocarli quando il servizio continua. Se si definiscono Sospendi per rilasciare tutte le risorse di sistema, si comporta come un comando di arresto.       Impostare <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>a `true`ed eseguire l&quot;override OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>per specificare l&quot;elaborazione che deve verificarsi quando il server passa una richiesta di sospensione o continuazione al servizio.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve essere implementato per annullare l&quot;elaborazione in OnPause.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>è `false`, SCM non passerà sospensione o continua di richieste al servizio, pertanto OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>metodi non verranno chiamati anche se è implementato.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>è `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnPause ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnPause*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  id: OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito quando lo stato di alimentazione del computer è stato modificato. Questo vale per i computer portatili che entrano in modalità sospensione, che non è lo stesso come un arresto del sistema."
  remarks: "Consente di specificare l&quot;elaborazione che si verifica quando l&quot;evento di sistema indicata OnPowerEvent il <xref:System.ServiceProcess.PowerBroadcastStatus>enumerazione si verifica, ad esempio, quando il computer si trova in modalità sospensione o indica consumo della batteria.</xref:System.ServiceProcess.PowerBroadcastStatus>       OnPowerEvent deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>proprietà `true`.</xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>"
  syntax:
    content: protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);
    parameters:
    - id: powerStatus
      type: System.ServiceProcess.PowerBroadcastStatus
      description: "Oggetto <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> che indica una notifica dal sistema sul relativo stato di alimentazione."
    return:
      type: System.Boolean
      description: "Quando viene implementato in una classe derivata, le esigenze della propria applicazione di determinano il valore da restituire. Ad esempio, se un <xref uid=&quot;langword_csharp_QuerySuspend&quot; name=&quot;QuerySuspend&quot; href=&quot;&quot;> </xref> stato viene passato, è possibile che l&quot;applicazione per rifiutare la query restituendo <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.OnPowerEvent*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  id: OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Viene eseguito quando viene ricevuto un evento di modifica da una sessione di Terminal Server."
  remarks: "È necessario impostare il <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>proprietà `true` per abilitare l&quot;esecuzione di questo metodo.</xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>"
  syntax:
    content: protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);
    parameters:
    - id: changeDescription
      type: System.ServiceProcess.SessionChangeDescription
      description: "Struttura che identifica il tipo di modifica."
  overload: System.ServiceProcess.ServiceBase.OnSessionChange*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  id: OnShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito quando il sistema è in corso l&quot;arresto. Specifica cosa dovrebbe accadere immediatamente prima della chiusura del sistema."
  remarks: "Utilizzare OnShutdown per specificare l&quot;elaborazione che si verifica quando il sistema si arresta.       Questo evento si verifica solo quando il sistema operativo viene arrestato, non quando il computer è spento.       OnShutdown deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>proprietà `true`.</xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>"
  syntax:
    content: protected virtual void OnShutdown ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  id: OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito quando un comando di avvio viene inviato al servizio da Gestione controllo servizi (SCM) o quando l&quot;avvio del sistema operativo (per un servizio che viene avviato automaticamente). Specifica le azioni da eseguire all&quot;avvio del servizio."
  remarks: "Use OnStart to specify the processing that occurs when the service receives a Start command. OnStart is the method in which you specify the behavior of the service. OnStart can take arguments as a way to pass data, but this usage is rare.  \n  \n> [!CAUTION]\n>  Do not use the constructor to perform processing that should be in OnStart. Use OnStart to handle all initialization of your service. The constructor is called when the application's executable runs, not when the service runs. The executable runs before OnStart. When you continue, for example, the constructor is not called again because the SCM already holds the object in memory. If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in OnStart, the needed resources would not be created again the second time the service is called.  \n  \n Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode>. In such a situation, OnStart would be called at system startup.  \n  \n OnStart is expected to be overridden in the derived class. For the service to be useful, OnStart and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.  \n  \n Process initialization arguments for the service in the OnStart method, not in the Main method. The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console. The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel. Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<service name>*). You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`."
  syntax:
    content: protected virtual void OnStart (string[] args);
    parameters:
    - id: args
      type: System.String[]
      description: "Dati passati dal comando di avvio."
  overload: System.ServiceProcess.ServiceBase.OnStart*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStop
  id: OnStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando viene implementato in una classe derivata, viene eseguito quando il servizio viene inviato un comando di arresto da Gestione controllo servizi (SCM). Specifica le azioni da intraprendere quando si arresta un servizio."
  remarks: "Consente di specificare l&quot;elaborazione che si verifica quando il servizio riceve un comando Stop OnStop.       Quando il server riceve un comando di interruzione, viene utilizzato il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A>per verificare se il servizio accetta comandi Stop.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>è `true`, il comando di interruzione viene passato al servizio e viene chiamato il metodo OnStop se è definito.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se OnStop non viene implementata nel servizio, il server gestisce il comando di arresto.       Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>è `false`, il comando di interruzione viene ignorato.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Non viene passato al servizio. Il comando Stop restituisce e genera un&quot;eccezione.       OnStop deve essere sottoposto a override nella classe derivata. Per il servizio siano utili, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>e OnStop deve implementato nella classe del servizio.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected virtual void OnStop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnStop*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  id: RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ora di ulteriori richieste per un&quot;operazione in sospeso."
  remarks: "Il metodo RequestAdditionalTime è destinato a essere chiamato da sottoposto a override <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>metodi per richiedere ulteriore tempo per un&quot;operazione in sospeso, per impedire che Gestione controllo servizi (SCM) contrassegni il servizio come non risponde.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>  Se l&quot;operazione in sospeso non è una continuazione, pausa, start o stop, un <xref:System.InvalidOperationException>viene generata un&quot;eccezione.</xref:System.InvalidOperationException>"
  syntax:
    content: public void RequestAdditionalTime (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Il tempo richiesto in millisecondi."
  overload: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il servizio non è stato in sospeso."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  id: Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra il file eseguibile per un servizio con Gestione controllo servizi (SCM)."
  remarks: "Chiamare questo overload nella `main()` funzione del servizio eseguibile per registrare il servizio con Gestione controllo servizi. Dopo la chiamata di esecuzione, Gestione controllo servizi esegue un comando di avvio, che comporta una chiamata al <xref:System.ServiceProcess.ServiceBase.OnStart%2A>metodo nel servizio.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Il servizio non viene avviato finché non viene eseguito il comando di avvio.       Viene chiamato il metodo Run in modo analogo a come <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>per applicazioni Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>è `true`, viene scritta una voce nel registro eventi se il servizio specificato per il `service` parametro non viene avviato.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase service);
    parameters:
    - id: service
      type: System.ServiceProcess.ServiceBase
      description: "Oggetto <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> che indica un servizio da avviare."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>service</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  id: Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra il file eseguibile per più servizi con Gestione controllo servizi (SCM)."
  remarks: "Chiamare questo overload nella `main()` funzione del servizio eseguibile per registrare i servizi con Gestione controllo servizi. Dopo la chiamata di esecuzione, Gestione controllo servizi esegue i comandi di avvio, generare chiamate per il <xref:System.ServiceProcess.ServiceBase.OnStart%2A>metodi nei servizi.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> I servizi non vengono avviati fino a quando non vengono eseguiti i comandi di avvio.       Viene chiamato il metodo Run in modo analogo a come il <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>metodo per applicazioni Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>è `true`, viene scritta una voce nel registro eventi se non si avvia qualsiasi servizio nella matrice.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase[] services);
    parameters:
    - id: services
      type: System.ServiceProcess.ServiceBase[]
      description: "Matrice di istanze ServiceBase, che indica i servizi da avviare."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Non è stato fornito un servizio da avviare. La matrice potrebbe essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> o vuoto."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  id: ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene l&quot;handle del controllo del servizio per il servizio."
  remarks: "L&quot;handle del controllo del servizio viene utilizzato per comunicare con Gestione controllo servizi (SCM).  L&quot;handle può essere utilizzato per aggiornare le informazioni sullo stato della gestione controllo servizi per il servizio chiamante mediante non gestito `SetServiceStatus` (funzione)."
  syntax:
    content: protected IntPtr ServiceHandle { get; }
    return:
      type: System.IntPtr
      description: "Un <xref:System.IntPtr>struttura che contiene l&quot;handle del controllo del servizio per il servizio.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceHandle*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  id: ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra il gestore del comando e avvia il servizio."
  syntax:
    content: public void ServiceMainCallback (int argCount, IntPtr argPointer);
    parameters:
    - id: argCount
      type: System.Int32
      description: "Il numero di argomenti nella matrice di argomenti."
    - id: argPointer
      type: System.IntPtr
      description: "Un <xref:System.IntPtr>struttura che punta a una matrice di argomenti.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceName
  id: ServiceName
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Ottiene o imposta il nome breve utilizzato per identificare il servizio di sistema."
  remarks: "La proprietà ServiceName identifica il servizio di Gestione controllo servizi. Il valore di questa proprietà deve essere identico al nome registrato per il servizio nella <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName>proprietà della classe corrispondente. programma di installazione</xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> Nel codice, ServiceName del servizio è in genere impostato nella `main()` funzione del file eseguibile.       La proprietà ServiceName viene inoltre utilizzato per specificare il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>associato il <xref:System.ServiceProcess.ServiceBase.EventLog%2A>proprietà.</xref:System.ServiceProcess.ServiceBase.EventLog%2A> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Questa <xref:System.ServiceProcess.ServiceBase.EventLog%2A>è un&quot;istanza che scrive le informazioni di comando di servizio nel registro applicazione.</xref:System.ServiceProcess.ServiceBase.EventLog%2A>       La proprietà ServiceName, che fornisce la stringa di origine per il log eventi, deve essere impostato prima che il servizio scrive nel registro eventi. Tentativo di accedere al registro eventi prima di imposta il nome dell&quot;origine genererà un&quot;eccezione generata."
  syntax:
    content: public string ServiceName { get; set; }
    return:
      type: System.String
      description: "Il nome del servizio."
  overload: System.ServiceProcess.ServiceBase.ServiceName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il servizio è già stato avviato. La proprietà ServiceName non può essere modificata dopo l&quot;avvio del servizio."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il nome specificato è una stringa di lunghezza zero o più di <xref href=&quot;System.ServiceProcess.ServiceBase.MaxNameLength&quot;> </xref>, o il nome specificato contiene caratteri di barra o barra rovesciata in avanti."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Stop
  id: Stop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Arresta il servizio in esecuzione."
  remarks: "Il metodo di arresto imposta la stato del servizio per indicare un arresto in sospeso e chiama il <xref:System.ServiceProcess.ServiceBase.OnStop%2A>metodo.</xref:System.ServiceProcess.ServiceBase.OnStop%2A>  Dopo l&quot;applicazione è stato arrestato, lo stato del servizio è impostato su arrestato. Se l&quot;applicazione è un servizio ospitato, viene scaricato il dominio dell&quot;applicazione."
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.Stop*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ServiceProcess.ServiceBase.#ctor
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
- uid: System.ServiceProcess.ServiceBase.AutoLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
- uid: System.ServiceProcess.ServiceBase.EventLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
- uid: System.Diagnostics.EventLog
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
- uid: System.ServiceProcess.ServiceBase.OnContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
- uid: System.ServiceProcess.ServiceBase.OnPause
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
- uid: System.ServiceProcess.PowerBroadcastStatus
  parent: System.ServiceProcess
  isExternal: false
  name: PowerBroadcastStatus
  nameWithType: PowerBroadcastStatus
  fullName: System.ServiceProcess.PowerBroadcastStatus
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
- uid: System.ServiceProcess.SessionChangeDescription
  parent: System.ServiceProcess
  isExternal: false
  name: SessionChangeDescription
  nameWithType: SessionChangeDescription
  fullName: System.ServiceProcess.SessionChangeDescription
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.OnStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
- uid: System.ServiceProcess.ServiceBase
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
- uid: System.ServiceProcess.ServiceBase[]
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase[]
  spec.csharp:
  - uid: System.ServiceProcess.ServiceBase
    name: ServiceBase
    nameWithType: ServiceBase
    fullName: ServiceBase[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
- uid: System.ServiceProcess.ServiceBase.ServiceName
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceProcess.ServiceBase.Stop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
- uid: System.ServiceProcess.ServiceBase.#ctor*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase.ServiceBase
- uid: System.ServiceProcess.ServiceBase.AutoLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose
  nameWithType: ServiceBase.Dispose
- uid: System.ServiceProcess.ServiceBase.EventLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
- uid: System.ServiceProcess.ServiceBase.OnContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue
  nameWithType: ServiceBase.OnContinue
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand
  nameWithType: ServiceBase.OnCustomCommand
- uid: System.ServiceProcess.ServiceBase.OnPause*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause
  nameWithType: ServiceBase.OnPause
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent
  nameWithType: ServiceBase.OnPowerEvent
- uid: System.ServiceProcess.ServiceBase.OnSessionChange*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange
  nameWithType: ServiceBase.OnSessionChange
- uid: System.ServiceProcess.ServiceBase.OnShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown
  nameWithType: ServiceBase.OnShutdown
- uid: System.ServiceProcess.ServiceBase.OnStart*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart
  nameWithType: ServiceBase.OnStart
- uid: System.ServiceProcess.ServiceBase.OnStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop
  nameWithType: ServiceBase.OnStop
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime
  nameWithType: ServiceBase.RequestAdditionalTime
- uid: System.ServiceProcess.ServiceBase.Run*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run
  nameWithType: ServiceBase.Run
- uid: System.ServiceProcess.ServiceBase.ServiceHandle*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback
  nameWithType: ServiceBase.ServiceMainCallback
- uid: System.ServiceProcess.ServiceBase.ServiceName*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
- uid: System.ServiceProcess.ServiceBase.Stop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop
  nameWithType: ServiceBase.Stop
