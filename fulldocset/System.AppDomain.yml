### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Rappresenta un dominio applicazione, che è un ambiente isolato in cui vengono eseguite le applicazioni. Questa classe non può essere ereditata."
  remarks: "Domini applicazione, che sono rappresentati da oggetti AppDomain, forniscono i limiti di isolamento, scaricamento e sicurezza per l&quot;esecuzione di codice gestito.      -Per isolare le operazioni che potrebbero arrestare un processo, utilizzare i domini applicazione. Se lo stato del dominio dell&quot;applicazione che esegue un&quot;attività diventa instabile, senza interferire con il processo può essere scaricato il dominio applicazione. Questo è importante quando è necessario eseguire un processo per lunghi periodi senza riavviare il computer. È inoltre possibile utilizzare domini applicazione per isolare le attività che non devono condividere dati.      -Se un assembly viene caricato nel dominio applicazione predefinito, non può essere scaricato dalla memoria mentre il processo è in esecuzione. Tuttavia, se si apre un secondo dominio di applicazione da caricare ed eseguire l&quot;assembly, l&quot;assembly viene scaricato quando tale dominio applicazione viene scaricato. Utilizzare questa tecnica per ridurre al minimo il working set di processi a esecuzione prolungata che talvolta utilizzano DLL di grandi dimensioni.       Più domini applicazione è possono eseguire su un singolo processo. Tuttavia, non c&quot;è un relazione uno a uno tra domini applicazione e thread. Più thread può appartenere a un singolo dominio applicazione e durante un determinato thread non è limitato a un singolo dominio applicazione, in qualsiasi momento, un thread viene eseguito in un singolo dominio applicazione.       Domini applicazione vengono creati utilizzando il <xref:System.AppDomain.CreateDomain%2A>metodo.</xref:System.AppDomain.CreateDomain%2A> Le istanze di AppDomain sono utilizzate per caricare ed eseguire assembly (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Quando un AppDomain non è più in uso, può essere scaricato.       La classe AppDomain implementa un set di eventi che consentono alle applicazioni di rispondere quando viene caricato un assembly, quando un dominio applicazione verrà scaricato o quando viene generata un&quot;eccezione non gestita.       Per ulteriori informazioni sull&quot;utilizzo dei domini applicazione, vedere [domini applicazione](~/add/includes/ajax-current-ext-md.md).       Questa classe implementa il <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory>interfacce.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       È consigliabile non creare mai un wrapper di utilizzabile in remoto per un oggetto AppDomain. In questo modo è possibile pubblicare un riferimento all&quot;oggetto AppDomain, esporre metodi, ad esempio remoto <xref:System.AppDomain.CreateInstance%2A>accesso remoto e l&quot;eliminazione definitiva in modo efficace di sicurezza dall&quot;accesso di codice per l&quot;elemento AppDomain.</xref:System.AppDomain.CreateInstance%2A> Il client non autorizzati la connessione al dominio dell&quot;applicazione eseguita in modalità remota è stato possibile accedere a qualsiasi risorsa a che il dominio di applicazione ha accesso. Non creare wrapper utilizzabile in remoto per qualsiasi tipo che estende <xref:System.MarshalByRefObject>e che implementa metodi che potrebbero essere utilizzati da client non autorizzati di ignorare il sistema di sicurezza.</xref:System.MarshalByRefObject>      > [!CAUTION] > Il valore predefinito per il <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>proprietà `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Questa impostazione è sicura per i servizi. Per impedire a servizi di scaricare codice parzialmente attendibile, impostare questa proprietà su `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il contesto di attivazione per il dominio applicazione corrente."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Oggetto che rappresenta il contesto di attivazione per il dominio applicazione corrente, o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il dominio non dispone di alcun contesto di attivazione."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Aggiunge il nome di directory specificato all&quot;elenco di percorsi privati."
  remarks: "L&quot;utilizzo di questa proprietà è sconsigliato, perché potrebbe modificare il percorso di sondaggio per gli assembly dopo che sono già stati caricati. Utilizzare il <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>proprietà invece.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       Il percorso privato o il percorso di ricerca relativo, è il percorso relativo alla directory di base in cui il resolver dell&quot;assembly viene eseguita la ricerca degli assembly privati."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Il nome della directory da aggiungere al percorso privato."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene l&quot;identità dell&quot;applicazione nel dominio dell&quot;applicazione."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Oggetto che identifica l&quot;applicazione nel dominio dell&quot;applicazione."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene informazioni che descrivono le autorizzazioni concesse a un&quot;applicazione e se l&quot;applicazione dispone di un livello di attendibilità che consente l&quot;esecuzione."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Oggetto che incapsula le informazioni di autorizzazione e l&quot;attendibilità per l&quot;applicazione nel dominio dell&quot;applicazione."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Restituisce la visualizzazione di assembly nome dopo l&quot;applicazione dei criteri."
  remarks: "Il metodo accetta un assembly di ApplyPolicy nome visualizzato e restituisce il nome visualizzato di post-criteri. Ciò è utile se è necessario caricare un assembly mediante i criteri, in quanto il contesto reflection-only non applica i criteri."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nome visualizzato dell&quot;assembly nel formato fornito dal &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; proprietà."
    return:
      type: System.String
      description: "Una stringa contenente l&quot;assembly nome viene visualizzato dopo l&quot;applicazione dei criteri."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando viene caricato un assembly."
  remarks: "Il <xref:System.AssemblyLoadEventHandler>delegato per questo evento indica quale assembly è stato caricato.</xref:System.AssemblyLoadEventHandler>       Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException>viene generata un&quot;eccezione.</xref:System.Security.SecurityException>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando la risoluzione di un assembly ha esito negativo."
  remarks: "È responsabilità del <xref:System.ResolveEventHandler>per questo evento per l&quot;assembly specificato dal <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>, proprietà o per restituire null se l&quot;assembly non è riconosciuto.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> L&quot;assembly deve essere caricato in un contesto di esecuzione. Se viene caricato nel contesto reflection-only, il carico che ha causato l&quot;evento da generare.       Per istruzioni sull&quot;utilizzo di questo evento, vedere [Risoluzione caricamenti Assembly](~/add/includes/ajax-current-ext-md.md).       A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>proprietà restituisce l&quot;assembly che ha richiesto il caricamento dell&quot;assembly che non può essere risolto.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Ad esempio, il caricatore potrebbe essere in grado di caricare una dipendenza dell&quot;assembly richiesta perché l&quot;assembly richiedente e la relativa dipendenza non sono nel percorso di sondaggio. Conoscere l&quot;identità dell&quot;assembly richiedente potrebbe essere utile individuare la dipendenza o identificare la versione corretta, se è disponibile più di una versione della dipendenza. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > A partire dal [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler>evento viene generato per tutti gli assembly, inclusi gli assembly di risorse.</xref:System.ResolveEventHandler> Nelle versioni precedenti, l&quot;evento non è stato generato per gli assembly di risorse. Se il sistema operativo localizzato, il gestore può essere chiamato più volte: una volta per ogni impostazione cultura nella catena di fallback.       Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>proprietà restituisce il nome dell&quot;assembly prima che i criteri vengono applicati.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Se più di un gestore dell&quot;evento viene registrato per questo evento, l&quot;evento handlersarecalled in ordine fino a quando un gestore eventi restituisce un valore che non è `null`. Gestori di eventi successivi vengono ignorati.       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene la directory di base usata dal resolver dell&quot;assembly per verificare la presenza di assembly."
  remarks: "Questa proprietà corrisponde al <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>proprietà.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Può anche essere recuperato tramite il <xref:System.AppDomain.GetData%2A>(metodo) con la stringa &quot;APPBASE&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "Directory di base che utilizza il resolver dell&quot;assembly per verificare la presenza di assembly."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Reimposta il percorso che specifica il percorso degli assembly privati su una stringa vuota (&quot;&quot;)."
  remarks: "Il percorso privato è un percorso relativo alla directory di base che common language runtime cerca gli assembly privati.       Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Reimposta l&quot;elenco delle directory contenenti assembly replicati mediante copiata shadow su una stringa vuota (&quot;&quot;)."
  remarks: "Il percorso della copia shadow è un elenco di directory in cui replicati gli assembly vengono archiviati.       Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>e [copie Shadow di assembly](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly contenente il tipo e il nome del tipo."
  remarks: "Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.       Il valore restituito deve per essere annullato il wrapping per accedere all&quot;oggetto reale.       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> attributo con un valore di `true` è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un&quot;istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException>viene generata un&quot;eccezione.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome di un file contenente un assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome del tipo richiesto."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Il tipo non può essere caricato."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico senza parametri."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>è una classe astratta.       - oppure - questo membro è stato richiamato con un meccanismo di associazione tardiva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>è una stringa vuota (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "L&quot;oggetto COM che viene fatto riferimento è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly contenente il tipo e il nome del tipo."
  remarks: "Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.       Il valore restituito deve per essere annullato il wrapping per accedere all&quot;oggetto reale.       A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>attributo con un valore di `true` è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un&quot;istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException>viene generata un&quot;eccezione.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome di un file contenente un assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome del tipo richiesto."
    - id: hashValue
      type: System.Byte[]
      description: "Rappresenta il valore del codice hash calcolato."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Rappresenta l&quot;algoritmo hash utilizzato dal manifesto dell&quot;assembly."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Il tipo non può essere caricato."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico senza parametri."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>è una classe astratta.       - oppure - questo membro è stato richiamato con un meccanismo di associazione tardiva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>è una stringa vuota (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "L&quot;oggetto COM che viene fatto riferimento è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione con il nome specificato."
  remarks: "Il `friendlyName` parametro ha lo scopo di identificare il dominio in modo significativo per gli utenti. Questa stringa deve essere adatta per la visualizzazione nelle interfacce utente.       Questo overload del metodo utilizza il <xref:System.AppDomainSetup>informazioni dal dominio applicazione predefinito.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione con il nome specificato usando l&quot;evidenza fornita."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidenza che stabilisce l&quot;identità del codice che viene eseguito nel dominio dell&quot;applicazione. Passare <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per usare l&quot;evidenza del dominio applicazione corrente."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione usando il nome specificato, l&quot;evidenza e informazioni di impostazione del dominio applicazione."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidenza che stabilisce l&quot;identità del codice che viene eseguito nel dominio dell&quot;applicazione. Passare <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per usare l&quot;evidenza del dominio applicazione corrente."
    - id: info
      type: System.AppDomainSetup
      description: "Oggetto che contiene informazioni di inizializzazione del dominio applicazione."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione con il nome specificato, la prova, informazioni di impostazione del dominio applicazione, set di autorizzazioni predefinito e matrice di assembly completamente attendibili."
  remarks: "È necessario impostare il <xref:System.AppDomainSetup.ApplicationBase%2A>proprietà del <xref:System.AppDomainSetup>oggetto che viene fornito per `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> In caso contrario, viene generata un&quot;eccezione.       Se `securityInfo` viene omesso, viene utilizzato l&quot;evidenza del dominio applicazione corrente.       Le informazioni fornite per `grantSet` e `fullTrustAssemblies` viene utilizzato per creare un <xref:System.Security.Policy.ApplicationTrust>oggetto per il nuovo dominio applicazione.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere la descrizione di <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidenza che stabilisce l&quot;identità del codice che viene eseguito nel dominio dell&quot;applicazione. Passare <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per usare l&quot;evidenza del dominio applicazione corrente."
    - id: info
      type: System.AppDomainSetup
      description: "Oggetto che contiene informazioni di inizializzazione del dominio applicazione."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Un set di autorizzazioni predefinito concesso a tutti gli assembly caricati nel nuovo dominio applicazione che non sono concesse autorizzazioni specifiche."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "Matrice di nomi sicuri che rappresentano gli assembly da considerare come completamente attendibili nel nuovo dominio applicazione."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il dominio applicazione è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - o - <xref:System.AppDomainSetup.ApplicationBase*>non è impostata sul <xref href=&quot;System.AppDomainSetup&quot;> </xref> oggetto fornito per <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione con il nome indicato mediante un&quot;evidenza, percorso base dell&quot;applicazione, il percorso di ricerca relativo e un parametro che specifica se una copia shadow di un assembly deve essere caricato nel dominio applicazione."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidenza che stabilisce l&quot;identità del codice che viene eseguito nel dominio dell&quot;applicazione. Passare <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per usare l&quot;evidenza del dominio applicazione corrente."
    - id: appBasePath
      type: System.String
      description: "Directory di base che utilizza il resolver dell&quot;assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Il percorso relativo alla directory di base in cui deve essere verificata la dal resolver dell&quot;assembly per gli assembly privati. Per ulteriori informazioni, vedere <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Se <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, una copia shadow di un assembly viene caricata nel dominio applicazione."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea un nuovo dominio applicazione con il nome indicato mediante un&quot;evidenza, percorso base dell&quot;applicazione, il percorso di ricerca relativo e un parametro che specifica se una copia shadow di un assembly deve essere caricato nel dominio applicazione. Specifica un metodo di callback che viene richiamato quando viene inizializzato il dominio applicazione e una matrice di argomenti stringa da passare al metodo di callback."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Il nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidenza che stabilisce l&quot;identità del codice che viene eseguito nel dominio dell&quot;applicazione. Passare <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per usare l&quot;evidenza del dominio applicazione corrente."
    - id: appBasePath
      type: System.String
      description: "Directory di base che utilizza il resolver dell&quot;assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Il percorso relativo alla directory di base in cui deve essere verificata la dal resolver dell&quot;assembly per gli assembly privati. Per ulteriori informazioni, vedere <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per caricare una copia shadow di un assembly nel dominio dell&quot;applicazione."
    - id: adInit
      type: System.AppDomainInitializer
      description: "Un <xref href=&quot;System.AppDomainInitializer&quot;> </xref> delegato che rappresenta un metodo di callback da richiamare quando il nuovo <xref href=&quot;System.AppDomain&quot;> </xref> viene inizializzato l&quot;oggetto."
    - id: adInitArgs
      type: System.String[]
      description: "Matrice di argomenti stringa da passare al metodo di callback rappresentato dal `adInit`, quando il nuovo <xref href=&quot;System.AppDomain&quot;> </xref> viene inizializzato l&quot;oggetto."
    return:
      type: System.AppDomain
      description: "Il dominio applicazione appena creato."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nell&quot;assembly specificato."
  remarks: "Questo metodo chiama il costruttore predefinito per `typeName`.       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName>       Un tentativo di chiamare CreateInstance in un dominio di applicazione di destinazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell&quot;assembly nel dominio dell&quot;applicazione di destinazione. Poiché un <xref:System.Reflection.Assembly>non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly>per l&quot;assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l&quot;assembly nel dominio applicazione corrente e il carico potrebbe non riuscire.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> L&quot;assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall&quot;assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nell&quot;assembly specificato. Un parametro specifica una matrice di attributi di attivazione."
  remarks: "Questo metodo chiama il costruttore predefinito per `typeName`.       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName>       Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A>una destinazione dominio dell&quot;applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell&quot;assembly nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstance%2A> Poiché un <xref:System.Reflection.Assembly>non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly>per l&quot;assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l&quot;assembly nel dominio applicazione corrente e il carico potrebbe non riuscire.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> L&quot;assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall&quot;assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nell&quot;assembly specificato. I parametri specificano uno strumento di associazione, flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti e gli attributi di attivazione facoltativi."
  remarks: "Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName>       Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A>una destinazione dominio dell&quot;applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell&quot;assembly nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstance%2A> Poiché un <xref:System.Reflection.Assembly>non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly>per l&quot;assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l&quot;assembly nel dominio applicazione corrente e il carico potrebbe non riuscire.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> L&quot;assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall&quot;assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - <code>assemblyName</code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore corrispondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nell&quot;assembly specificato. I parametri specificano uno strumento di associazione, flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti, gli attributi di attivazione e l&quot;autorizzazione per creare il tipo."
  remarks: "Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName>       Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A>una destinazione dominio dell&quot;applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell&quot;assembly nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstance%2A> Poiché un <xref:System.Reflection.Assembly>non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly>per l&quot;assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l&quot;assembly nel dominio applicazione corrente e il carico potrebbe non riuscire.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> L&quot;assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall&quot;assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Le informazioni usate per autorizzare la creazione di `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza specificata da <code> typeName </code>. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore corrispondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code> securityAttributes </code> deve essere<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato. I parametri specificano l&quot;assembly in cui è definito il tipo e il nome del tipo."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Questo metodo chiama il costruttore predefinito per `typeName`.       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName> Vedere il <xref:System.Type.FullName%2A?displayProperty=fullName>proprietà per il formato di `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se si effettua una chiamata di associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da CreateInstanceAndUnwrap e tale metodo esegue una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` diverso dall&quot;assembly corrente o l&quot;assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento si verifica anche se l&quot;associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l&quot;assembly `C`, potrebbe non riuscire."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    return:
      type: System.Object
      description: "Un&quot;istanza dell&quot;oggetto specificato da <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato. I parametri specificano l&quot;assembly in cui il tipo è definito, il nome del tipo e una matrice di attributi di attivazione."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Questo metodo chiama il costruttore predefinito per `typeName`.       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName> Vedere il <xref:System.Type.FullName%2A?displayProperty=fullName>proprietà per il formato di `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se si effettua una chiamata di associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` diverso dall&quot;assembly corrente o l&quot;assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Il caricamento si verifica anche se l&quot;associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l&quot;assembly `C`, potrebbe non riuscire."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Object
      description: "Un&quot;istanza dell&quot;oggetto specificato da <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nell&quot;assembly specificato, indicando se ignorare il caso del nome del tipo; gli attributi di associazione e lo strumento di associazione usati per selezionare il tipo da creare; gli argomenti del costruttore. le impostazioni cultura e gli attributi di attivazione."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName> Vedere il <xref:System.Type.FullName%2A?displayProperty=fullName>proprietà per il formato di `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se si effettua una chiamata di associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` diverso dall&quot;assembly corrente o l&quot;assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Il caricamento si verifica anche se l&quot;associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l&quot;assembly `C`, potrebbe non riuscire."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Un oggetto di specifica della lingua usato per regolare la coercizione dei tipi. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> per il thread corrente verrà usato."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto. che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Object
      description: "Un&quot;istanza dell&quot;oggetto specificato da <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore corrispondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - <code>assemblyName</code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato. I parametri specificano il nome del tipo e la modalità individuazione e creazione."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Vedere <xref:System.Reflection.AssemblyName>per il formato di `assemblyName`.</xref:System.Reflection.AssemblyName> Vedere il <xref:System.Type.FullName%2A?displayProperty=fullName>proprietà per il formato di `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se si effettua una chiamata di associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` diverso dall&quot;assembly corrente o l&quot;assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Il caricamento si verifica anche se l&quot;associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l&quot;assembly `C`, potrebbe non riuscire."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Un oggetto di specifica della lingua usato per regolare la coercizione dei tipi. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> per il thread corrente verrà usato."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Le informazioni usate per autorizzare la creazione di `typeName`."
    return:
      type: System.Object
      description: "Un&quot;istanza dell&quot;oggetto specificato da <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore corrispondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>non è stato trovato <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone dell&quot;autorizzazione per chiamare questo costruttore."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Il costruttore predefinito per `typeName` viene richiamato.       Per ulteriori informazioni, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando il metodo CreateInstanceFrom viene utilizzato per creare un&quot;istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l&quot;assembly viene caricato nel dominio dell&quot;applicazione di destinazione. Tuttavia, se l&quot;istanza è annullato il wrapping nel dominio dell&quot;applicazione chiamante, utilizzando l&quot;istanza annullato il wrapping in determinati modi può causare l&quot;assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l&quot;istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l&quot;assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.      -Se un&quot;altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell&quot;applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException>possono verificarsi.</xref:System.MissingMethodException>      -Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException>può essere generata quando viene effettuato un tentativo di cast dell&quot;istanza.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome, incluso il percorso, di un file contenente un assembly che definisce il tipo richiesto. L&quot;assembly viene caricato usando il <xref:System.Reflection.Assembly.LoadFrom*>metodo.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico senza parametri."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Il costruttore predefinito per `typeName` viene richiamato.       Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando il <xref:System.AppDomain.CreateInstanceFrom%2A>metodo viene utilizzato per creare un&quot;istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l&quot;assembly viene caricato nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstanceFrom%2A> Tuttavia, se l&quot;istanza è annullato il wrapping nel dominio dell&quot;applicazione chiamante, utilizzando l&quot;istanza annullato il wrapping in determinati modi può causare l&quot;assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l&quot;istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l&quot;assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.      -Se un&quot;altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell&quot;applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException>possono verificarsi.</xref:System.MissingMethodException>      -Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException>può essere generata quando viene effettuato un tentativo di cast dell&quot;istanza.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome, incluso il percorso, di un file contenente un assembly che definisce il tipo richiesto. L&quot;assembly viene caricato usando il <xref:System.Reflection.Assembly.LoadFrom*>metodo.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Per ulteriori informazioni, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando il <xref:System.AppDomain.CreateInstanceFrom%2A>metodo viene utilizzato per creare un&quot;istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l&quot;assembly viene caricato nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstanceFrom%2A> Tuttavia, se l&quot;istanza è annullato il wrapping nel dominio dell&quot;applicazione chiamante, utilizzando l&quot;istanza annullato il wrapping in determinati modi può causare l&quot;assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l&quot;istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l&quot;assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.      -Se un&quot;altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell&quot;applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException>possono verificarsi.</xref:System.MissingMethodException>      -Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException>può essere generata quando viene effettuato un tentativo di cast dell&quot;istanza.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome, incluso il percorso, di un file contenente un assembly che definisce il tipo richiesto. L&quot;assembly viene caricato usando il <xref:System.Reflection.Assembly.LoadFrom*>metodo.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - <code>assemblyFile</code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando il <xref:System.AppDomain.CreateInstanceFrom%2A>metodo viene utilizzato per creare un&quot;istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l&quot;assembly viene caricato nel dominio dell&quot;applicazione di destinazione.</xref:System.AppDomain.CreateInstanceFrom%2A> Tuttavia, se l&quot;istanza è annullato il wrapping nel dominio dell&quot;applicazione chiamante, utilizzando l&quot;istanza annullato il wrapping in determinati modi può causare l&quot;assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l&quot;istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l&quot;assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.      -Se un&quot;altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell&quot;applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException>possono verificarsi.</xref:System.MissingMethodException>      -Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException>può essere generata quando viene effettuato un tentativo di cast dell&quot;istanza.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome, incluso il percorso, di un file contenente un assembly che definisce il tipo richiesto. L&quot;assembly viene caricato usando il <xref:System.Reflection.Assembly.LoadFrom*>metodo.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Le informazioni usate per autorizzare la creazione di `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Un oggetto che rappresenta un wrapper per la nuova istanza o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato. Il valore restituito deve essere annullato il wrapping per accedere all&quot;oggetto reale."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code> securityAttributes </code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Questa istanza è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Questo metodo chiama il costruttore predefinito per `typeName`.       Per ulteriori informazioni, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome del file e il percorso dell&quot;assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    return:
      type: System.Object
      description: "L&quot;oggetto richiesto, o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico senza parametri."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Questo metodo chiama il costruttore predefinito per `typeName`.       Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome del file e il percorso dell&quot;assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly (vedere il &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà)."
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Object
      description: "L&quot;oggetto richiesto, o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico senza parametri."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato, indicando se ignorare il caso del nome del tipo; gli attributi di associazione e lo strumento di associazione usati per selezionare il tipo da creare; gli argomenti del costruttore. le impostazioni cultura e gli attributi di attivazione."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file e il percorso dell&quot;assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    return:
      type: System.Object
      description: "L&quot;oggetto richiesto, o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - <code>assemblyName</code> è stato compilato con una versione successiva di common language runtime che la versione attualmente caricata."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Crea una nuova istanza del tipo specificato definito nel file di assembly specificato."
  remarks: "Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metodo.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome del file e il percorso dell&quot;assembly che definisce il tipo richiesto."
    - id: typeName
      type: System.String
      description: "Il nome completo del tipo richiesto, compreso lo spazio dei nomi ma non l&quot;assembly, restituito dal &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; proprietà."
    - id: ignoreCase
      type: System.Boolean
      description: "Valore booleano che specifica se eseguire una ricerca con distinzione maiuscole/minuscole o non."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Una combinazione di zero o più flag di bit che influiscono sulla ricerca di `typeName` costruttore. Se `bindingAttr` è zero, una ricerca con distinzione maiuscole/minuscole per i costruttori pubblici viene effettuata."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipi di oggetto che consente l&quot;associazione, la coercizione di argomento, la chiamata dei membri e il recupero di <xref:System.Reflection.MemberInfo>oggetti tramite reflection.</xref:System.Reflection.MemberInfo> Se `binder` è null, verrà usato il binder predefinito."
    - id: args
      type: System.Object[]
      description: "Gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere in numero, ordine e tipo ai parametri del costruttore da richiamare. Se si preferisce, il costruttore predefinito `args` deve essere una matrice vuota o null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informazioni specifiche delle impostazioni cultura che regolano la coercizione di `args` ai tipi formali dichiarati per il `typeName` costruttore. Se `culture` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>per il thread corrente verrà usato.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Matrice di uno o più attributi che possono prendere parte all&quot;attivazione. In genere, una matrice che contiene un singolo <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> oggetto che specifica l&quot;URL necessario per attivare un oggetto remoto.       Questo parametro è correlato agli oggetti attivati dal client. Attivazione del client è una tecnologia legacy che viene mantenuta per compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Le applicazioni distribuite devono usare invece Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Le informazioni usate per autorizzare la creazione di `typeName`."
    return:
      type: System.Object
      description: "L&quot;oggetto richiesto, o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> non viene trovato."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>non è stato trovato."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>non è stato trovato <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "È stato trovato alcun costruttore pubblico corrispondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Il chiamante non dispone di autorizzazioni sufficienti per chiamare questo costruttore."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyName</code> è stato compilato con una versione successiva."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il dominio applicazione corrente per l&quot;oggetto corrente <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "Il dominio applicazione corrente."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico con la modalità di accesso e al nome specificato."
  remarks: "Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità di accesso per l&quot;assembly dinamico."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con la modalità di accesso e al nome specificato."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico con il nome specificato, la modalità di accesso e gli attributi personalizzati."
  remarks: "Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità di accesso per l&quot;assembly dinamico."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Elenco enumerabile di attributi da applicare all&quot;assembly o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se non sono presenti attributi."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, modalità di accesso e l&quot;evidenza."
  remarks: "Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly>per dinamica <xref:System.Reflection.Assembly>viene definito e contrassegna i criteri come risolti.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinamica <xref:System.Reflection.Assembly>viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly>è stato salvato.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso e directory di archiviazione."
  remarks: "Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, la directory predefinita sarà la directory corrente."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico con il nome specificato, la modalità di accesso e gli attributi personalizzati e usando l&quot;origine specificata per il contesto di sicurezza."
  remarks: "Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità di accesso per l&quot;assembly dinamico."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Elenco enumerabile di attributi da applicare all&quot;assembly o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se non sono presenti attributi."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "L&quot;origine del contesto di sicurezza."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il valore di <code> securityContextSource </code> non è uno dei valori di enumerazione."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, directory di archiviazione e la prova."
  remarks: "Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly>per dinamica <xref:System.Reflection.Assembly>viene definito e contrassegna i criteri come risolti.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinamica <xref:System.Reflection.Assembly>viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly>è stato salvato.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, la directory predefinita sarà la directory corrente."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso e le richieste di autorizzazione."
  remarks: "Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono utilizzate, a meno che l&quot;assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l&quot;overload del metodo di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza anche come richiesto e autorizzazioni, fornire un <xref:System.Security.Policy.Evidence>oggetto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, directory di archiviazione e opzione di sincronizzazione."
  remarks: "Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Se `isSynchronized` è `true`, i metodi seguenti dell&quot;oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder>verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly dinamico. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, viene utilizzata la directory corrente."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per sincronizzare la creazione di moduli, tipi e membri nell&quot;assembly dinamico. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Elenco enumerabile di attributi da applicare all&quot;assembly o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se non sono presenti attributi."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, l&quot;evidenza e le richieste di autorizzazione."
  remarks: "Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l&quot;assembly dinamico viene salvato e ricaricato in memoria.      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly>per dinamica <xref:System.Reflection.Assembly>viene definito e contrassegna i criteri come risolti.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinamica <xref:System.Reflection.Assembly>viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly>è stato salvato.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, directory di archiviazione e le richieste di autorizzazione."
  remarks: "Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono utilizzate, a meno che l&quot;assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l&quot;overload del metodo di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza anche come richiesto e autorizzazioni, fornire un <xref:System.Security.Policy.Evidence>oggetto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A>metodo che specifica l&quot;evidenza e le autorizzazioni, fornire l&quot;evidenza l&quot;assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, la directory predefinita sarà la directory corrente."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, directory di archiviazione, evidenza e le richieste di autorizzazione."
  remarks: "Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l&quot;assembly dinamico viene salvato e ricaricato in memoria.      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly>per dinamica <xref:System.Reflection.Assembly>viene definito e contrassegna i criteri come risolti.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinamica <xref:System.Reflection.Assembly>viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly>è stato salvato.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, la directory predefinita sarà la directory corrente."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico usando il nome specificato, la modalità di accesso, directory di archiviazione, evidenza, le richieste di autorizzazione e opzione di sincronizzazione."
  remarks: "Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l&quot;assembly dinamico viene salvato e ricaricato in memoria.      > [!NOTE] > Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag>nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato.</xref:System.Security.Permissions.SecurityPermissionFlag> Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>quando usato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Solo i chiamanti completamente attendibili possono fornire la propria evidence quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly>per dinamica <xref:System.Reflection.Assembly>viene definito e contrassegna i criteri come risolti.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinamica <xref:System.Reflection.Assembly>viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly>è stato salvato.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se `isSynchronized` è `true`, i metodi seguenti dell&quot;oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder>verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino a quando il loro completamento."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly dinamico. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, la directory predefinita sarà la directory corrente."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per sincronizzare la creazione di moduli, tipi e membri nell&quot;assembly dinamico. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definisce un assembly dinamico con il nome specificato, la modalità di accesso, directory di archiviazione, evidenza, le richieste di autorizzazione, opzione di sincronizzazione e attributi personalizzati."
  remarks: "Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Le richieste di autorizzazione specificate per il `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parametri vengono utilizzati solo se il `evidence` anche viene fornito alcun parametro, o se l&quot;assembly dinamico viene salvato e ricaricato in memoria.      > [!NOTE] > Quando si sviluppa codice che genera gli assembly dinamici, si consiglia di includere il <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>flag nel `refusedPermissions` parametro.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> L&quot;inclusione di questo flag garantisce che il Microsoft intermediate language (MSIL) verrà verificata. Questa tecnica rileverà la generazione di codice non verificabile, che in caso contrario è molto difficili da rilevare non intenzionale. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException>viene generata quando viene utilizzato con il codice che richiede l&quot;attendibilità totale.</xref:System.Security.SecurityException>       Solo i chiamanti completamente attendibili possono fornire l&quot;evidenza quando si definisce un dinamico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Il runtime esegue il mapping di <xref:System.Security.Policy.Evidence>tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</xref:System.Security.Policy.Evidence> Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni (ovvero, il correnti concesse e negate) dall&quot;assembly del chiamante all&quot;assembly dinamico che viene definito, contrassegnando i criteri come risolti.       Se l&quot;assembly dinamico viene salvato su disco, successivi caricamenti verranno concesse autorizzazioni in base ai criteri associati al percorso in cui è stato salvato l&quot;assembly dinamico.       Se `isSynchronized` è `true`, i metodi seguenti dell&quot;oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder>verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri.       Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Identità univoca dell&quot;assembly dinamico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "La modalità in cui si accederà all&quot;assembly dinamico."
    - id: dir
      type: System.String
      description: "Il nome della directory in cui verrà salvato l&quot;assembly dinamico. Se `dir` è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, viene utilizzata la directory corrente."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "L&quot;evidenza fornita per l&quot;assembly dinamico. L&quot;evidenza viene usata senza modifiche come il set di evidenza utilizzata per la risoluzione dei criteri finale."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni obbligatoria."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni facoltativa."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Richiesta di autorizzazioni rifiutata."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per sincronizzare la creazione di moduli, tipi e membri nell&quot;assembly dinamico. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Elenco enumerabile di attributi da applicare all&quot;assembly o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se non sono presenti attributi."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Un assembly dinamico con il nome e funzionalità specificati."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - o - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> proprietà di <code> name </code> inizia con uno spazio vuoto o contiene una barra rovesciata in avanti o indietro."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue il codice in un altro dominio applicazione che è identificato dal delegato specificato."
  remarks: '`callBackDelegate`specificare un marshalling dal valore, <xref:System.MarshalByRefObject>, o <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Delegato che specifica un metodo da chiamare."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il gestore di dominio fornito dall&quot;host quando è stato inizializzato il dominio dell&quot;applicazione."
  remarks: "Un host non gestito di common language runtime (CLR) è possibile fornire un gestore di dominio. Il gestore di dominio può partecipare all&quot;inizializzazione del nuovo dominio applicazione e fornire altri gestori, come ad esempio un <xref:System.Security.HostSecurityManager>, che partecipano alle operazioni del dominio dell&quot;applicazione.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Oggetto che rappresenta il gestore di dominio fornito dall&quot;host quando è stato inizializzato il dominio dell&quot;applicazione o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se è stato fornito alcun gestore di dominio."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando un <xref href=&quot;System.AppDomain&quot;> </xref> sta per essere scaricato."
  remarks: "Il <xref:System.EventHandler>delegato per questo evento è possibile eseguire qualsiasi attività di chiusura prima che venga scaricato il dominio dell&quot;applicazione.</xref:System.EventHandler>       Ogni dominio applicazione che deve essere eseguita l&quot;elaborazione quando viene scaricato deve registrare un gestore eventi per questo evento. Un gestore eventi condiviso non deve essere utilizzato, in quanto il <xref:System.EventHandler>delegato identifica il dominio che sta per essere scaricato.</xref:System.EventHandler>      > [!NOTE] > Questo evento non viene mai generato nel dominio applicazione predefinito.       Non basarsi su presupposti sul thread che in cui viene generato l&quot;evento. L&quot;evento può essere generato in un thread diverso da quello che ha chiamato la <xref:System.AppDomain.Unload%2A>metodo.</xref:System.AppDomain.Unload%2A>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene la directory usata dal resolver dell&quot;assembly per verificare la presenza di assembly creati dinamicamente."
  remarks: "Per impostare la directory dinamica, assegnare un percorso di directory di base per il <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>proprietà del <xref:System.AppDomainSetup>oggetto che verrà utilizzato per creare un nuovo dominio applicazione.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> Il percorso della directory base assegnare alla proprietà viene modificato mediante l&quot;aggiunta di una sottodirectory il cui nome semplice è il codice hash della stringa assegnare la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>proprietà, pertanto è il formato della directory base *percorso originale*\\\\*il codice hash*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> La directory dinamica è una sottodirectory della directory di base. Il nome semplice è il valore della <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>proprietà, pertanto il formato è *percorso originale*\\\\*il codice hash*\\\\*nome applicazione*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "La directory usata dal resolver dell&quot;assembly per verificare la presenza di assembly creati dinamicamente."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> associato al dominio applicazione."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "Evidenza associata al dominio applicazione."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Per creare il <xref:System.AppDomain>per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A>metodo.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato, usando l&quot;evidenza specificata."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Il <xref:System.AppDomain.ExecuteAssembly%2A>metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</xref:System.AppDomain.ExecuteAssembly%2A>       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato, usando gli argomenti specificati."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    - id: args
      type: System.String[]
      description: "Gli argomenti per il punto di ingresso dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - <code>assemblyFile</code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato, usando l&quot;evidenza specificata e gli argomenti."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "L&quot;evidenza fornita per l&quot;assembly."
    - id: args
      type: System.String[]
      description: "Gli argomenti per il punto di ingresso dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code>assemblySecurity</code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato, usando gli argomenti specificati, il valore hash e l&quot;algoritmo hash."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    - id: args
      type: System.String[]
      description: "Gli argomenti per il punto di ingresso dell&quot;assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Rappresenta il valore del codice hash calcolato."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Rappresenta l&quot;algoritmo hash utilizzato dal manifesto dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - <code>assemblyFile</code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly contenuto nel file specificato, usando l&quot;evidenza specificata, argomenti, il valore hash e algoritmo hash."
  remarks: "L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Questo metodo carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A>(metodo), che carica l&quot;assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A>metodo.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Il nome del file che contiene l&quot;assembly da eseguire."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "L&quot;evidenza fornita per l&quot;assembly."
    - id: args
      type: System.String[]
      description: "Gli argomenti per il punto di ingresso dell&quot;assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Rappresenta il valore del codice hash calcolato."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Rappresenta l&quot;algoritmo hash utilizzato dal manifesto dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyFile</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code>assemblySecurity</code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue un assembly dato il nome visualizzato."
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.       Per creare il <xref:System.AppDomain>per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A>metodo.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code> assemblyName </code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly dato un <xref:System.Reflection.AssemblyName>, usando gli argomenti specificati.</xref:System.Reflection.AssemblyName>"
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Un <xref:System.Reflection.AssemblyName>che rappresenta il nome dell&quot;assembly.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - <code> assemblyName </code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue un assembly in base al nome visualizzato, usando l&quot;evidenza specificata."
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo con un <xref:System.Security.Policy.Evidence>parametro evidenze vengono uniti.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo sostituiscono quelle di evidenza fornita dal caricatore.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code> assemblyName </code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly in base al nome visualizzato, usando gli argomenti specificati."
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - <code> assemblyName </code> è stato compilato con una versione successiva di common language runtime rispetto alla versione attualmente caricata."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly dato un <xref:System.Reflection.AssemblyName>, usando l&quot;evidenza specificata e gli argomenti.</xref:System.Reflection.AssemblyName>"
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.      > [!NOTE] > Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo con un <xref:System.Security.Policy.Evidence>parametro evidenze vengono uniti.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo sostituiscono quelle di evidenza fornita dal caricatore.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Un <xref:System.Reflection.AssemblyName>che rappresenta il nome dell&quot;assembly.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    - id: args
      type: System.String[]
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code> assemblyName </code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code>assemblySecurity</code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue l&quot;assembly in base al nome visualizzato, usando l&quot;evidenza specificata e gli argomenti."
  remarks: "Il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A>(metodo), ma specifica l&quot;assembly con nome visualizzato o <xref:System.Reflection.AssemblyName>anziché dal percorso del file.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A>Carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A>metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A>metodo.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       L&quot;assembly inizia l&quot;esecuzione nel punto di ingresso specificato nell&quot;intestazione di .NET Framework.       Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.      > [!NOTE] > Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo con un <xref:System.Security.Policy.Evidence>parametro evidenze vengono uniti.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodo sostituiscono quelle di evidenza fornita dal caricatore.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    - id: args
      type: System.String[]
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    return:
      type: System.Int32
      description: "Il valore restituito dal punto di ingresso dell&quot;assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non viene trovato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "L&quot;assembly specificato da <code> assemblyName </code> è stato trovato, ma non può essere caricato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "L&quot;assembly specificato da <code> assemblyName </code> non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code> assemblyName </code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code>assemblySecurity</code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "L&quot;assembly specificato non dispone di alcun punto di ingresso."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando viene generata un&quot;eccezione nel codice gestito, prima che il runtime cerchi lo stack di chiamate per un gestore di eccezioni nel dominio dell&quot;applicazione."
  remarks: "Questo evento è solo una notifica. Gestione di questo evento non gestire l&quot;eccezione, né altera successive eccezioni in alcun modo. Dopo che è stato generato l&quot;evento e i gestori eventi siano stati richiamati, common language runtime (CLR) inizia la ricerca di un gestore per l&quot;eccezione. FirstChanceException fornisce il dominio applicazione con una prima opportunità per esaminare qualsiasi eccezione gestita.       L&quot;evento può essere gestito per ogni dominio applicazione. Se un thread passa attraverso più domini applicazione durante l&quot;esecuzione di una chiamata, l&quot;evento viene generato in ogni dominio applicazione che ha registrato un gestore di evento, prima di CLR inizia la ricerca per un gestore eccezioni corrispondente nel dominio dell&quot;applicazione. Dopo l&quot;evento è stata gestita, viene eseguita una ricerca per un gestore eccezioni corrispondente nel dominio dell&quot;applicazione. Se non viene trovato, viene generato l&quot;evento nel dominio dell&quot;applicazione successivo.       È necessario gestire tutte le eccezioni che si verificano nel gestore per l&quot;evento FirstChanceException. In caso contrario, FirstChanceException viene generato in modo ricorsivo. Ciò potrebbe causare un overflow dello stack e la chiusura dell&quot;applicazione. È consigliabile implementare i gestori eventi per questo evento come aree a esecuzione vincolata (CER), per evitare che le eccezioni correlate all&quot;infrastruttura, ad esempio di memoria insufficiente o overflow dello stack di influire sulla macchina virtuale durante l&quot;elaborazione della notifica dell&quot;eccezione.       Questo evento non viene generato per le eccezioni che indicano il danneggiamento dello stato del processo, ad esempio le violazioni di accesso, a meno che il gestore dell&quot;evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Common language runtime sospende le interruzioni di thread, mentre viene gestito l&quot;evento di notifica."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il nome descrittivo del dominio applicazione."
  remarks: "Il nome descrittivo del dominio applicazione predefinito è il nome del file dell&quot;eseguibile del processo. Ad esempio, se l&quot;eseguibile usato per avviare il processo è `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, il nome descrittivo del dominio applicazione predefinito è `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "Il nome descrittivo del dominio applicazione."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene gli assembly caricati nel contesto di esecuzione di questo dominio applicazione."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Matrice di assembly nel dominio applicazione."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene l&quot;identificatore del thread corrente."
  remarks: "Utilizzare il <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>proprietà, che rimane stabile anche quando .NET Framework è ospitato da un ambiente che supporta i fiber (vale a dire il thread lightweight).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "Intero con segno a 32 bit che rappresenta l&quot;identificatore del thread corrente."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il valore archiviato nel dominio applicazione corrente per il nome specificato."
  remarks: "Utilizzare questo metodo per recuperare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <xref:System.AppDomain>.</xref:System.AppDomain> Si noti che il confronto di `name` con il nome di coppie chiave-valore è tra maiuscole e minuscole.       La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell&quot;applicazione. È possibile controllare i valori mediante il metodo GetData o l&quot;equivalente <xref:System.AppDomainSetup>proprietà.</xref:System.AppDomainSetup>       È possibile inserire o modificare la propria coppie nome / dati definiti dall&quot;utente con il <xref:System.AppDomain.SetData%2A>(metodo) e verificarne i valori con il metodo GetData.</xref:System.AppDomain.SetData%2A>       Nella tabella seguente vengono descritti il `name` di ogni voce nel sistema e predefiniti corrispondente <xref:System.AppDomainSetup>proprietà.</xref:System.AppDomainSetup>      | Valore della proprietà &quot;name&quot; | Proprietà |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (nessuna proprietà)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; rappresenta l&quot;URL richiesto originariamente dall&quot;utente, prima di qualsiasi reindirizzamento. È disponibile solo quando l&quot;applicazione è stata avviata con un browser quale Internet Explorer. Non tutti i browser forniscono questo valore. |   |&quot; APP_NAME &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (nessuna proprietà) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;, o una stringa specifica dell&quot;applicazione | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (nessuna proprietà) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; non è una voce di sistema e il relativo valore può essere impostato chiamando il metodo <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "Il nome di una proprietà del dominio applicazione predefinito oppure il nome di una proprietà del dominio applicazione è stata definita."
    return:
      type: System.Object
      description: "Il valore di <code> name </code> , proprietà o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se la proprietà non esiste."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il tipo dell&quot;istanza corrente."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "Il tipo dell&quot;istanza corrente."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene un intero che identifica in modo univoco il dominio applicazione all&quot;interno del processo."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Valore intero che identifica il dominio applicazione."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornisce il <xref href=&quot;System.AppDomain&quot;> </xref> una durata infinita impedendo la creazione di un lease."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene un valore booleano che ammette valori null che indica se sono impostate opzioni di compatibilità e, in tal caso, se è impostata l&quot;opzione di compatibilità specificata."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "Opzione di compatibilità da testare."
    return:
      type: System.Nullable{System.Boolean}
      description: "Un riferimento null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> in Visual Basic) se è non impostate alcuna opzione di compatibilità; in caso contrario, un valore booleano che indica se l&quot;opzione di compatibilità è specificato da <code> value </code> è impostata."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Restituisce un valore che indica se il dominio applicazione è il dominio applicazione predefinito per il processo."
  remarks: "Ogni processo gestito dispone di un dominio applicazione predefinito. L&quot;esecuzione inizia nel dominio predefinito."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;oggetto corrente <xref href=&quot;System.AppDomain&quot;> </xref> oggetto rappresenta il dominio applicazione predefinito per il processo; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Indica se lo scaricamento di questo dominio applicazione e oggetti in che esso contenuti sono finalizzati da common language runtime."
  remarks: "Il metodo di finalizzazione per un oggetto si offre l&quot;opportunità di eseguire eventuali operazioni di pulizia prima che l&quot;oggetto è sottoposto a garbage collection. Dopo la finalizzazione, l&quot;oggetto è accessibile ma in uno stato non valido ed è pertanto inutilizzabile. Infine, la garbage collection completa e viene recuperato l&quot;oggetto.       Viene chiamato il metodo di finalizzazione dell&quot;oggetto in una delle situazioni seguenti: durante l&quot;operazione di garbage collection, quando common language runtime è in corso l&quot;arresto o quando viene scaricato il dominio applicazione che contiene l&quot;oggetto. Restituisce il metodo IsFinalizingForUnload `true` solo nell&quot;ultimo caso; non restituisce `true` se dà come risultato la finalizzazione da routine di garbage collection o dall&quot;arresto CLR.      > [!NOTE] > Per determinare se la finalizzazione a causa dell&quot;arresto CLR, utilizzare il <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>proprietà.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Restituisce `true` se la finalizzazione è dovuto a un dominio applicazione in corso lo scaricamento o all&quot;arresto di CLR.       Durante l&quot;esecuzione del metodo di finalizzazione durante lo scaricamento del dominio, è necessario per accedere a un altro oggetto che fa riferimento un campo statico e dispone di un metodo di finalizzazione. Tuttavia, non è possibile in modo affidabile avviene perché l&quot;oggetto a cui si accede potrebbe essere già stato completato.      > [!NOTE] > Un&quot;eccezione a questa regola è la <xref:System.Console>(classe), che contiene i campi statici che fanno riferimento a oggetti di flusso, ma viene implementato in modo tale è sempre possibile scrivere nella console di sistema, anche durante l&quot;arresto del sistema o lo scaricamento di dominio.</xref:System.Console>       Utilizzare questo metodo nel metodo di finalizzazione dell&quot;oggetto per determinare se il dominio applicazione che contiene l&quot;oggetto di scaricamento. Se è questo il caso, è possibile accedere in modo affidabile qualsiasi oggetto che dispone di un metodo di finalizzazione e fa riferimento a un campo statico."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se questo dominio applicazione è lo scaricamento e common language runtime è avviato il richiamo dei finalizzatori; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene un valore che indica se gli assembly caricati nel dominio applicazione corrente vengono eseguiti con attendibilità totale."
  remarks: "Questo metodo restituisce sempre `true` per il dominio applicazione predefinito di un&quot;applicazione che viene eseguito sul desktop. Restituisce `false` per un dominio applicazione creato mediante sandbox è stato creato utilizzando il [AppDomain.CreateDomain (stringa, la prova, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) overload del metodo, a meno che le autorizzazioni concesse al dominio dell&quot;applicazione sono equivalenti all&quot;attendibilità."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se gli assembly caricati nel dominio applicazione corrente vengono eseguiti con attendibilità totale; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene un valore che indica se il dominio applicazione corrente dispone di un set di autorizzazioni concesso a tutti gli assembly caricati nel dominio dell&quot;applicazione."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il dominio applicazione corrente dispone di un set omogeneo di autorizzazioni. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica l&quot; <xref:System.Reflection.Assembly>con un&quot;immagine common object file formato COFF () in base che contiene un <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> generato</xref:System.Reflection.Assembly>"
  remarks: "A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall&quot;utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell&quot;applicazione.       Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Matrice di tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> vale a dire un&quot;immagine a in formato COFF contenente un assembly generato."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>rawAssembly</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica un <xref:System.Reflection.Assembly>dato relativo <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Se è già caricata una versione dell&quot;assembly richiesto, questo metodo restituisce l&quot;assembly caricato, anche se non è necessaria una versione diversa.       Specificare un nome di assembly parziali per `assemblyRef` non è consigliata. (Un nome parziale omette una o più delle impostazioni cultura, versione o token di chiave pubblica. Di overload che accettano una stringa anziché un <xref:System.Reflection.AssemblyName>oggetto, &quot;MyAssembly, Version =&1;.0.0.0&quot; è un esempio di un nome parziale e &quot;MyAssembly, Version =&1;.0.0.0, Culture = neutral, PublicKeyToken =&18;ab3442da84b47&quot; è riportato un esempio di un nome completo.)</xref:System.Reflection.AssemblyName> Utilizzo di nomi parziali ha un effetto negativo sulle prestazioni. Inoltre, un nome di assembly parziali possa caricare un assembly dalla global assembly cache solo se è disponibile una copia esatta dell&quot;assembly nella directory base dell&quot;applicazione (<xref:System.AppDomain.BaseDirectory%2A> o <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Se l&quot;oggetto corrente <xref:System.AppDomain>oggetto rappresenta il dominio applicazione `A`e <xref:System.AppDomain.Load%2A>metodo viene chiamato dal dominio applicazione `B`, l&quot;assembly viene caricato in entrambi i domini applicazione.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Ad esempio, il codice seguente carica `MyAssembly` nel nuovo dominio applicazione `ChildDomain` e anche nel dominio applicazione in cui viene eseguito il codice: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] l&quot;assembly viene caricato in entrambi i domini perché <xref:System.Reflection.Assembly>non deriva da <xref:System.MarshalByRefObject>e pertanto il valore restituito del <xref:System.AppDomain.Load%2A>metodo Impossibile effettuare il marshalling.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     In alternativa, common language runtime tenta di caricare l&quot;assembly nel dominio applicazione chiamante. Gli assembly caricati in due domini applicazione potrebbero essere diversi se le impostazioni del percorso per i due domini applicazione sono diverse.      > [!NOTE] > Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>proprietà e <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>proprietà sono impostate, il primo tentativo di caricare l&quot;assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>proprietà).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Se il file non viene trovato, il <xref:System.Reflection.AssemblyName.CodeBase%2A>proprietà viene utilizzata per cercare l&quot;assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se l&quot;assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l&quot;assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException>viene generata un&quot;eccezione.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Oggetto che descrive l&quot;assembly da caricare."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyRef</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica un <xref:System.Reflection.Assembly>dato il nome visualizzato.</xref:System.Reflection.Assembly>"
  remarks: "Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>è<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyString</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica l&quot; <xref:System.Reflection.Assembly>con un&quot;immagine common object file formato COFF () in base che contiene un <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> generato</xref:System.Reflection.Assembly> I byte non elaborati che rappresentano i simboli per il <xref:System.Reflection.Assembly>vengono caricati anche.</xref:System.Reflection.Assembly>"
  remarks: "A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall&quot;utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell&quot;applicazione.       Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Matrice di tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> vale a dire un&quot;immagine a in formato COFF contenente un assembly generato."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Matrice di tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> contenente i byte non elaborati che rappresentano i simboli per l&quot;assembly."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>rawAssembly</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica un <xref:System.Reflection.Assembly>dato relativo <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Oggetto che descrive l&quot;assembly da caricare."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>è<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyRef</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica un <xref:System.Reflection.Assembly>dato il nome visualizzato.</xref:System.Reflection.Assembly>"
  remarks: "Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Il nome visualizzato dell&quot;assembly. Vedere &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>è<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>non è stato trovato."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>assemblyString</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carica l&quot; <xref:System.Reflection.Assembly>con un&quot;immagine common object file formato COFF () in base che contiene un <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> generato</xref:System.Reflection.Assembly> I byte non elaborati che rappresentano i simboli per il <xref:System.Reflection.Assembly>vengono caricati anche.</xref:System.Reflection.Assembly>"
  remarks: "A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall&quot;utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell&quot;applicazione.       Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metodo.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Per caricare gli assembly in altri domini applicazione, utilizzare un metodo come <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>overload del metodo.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Matrice di tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> vale a dire un&quot;immagine a in formato COFF contenente un assembly generato."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Matrice di tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> contenente i byte non elaborati che rappresentano i simboli per l&quot;assembly."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Evidenza per il caricamento dell&quot;assembly."
    return:
      type: System.Reflection.Assembly
      description: "Assembly caricato."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>non è un assembly valido.       - oppure - versione 2.0 o versione successiva di common language runtime è attualmente caricato e <code>rawAssembly</code> è stato compilato con una versione successiva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Un assembly o un modulo è stato caricato due volte con due evidenze diverse."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando i criteri di autorità di certificazione legacy non sono abilitato, <code>securityEvidence</code> deve essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene o imposta un valore che indica se le CPU e il monitoraggio della memoria dei domini applicazione è abilitato per il processo corrente. Una volta che il monitoraggio è attivato per un processo, non può essere disabilitata."
  remarks: "Questo `static` proprietà (`Shared` proprietà in Visual Basic) controlla la CPU e il monitoraggio della memoria di tutti i domini applicazione nel processo.       Se si tenta di impostare questa proprietà su `false`, <xref:System.ArgumentException>viene generata l&quot;eccezione, anche se il valore corrente della proprietà è `false`.</xref:System.ArgumentException>       Il monitoraggio è abilitato, è possibile utilizzare il <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>delle proprietà per monitorare l&quot;utilizzo della CPU e memoria dei singoli domini applicazione dell&quot;istanza.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il monitoraggio è attivato. in caso contrario <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il processo corrente ha tentato di assegnare il valore <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> a questa proprietà."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il numero di byte esclusi dall&quot;ultima raccolta e a cui fa riferimento il dominio applicazione corrente."
  remarks: "Le statistiche vengono aggiornate con ogni operazione di garbage collection. Tuttavia, essi sono sicuramente accurata solo dopo una procedura completa di Garbage collection; bloccante ovvero, si verifica una raccolta che include tutte le generazioni e che interrompe l&quot;applicazione durante la raccolta. Ad esempio, il <xref:System.GC.Collect?displayProperty=fullName>overload del metodo esegue una procedura completa di Garbage collection bloccante.</xref:System.GC.Collect?displayProperty=fullName> (Raccolta simultanea avviene in background e non blocca l&quot;applicazione)."
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "Il numero di byte esclusi."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>è impostata su <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene i byte totali rimasti dall&quot;ultima raccolta per tutti i domini applicazione nel processo."
  remarks: "Dopo una raccolta completa di, questo numero rappresenta il numero di byte attualmente mantenuti attivi in gestiti heap. Dovrebbe essere simile al numero segnalato dal <xref:System.GC.GetTotalMemory%2A>metodo.</xref:System.GC.GetTotalMemory%2A> Dopo una raccolta temporanea, questo numero rappresenta il numero di byte attualmente mantenuti attivo in generazioni temporanee."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "Numero totale di byte esclusi per il processo."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>è impostata su <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene le dimensioni totali, in byte, di tutte le allocazioni di memoria effettuate dal dominio dell&quot;applicazione quando è stato creato, senza sottrarre la memoria che è stati raccolti."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "Le dimensioni totali di tutte le allocazioni di memoria."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>è impostata su <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il tempo totale del processore utilizzata da tutti i thread durante l&quot;esecuzione nel dominio dell&quot;applicazione corrente dall&quot;avvio del processo."
  remarks: "Il tempo totale, viene restituito per un dominio applicazione include il tempo impiegato da ogni thread nel processo di esecuzione nel dominio dell&quot;applicazione.       Un thread che chiama codice non gestito è ancora associato a un dominio applicazione e il tempo del processore impiegato per l&quot;esecuzione di che codice non gestito viene segnalato per il dominio applicazione in cui è stata effettuata la chiamata.       Quando un thread è bloccato o inattivo, non utilizzare il tempo del processore."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Tempo totale processore per il dominio applicazione corrente."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>è impostata su <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il set di autorizzazioni di un dominio applicazione creato mediante sandbox."
  remarks: "Domini applicazione creata mediante sandbox che sono stati creati tramite il [AppDomain.CreateDomain (stringa, la prova, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) overload del metodo dispone di un set omogeneo di autorizzazioni, vale a dire lo stesso set di autorizzazioni viene concesso a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell&quot;applicazione. Facoltativamente, un dominio applicazione sandboxed include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e vengono invece eseguiti con attendibilità totale."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "Il set di autorizzazioni del dominio applicazione creato mediante sandbox."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica al termine del processo padre del dominio applicazione predefinito."
  remarks: "Il <xref:System.EventHandler>per questo evento è possibile eseguire le attività di chiusura, ad esempio la chiusura di file, il rilascio di archiviazione e così via, prima della fine del processo.</xref:System.EventHandler>       A partire da .NET Framework versione 2.0, questo evento viene generato in ogni dominio applicazione che registra un gestore dell&quot;evento.      > [!NOTE] > Il tempo di esecuzione totale di tutti i gestori di eventi ProcessExit è limitato, esattamente come il tempo di esecuzione totale di tutti i finalizzatori è limitato all&quot;arresto del processo. Il valore predefinito è di due secondi. Un host non gestito può modificare il tempo di esecuzione chiamando il [ICLRPolicyManager:: SetTimeout](~/add/includes/ajax-current-ext-md.md) metodo con il [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) valore di enumerazione.       Nelle versioni di .NET Framework 1.0 e 1.1, questo evento viene generato solo nel dominio applicazione predefinito e solo se un gestore eventi è registrato nel dominio applicazione predefinito.       Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException>viene generata un&quot;eccezione.</xref:System.Security.SecurityException>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando la risoluzione di un assembly ha esito negativo nel contesto reflection-only."
  remarks: "Nel contesto reflection-only, le dipendenze non vengono risolti automaticamente. Devono essere precaricati o restituiti dal gestore per questo evento. Questo evento viene generato quando un assembly ha una dipendenza che non è già caricata nel contesto reflection-only. La dipendenza mancante è specificata per il <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>proprietà.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> Il <xref:System.ResolveEventHandler>per questo evento deve restituire un assembly che soddisfa la dipendenza.</xref:System.ResolveEventHandler> L&quot;assembly restituito deve essere caricato nel contesto reflection-only.      > [!IMPORTANT] > Questo evento viene generato solo per le dipendenze mancanti dell&quot;assembly che si sta caricando nel contesto reflection-only (ad esempio, tramite il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>(metodo)).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Non viene generato se l&quot;assembly che si sta caricando non viene trovato.       A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>proprietà restituisce l&quot;assembly che ha richiesto il caricamento dell&quot;assembly che non può essere risolto.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Conoscere l&quot;identità dell&quot;assembly richiesta potrebbe essere utile per identificare la versione corretta della dipendenza, se è disponibile più di una versione. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>proprietà restituisce il nome dell&quot;assembly prima che i criteri vengono applicati.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Restituisce gli assembly caricati nel contesto ReflectionOnly del dominio dell&quot;applicazione."
  remarks: "Questo metodo restituisce gli assembly caricati nel contesto reflection-only. Per ottenere gli assembly che sono stati caricati per l&quot;esecuzione, utilizzare il <xref:System.AppDomain.GetAssemblies%2A>metodo.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Matrice di <xref:System.Reflection.Assembly>gli oggetti che rappresentano gli assembly caricati nel contesto ReflectionOnly del dominio dell&quot;applicazione.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Un&quot;operazione viene tentata in un dominio applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene il percorso nella directory di base in cui deve essere verificata la dal resolver dell&quot;assembly per gli assembly privati."
  remarks: "Assembly privati vengono distribuiti nella stessa struttura di directory dell&quot;applicazione. Se il percorso specificato dalla proprietà RelativeSearchPath non è gestito da <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, viene ignorata.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Questa proprietà restituisce il valore impostato utilizzando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "Il percorso nella directory di base in cui deve essere verificata la dal resolver dell&quot;assembly per gli assembly privati."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando la risoluzione di una risorsa ha esito negativo perché la risorsa non è una risorsa collegata valida o incorporata nell&quot;assembly."
  remarks: "<xref:System.ResolveEventHandler>Per questo evento può tentare di individuare l&quot;assembly contenente la risorsa e restituire tale</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Questo evento non viene generato se la risoluzione non riesce perché può essere trovato alcun file per una risorsa collegata valida. Viene generato se un flusso di risorsa di manifesto non è stato trovato, ma non viene generato se non viene trovata una chiave singola risorsa.       A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>proprietà contiene l&quot;assembly che ha richiesto la risorsa.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException>viene generata un&quot;eccezione.</xref:System.Security.SecurityException>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Imposta il livello di criteri di sicurezza per il dominio applicazione."
  remarks: "Chiamare questo metodo prima del caricamento in un assembly di <xref:System.AppDomain>affinché i criteri di sicurezza ha effetto.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "Il livello di criteri di sicurezza."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "È già stato impostato il livello di criteri di sicurezza."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Imposta il percorso di directory specificato come percorso in cui gli assembly vengono replicati."
  remarks: "Il percorso della cache viene ignorato se il <xref:System.AppDomainSetup.ApplicationName%2A>non è impostata.</xref:System.AppDomainSetup.ApplicationName%2A> Vedere il <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>proprietà.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Per ulteriori informazioni sulla creazione di copie shadow vedere [copie Shadow di assembly](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Il percorso completo per il percorso della copia shadow."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Assegna il valore specificato per la proprietà di dominio di applicazione specificata."
  remarks: "Utilizzare questo metodo per inserire una voce o modificare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <xref:System.AppDomain>.</xref:System.AppDomain>       La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell&quot;applicazione. È possibile inserire o modificare voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un&quot;eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A>metodo, o l&quot; equivalente <xref:System.AppDomainSetup>proprietà descritti in <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>       È possibile chiamare questo metodo per impostare il valore dell&quot;intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; come valore della `name` argomento e un <xref:System.TimeSpan>valore che rappresenta l&quot;intervallo di timeout come valore della `data` argomento.</xref:System.TimeSpan> È anche possibile inserire o modificare la propria coppie nome / dati definiti dall&quot;utente con questo metodo e verificarne i valori con il <xref:System.AppDomain.GetData%2A>metodo.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "Il nome di una proprietà del dominio applicazione definito dall&quot;utente per creare o modificare."
    - id: data
      type: System.Object
      description: "Il valore della proprietà."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Assegna il valore specificato per la proprietà di dominio di applicazione specificata, con una determinata autorizzazione di richiesta del chiamante quando viene recuperata la proprietà."
  remarks: "Utilizzare questo metodo per inserire o modificare voci personalizzate definite dall&quot;utente in una cache interna di coppie nome/dati che descrivono le proprietà del dominio dell&quot;applicazione. Quando si inserisce una voce, è possibile specificare una richiesta di autorizzazione da applicare quando viene recuperata la voce. Inoltre, è possibile chiamare questo metodo per impostare il valore dell&quot;intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; come valore del `name` argomento e un <xref:System.TimeSpan>valore che rappresenta l&quot;intervallo di timeout come valore della `data` argomento.</xref:System.TimeSpan>       È possibile usare questo metodo per assegnare una richiesta di sicurezza in una stringa di proprietà definita dal sistema.       La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell&quot;applicazione. È possibile inserire o modificare voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un&quot;eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A>metodo o l&quot;equivalente <xref:System.AppDomainSetup>proprietà descritte nella sezione Osservazioni per il <xref:System.AppDomain.GetData%2A>metodo.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "Il nome di una proprietà del dominio applicazione definito dall&quot;utente per creare o modificare."
    - id: data
      type: System.Object
      description: "Il valore della proprietà."
    - id: permission
      type: System.Security.IPermission
      description: "Autorizzazione di richiesta del chiamante quando viene recuperata la proprietà."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Specifica una stringa di proprietà definita dal sistema e <code>permission</code> non <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Imposta il percorso di directory specificato come directory di base per sottodirectory in cui i file generati dinamicamente sono archiviati e accessibili."
  remarks: "Questo metodo imposta la <xref:System.AppDomainSetup.DynamicBase%2A>proprietà dell&quot;oggetto interno <xref:System.AppDomainSetup>associata a questa istanza.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "Il percorso completo che è la directory di base per sottodirectory in cui sono archiviati gli assembly dinamici."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Specifica come oggetti principal e identity dovrebbero essere collegati a un thread se il thread tenta di associare a un&quot;entità durante l&quot;esecuzione nel dominio applicazione."
  remarks: "Impostando questo valore saranno effettiva solo se si imposta la proprietà prima di utilizzare il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>proprietà.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Ad esempio, se si imposta <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>a una determinata entità (ad esempio, un&quot;entità generica) e quindi utilizzare il metodo SetPrincipalPolicy per impostare il <xref:System.Security.Principal.PrincipalPolicy>a <xref:System.Security.Principal.PrincipalPolicy>, l&quot;entità corrente rimarrà entità generica.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Uno del <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> valori che specifica il tipo dell&quot;oggetto principal da collegare ai thread."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Attiva la copia shadow."
  remarks: "Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Imposta il percorso di directory specificato come percorso degli assembly da replicare mediante copiata shadow."
  remarks: "Per impostazione predefinita, una copia shadow include tutti gli assembly trovati durante il rilevamento. Il metodo SetShadowCopyPath limita la copia shadow agli assembly nella directory specificata da `path`.       Il metodo SetShadowCopyPath specifica directory aggiuntive in cui cercare gli assembly. Assembly da una copia shadow deve già trovarsi nel percorso di ricerca, ad esempio in <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> Il metodo SetShadowCopyPath specifica quali percorsi di ricerca sono idonei per l&quot;esecuzione della copia shadow.       Questo metodo imposta la <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>proprietà dell&quot;oggetto interno <xref:System.AppDomainSetup>associata a questa istanza.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Un elenco di nomi di directory, in cui i nomi sono separati da un punto e virgola."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Imposta l&quot;oggetto principal predefinito da collegare ai thread se si tenta di associare a un&quot;entità durante l&quot;esecuzione nel dominio applicazione."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "L&quot;oggetto principal da collegare ai thread."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "L&quot;entità di thread è già stata impostata."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene le informazioni di configurazione del dominio applicazione per questa istanza."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "Le informazioni di inizializzazione del dominio applicazione."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene un valore che indica se il dominio applicazione è configurato per il file di copia shadow."
  remarks: "Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>e [copie Shadow di assembly](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il dominio applicazione è configurato per eseguire la copia shadow di file; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "L&quot;operazione viene tentata in un dominio dell&quot;applicazione non caricato."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch."
  remarks: "Questo metodo consente l&quot;accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Riservato per utilizzo futuro. Deve essere IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Passata matrice di nomi di cui eseguire il mapping."
    - id: cNames
      type: System.UInt32
      description: "Conteggio dei nomi di cui eseguire il mapping."
    - id: lcid
      type: System.UInt32
      description: "Contesto in cui interpretare i nomi delle impostazioni locali."
    - id: rgDispId
      type: System.IntPtr
      description: "Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Accesso ad associazione tardiva usando il modello COM `IDispatch` interfaccia non è supportata."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Recupera le informazioni sul tipo per un oggetto che può quindi essere usato per ottenere le informazioni sul tipo per un&quot;interfaccia."
  remarks: "Questo metodo consente l&quot;accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "Le informazioni sul tipo da restituire."
    - id: lcid
      type: System.UInt32
      description: "Identificatore delle impostazioni locali per le informazioni sul tipo."
    - id: ppTInfo
      type: System.IntPtr
      description: "Riceve un puntatore all&quot;oggetto informazioni sul tipo richiesto."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Accesso ad associazione tardiva usando il modello COM `IDispatch` interfaccia non è supportata."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Recupera il numero di interfacce di informazioni sul tipo fornite da un oggetto (0 o 1)."
  remarks: "Questo metodo consente l&quot;accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall&quot;oggetto."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Accesso ad associazione tardiva usando il modello COM `IDispatch` interfaccia non è supportata."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornisce l&quot;accesso a proprietà e metodi esposti da un oggetto."
  remarks: "Questo metodo consente l&quot;accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifica il membro."
    - id: riid
      type: System.Guid
      description: "Riservato per utilizzo futuro. Deve essere IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "Contesto delle impostazioni locali in cui interpretare gli argomenti."
    - id: wFlags
      type: System.Int16
      description: "Flag che descrivono il contesto della chiamata."
    - id: pDispParams
      type: System.IntPtr
      description: "Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici."
    - id: pVarResult
      type: System.IntPtr
      description: "Puntatore alla posizione in cui il risultato viene archiviato."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Puntatore a una struttura contenente informazioni sull&quot;eccezione."
    - id: puArgErr
      type: System.IntPtr
      description: "L&quot;indice del primo argomento che contiene un errore."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Accesso ad associazione tardiva usando il modello COM `IDispatch` interfaccia non è supportata."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ottiene una rappresentazione di stringa che include il nome descrittivo del dominio applicazione e qualsiasi criterio di contesto."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Stringa formata concatenando la stringa letterale &quot;nome:&quot;, il nome descrittivo del dominio applicazione e le rappresentazioni di stringa dei criteri di contesto o la stringa &quot;There non are context policies.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Il dominio applicazione rappresentato dall&quot;oggetto corrente <xref href=&quot;System.AppDomain&quot;> </xref> è stato scaricato."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando la risoluzione di un tipo non riesce."
  remarks: "L&quot;evento TypeResolve si verifica quando in common language runtime non riesce a determinare l&quot;assembly che è possibile creare il tipo richiesto. Ciò può verificarsi se il tipo è definito in un assembly dinamico, o il tipo non è definito in un assembly dinamico, ma il runtime non conosce il tipo è definito nell&quot;assembly. La seconda situazione può verificarsi quando <xref:System.Type.GetType%2A?displayProperty=fullName>viene chiamato con un nome di tipo che non è qualificato con il nome dell&quot;assembly.</xref:System.Type.GetType%2A?displayProperty=fullName>       Il <xref:System.ResolveEventHandler>per questo evento può tentare di individuare e creare il tipo.</xref:System.ResolveEventHandler>       Tuttavia, l&quot;evento TypeResolve non si verifica se il runtime è in grado che non è possibile trovare un tipo in determinati assembly. Ad esempio, questo evento non si verifica se il tipo non viene trovato in un assembly statico perché il runtime è in grado di tipi non possono essere aggiunte dinamicamente per gli assembly statici.       A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>proprietà contiene l&quot;assembly che ha richiesto il tipo.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException>viene generata un&quot;eccezione.</xref:System.Security.SecurityException>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Si verifica quando non viene intercettata un&quot;eccezione."
  remarks: "Questo evento di notifica delle eccezioni non rilevate. Consente all&quot;applicazione di registrare informazioni sull&quot;eccezione prima che il gestore di sistema predefinito segnala l&quot;eccezione all&quot;utente e termina l&quot;applicazione. Se sono disponibili sufficienti informazioni sullo stato dell&quot;applicazione, si possono intraprendere altre azioni, quali il salvataggio di dati del programma per il ripristino di versioni successive. È consigliabile prestare attenzione, perché i dati del programma possono risultare danneggiati quando le eccezioni non gestite.      > [!NOTE] > Nelle versioni di .NET Framework 1.0 e 1.1, la terminazione dell&quot;applicazione e le opzioni di debug vengono segnalati all&quot;utente prima di questo evento viene generato, anziché dopo.       Questo evento può essere gestito in qualsiasi dominio applicazione. Tuttavia, l&quot;evento non viene necessariamente generato nel dominio dell&quot;applicazione in cui si è verificata l&quot;eccezione. Un&quot;eccezione viene gestita solo se l&quot;intero stack per il thread è stato rimosso senza trovare un gestore di eccezioni applicabile, pertanto il primo elemento che può essere generato l&quot;evento è nel dominio dell&quot;applicazione in cui il thread ha avuto origine.      > [!NOTE] > Versioni in .NET Framework 1.0 e 1.1, questo evento si verifica solo per il dominio applicazione predefinito creato dal sistema quando viene avviata un&quot;applicazione. Se un&quot;applicazione crea domini applicazione aggiuntivi, specificando un delegato per questo evento in tali domini applicazioni non ha alcun effetto.       Se l&quot;evento UnhandledException viene gestito nel dominio applicazione predefinito, viene generato in qualsiasi eccezione non gestita in qualsiasi thread, indipendentemente dal dominio applicazione è stato avviato il thread. Se il thread è stato avviato in un dominio applicazione che dispone di un gestore eventi per UnhandledException, l&quot;evento viene generato nel dominio dell&quot;applicazione. Dominio dell&quot;applicazione non è il dominio applicazione predefinito, se non vi è un gestore dell&quot;evento nel dominio applicazione predefinito, viene generato l&quot;evento in entrambi i domini applicazione.       Ad esempio, si supponga che un thread viene avviato in dominio applicazione &quot;AD1&quot;, chiama un metodo nel dominio applicazione &quot;AD2&quot; e da lì chiama un metodo nel dominio applicazione &quot;AD3&quot;, in cui viene generata un&quot;eccezione. Il primo dominio di applicazione in cui può essere generato l&quot;evento UnhandledException è &quot;AD1&quot;. Se il dominio dell&quot;applicazione non è il dominio applicazione predefinito, l&quot;evento può essere generato anche nel dominio applicazione predefinito.      > [!NOTE] > Common language runtime sospende le interruzioni dei thread durante l&quot;esecuzione di gestori eventi per l&quot;evento UnhandledException.       Se il gestore di evento include un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>attributo con il flag appropriati, il gestore dell&quot;evento viene considerato come un&quot;area a esecuzione vincolata.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       A partire dal [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], questo evento non viene generato per le eccezioni che danneggiano lo stato del processo, ad esempio overflow dello stack o violazioni di accesso, a meno che il gestore dell&quot;evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Nelle versioni di .NET Framework 1.0 e 1.1, un&quot;eccezione non gestita che si verifica in un thread diverso dal thread principale dell&quot;applicazione viene intercettata dal runtime e pertanto non causa l&quot;interruzione dell&quot;applicazione. Pertanto, è possibile che l&quot;evento UnhandledException venga generato senza che l&quot;applicazione termini. A partire da .NET Framework versione 2.0, questo trasparenti comprendeva per le eccezioni non gestite nei thread figlio è stato rimosso, poiché l&quot;effetto cumulativo di tali errori invisibile all&quot;utente un calo delle prestazioni, dati danneggiati e blocchi, ognuno dei quali sono stati difficile eseguire il debug. Per ulteriori informazioni, incluso un elenco di casi in cui il runtime non viene terminato, vedere [eccezioni in thread gestiti](~/add/includes/ajax-current-ext-md.md).       Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException>viene generata un&quot;eccezione.</xref:System.Security.SecurityException>       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md).      ## Altri eventi per le eccezioni non gestite per alcune applicazioni di modelli, l&quot;eccezione UnhandledException evento può essere superato da altri eventi se si verifica l&quot;eccezione non gestita nel thread principale dell&quot;applicazione.       Nelle applicazioni che usano Windows Form, eccezioni non gestite nella causa del thread principale dell&quot;applicazione di <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>evento da generare.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Se questo evento viene gestito, il comportamento predefinito prevede che l&quot;eccezione non gestita non termina l&quot;applicazione, anche se l&quot;applicazione viene lasciato in uno stato sconosciuto. In tal caso, l&quot;evento UnhandledException non viene generato. Questo comportamento può essere modificato utilizzando il file di configurazione dell&quot;applicazione o tramite il <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>metodo per modificare la modalità a <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>prima del <xref:System.Windows.Forms.Application.ThreadException>gestore eventi è up. associati</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Questo vale solo per il thread principale dell&quot;applicazione. L&quot;evento UnhandledException viene generato per le eccezioni non gestite generate in altri thread.       A partire da Microsoft Visual Studio 2005, il framework dell&quot;applicazione Visual Basic fornisce un altro evento per le eccezioni non gestite nel thread principale dell&quot;applicazione. Vedere il <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>evento.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Questo evento è un oggetto di argomenti di eventi con lo stesso nome dell&quot;oggetto di argomenti di evento utilizzato da UnhandledException, ma con proprietà diverse. In particolare, questo oggetto di argomenti di evento include un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>proprietà che consente all&quot;applicazione di continuare l&quot;esecuzione, ignorando l&quot;eccezione non gestita (e lasciando l&quot;applicazione in uno stato sconosciuto).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> In tal caso, l&quot;evento UnhandledException non viene generato."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Scarica il dominio di applicazione specificata."
  remarks: "In .NET Framework versione 2.0 è un thread dedicato di scaricamento di domini applicazione. Ciò migliora l&quot;affidabilità, soprattutto quando è ospitato in .NET Framework. Quando un thread chiama Scarica il dominio di destinazione è contrassegnato per lo scaricamento. Il thread dedicato tenta di scaricare il dominio e tutti i thread nel dominio sono state interrotte. Se un thread viene interrotto, ad esempio perché è in esecuzione il codice non gestito o perché è in esecuzione un `finally` blocco, quindi dopo un periodo di tempo un <xref:System.CannotUnloadAppDomainException>viene generata nel thread che ha originariamente chiamato Unload.</xref:System.CannotUnloadAppDomainException> Se il thread che non venga interrotto infine termina, il dominio di destinazione non viene scaricato. Pertanto, in .NET Framework versione 2.0 `domain` non è garantita per essere scaricato, perché potrebbe non essere possibile terminare l&quot;esecuzione di thread.      > [!NOTE] > In alcuni casi, lo scaricamento di chiamata genera un&quot;eccezione immediata <xref:System.CannotUnloadAppDomainException>, ad esempio se viene chiamato in un finalizzatore.</xref:System.CannotUnloadAppDomainException>       I thread nel `domain` vengono terminati mediante il <xref:System.Threading.Thread.Abort%2A>metodo, che genera un <xref:System.Threading.ThreadAbortException>nel thread.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Anche se il thread viene terminato immediatamente, può continuare l&quot;esecuzione per un periodo di tempo in imprevedibile un `finally` clausola.      ## Versione compatibilità In .NET Framework versioni 1.0 e 1.1, se è in esecuzione il thread che chiama Unload `domain`, viene avviato un altro thread per eseguire l&quot;operazione di scaricamento. Se `domain` non può essere scaricato, un <xref:System.CannotUnloadAppDomainException>viene generata in tale thread, non nel thread originale che ha chiamato Unload.</xref:System.CannotUnloadAppDomainException> Tuttavia, se il thread che chiama lo scaricamento è in esecuzione all&quot;esterno `domain`, che i thread riceve l&quot;eccezione."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Un dominio di applicazione da scaricare."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>non è stato scaricato."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Si è verificato un errore durante il processo di scaricamento."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
