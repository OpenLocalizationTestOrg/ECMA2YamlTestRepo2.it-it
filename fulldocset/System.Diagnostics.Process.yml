### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Fornisce l&quot;accesso a processi locali e remoti e permette di avviare e arrestare i processi di sistema locale.       Per esaminare il codice sorgente di .NET Framework per questo tipo, vedere il [origine riferimento](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Diagnostics.Process&quot;> </xref> classe."
  remarks: "Se non si specifica il <xref:System.Diagnostics.Process.MachineName%2A>proprietà, il valore predefinito è il computer locale (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Sono disponibili due opzioni per l&quot;associazione di un nuovo <xref:System.Diagnostics.Process>componente con un processo nel computer.</xref:System.Diagnostics.Process> La prima opzione è utilizzare il costruttore per creare il <xref:System.Diagnostics.Process>componente, impostare i membri appropriati del <xref:System.Diagnostics.Process.StartInfo%2A>proprietà e chiamare <xref:System.Diagnostics.Process.Start%2A>per associare il <xref:System.Diagnostics.Process>con un nuovo processo di sistema.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> La seconda opzione consiste nell&quot;associare il <xref:System.Diagnostics.Process>con un processo di sistema in esecuzione utilizzando <xref:System.Diagnostics.Process.GetProcessById%2A>o uno del <xref:System.Diagnostics.Process.GetProcesses%2A>restituiscono valori.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Se si utilizza un `static` overload di <xref:System.Diagnostics.Process.Start%2A>Crea un nuovo metodo per avviare un nuovo processo di sistema, il metodo <xref:System.Diagnostics.Process>componente e lo associa al processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Quando il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>proprietà è impostata sul valore predefinito `true`, è possibile avviare le applicazioni e documenti in modo che è simile all&quot;utilizzo di `Run` delle finestre di dialogo `Start` menu.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>è `false`, è possibile avviare solo file eseguibili.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Qualsiasi file eseguibile che è possibile chiamare dalla riga di comando può essere avviato in uno dei due modi: mediante l&quot;impostazione dei membri appropriati del <xref:System.Diagnostics.Process.StartInfo%2A>proprietà e la chiamata di <xref:System.Diagnostics.Process.Start%2A>metodo senza parametri oppure passando il parametro appropriato per il `static` <xref:System.Diagnostics.Process.Start%2A>membro.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       È possibile creare un <xref:System.Diagnostics.Process>componente utilizzando il costruttore, uno dei statica <xref:System.Diagnostics.Process.Start%2A>Overload o uno qualsiasi del <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, o <xref:System.Diagnostics.Process.GetProcessesByName%2A>metodi.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Dopo aver eseguito questa operazione, è disponibile una visualizzazione il processo associato. Non si tratta di una visualizzazione dinamica che viene aggiornata automaticamente le proprietà del processo sono stati modificati in memoria. In alternativa, è necessario chiamare <xref:System.Diagnostics.Process.Refresh%2A>per il componente aggiornare il <xref:System.Diagnostics.Process>informazioni sulle proprietà dell&quot;applicazione.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la priorità base del processo associato."
  remarks: "BasePriority del processo è la priorità iniziale dei thread creati all&quot;interno del processo associato. È possibile visualizzare informazioni sulla priorità base attraverso contatore di Base di priorità del Monitor di sistema.       In base al tempo trascorsi o degli altri incrementi, il sistema operativo è possono modificare la priorità di base quando un processo deve essere inserito prima degli altri.       La proprietà BasePriority consente di visualizzare la priorità iniziale assegnata a un processo. Tuttavia, poiché è di sola lettura, è possibile utilizzare il BasePriority per impostare la priorità del processo. Per modificare la priorità, utilizzare il <xref:System.Diagnostics.Process.PriorityClass%2A>proprietà.</xref:System.Diagnostics.Process.PriorityClass%2A> Il BasePriority è visualizzabile tramite il monitoraggio di sistema, mentre il <xref:System.Diagnostics.Process.PriorityClass%2A>non.</xref:System.Diagnostics.Process.PriorityClass%2A> Entrambi i BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>possono essere visualizzati a livello di codice.</xref:System.Diagnostics.Process.PriorityClass%2A> Nella tabella seguente viene illustrata la relazione tra i valori BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>valori.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | Classe di priorità |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "La priorità di base, calcolata dal <xref:System.Diagnostics.Process.PriorityClass*>del processo associato.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare il &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; proprietà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo è terminato.       - oppure - il processo non è avviato, pertanto non c&quot;è Nessun ID del processo."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inizia le operazioni di lettura asincrone sul reindirizzato <xref:System.Diagnostics.Process.StandardError*>flusso dell&quot;applicazione.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Il <xref:System.Diagnostics.Process.StandardError%2A>flusso può essere letto in modo sincrono o asincrono.</xref:System.Diagnostics.Process.StandardError%2A> I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>eseguire le operazioni di lettura sincrona nel flusso di output di errore del processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Questi sincrono letti operazioni non vengono completate fino a quando l&quot;oggetto associato <xref:System.Diagnostics.Process>scrive relativo <xref:System.Diagnostics.Process.StandardError%2A>stream o chiude il flusso.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Al contrario, viene avviato BeginErrorReadLine asincrona operazioni di lettura nel <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A> Questo metodo consente al gestore eventi designato per l&quot;output del flusso e viene restituito immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l&quot;output di flusso viene indirizzato al gestore dell&quot;evento.       Seguire questi passaggi per eseguire operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardError%2A>per un <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.ErrorDataReceived>evento.</xref:System.Diagnostics.Process.ErrorDataReceived> Il gestore eventi deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>firma del delegato.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Avviare il <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chiamare BeginErrorReadLine per <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> La chiamata avvia le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Quando l&quot;avvio di operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta associato <xref:System.Diagnostics.Process>scrive una riga di testo relativa <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       È possibile annullare un&quot;operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> L&quot;operazione di lettura può essere annullata dal chiamante o dal gestore dell&quot;evento. Dopo l&quot;annullamento, è possibile chiamare BeginErrorReadLine nuovamente per riprendere le operazioni di lettura asincrone.      > [!NOTE] > Non è possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Ad esempio, non seguire con una chiamata a BeginErrorReadLine <xref:System.IO.StreamReader.ReadLine%2A>sul <xref:System.Diagnostics.Process.StandardError%2A>flusso, o viceversa.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare BeginErrorReadLine e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A>per il <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inizia le operazioni di lettura asincrone sul reindirizzato <xref:System.Diagnostics.Process.StandardOutput*>flusso dell&quot;applicazione.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "Il <xref:System.Diagnostics.Process.StandardOutput%2A>flusso può essere letto in modo sincrono o asincrono.</xref:System.Diagnostics.Process.StandardOutput%2A> I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>eseguire le operazioni di lettura sincrona nel flusso di output del processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Questi sincrono letti operazioni non vengono completate fino a quando l&quot;oggetto associato <xref:System.Diagnostics.Process>scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A>stream o chiude il flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Al contrario, viene avviato BeginOutputReadLine asincrona operazioni di lettura nel <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> Questo metodo consente a un gestore eventi designato per l&quot;output del flusso e viene restituito immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l&quot;output di flusso viene indirizzato al gestore dell&quot;evento.       Seguire questi passaggi per eseguire operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardOutput%2A>per un <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.OutputDataReceived>evento.</xref:System.Diagnostics.Process.OutputDataReceived> Il gestore eventi deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>firma del delegato.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Avviare il <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chiamare BeginOutputReadLine per <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> La chiamata avvia le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Quando l&quot;avvio di operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta associato <xref:System.Diagnostics.Process>scrive una riga di testo relativa <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       È possibile annullare un&quot;operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> L&quot;operazione di lettura può essere annullata dal chiamante o dal gestore dell&quot;evento. Dopo l&quot;annullamento, è possibile chiamare BeginOutputReadLine nuovamente per riprendere le operazioni di lettura asincrone.      > [!NOTE] > Non è possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Ad esempio, non seguire con una chiamata a BeginOutputReadLine <xref:System.IO.StreamReader.ReadLine%2A>sul <xref:System.Diagnostics.Process.StandardOutput%2A>flusso, o viceversa.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare BeginOutputReadLine e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A>per il <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Annulla l&quot;operazione di lettura asincrona in reindirizzato <xref:System.Diagnostics.Process.StandardError*>flusso di un&quot;applicazione.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Avvia un&quot;operazione di lettura asincrona nel <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead termina l&quot;operazione di lettura asincrona.       Dopo l&quot;annullamento, è possibile riprendere l&quot;operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>nuovamente.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       Quando si chiama CancelErrorRead, tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardError%2A>vengono completate e il gestore dell&quot;evento viene disabilitato.</xref:System.Diagnostics.Process.StandardError%2A> Ogni ulteriore output reindirizzato a <xref:System.Diagnostics.Process.StandardError%2A>viene salvato in un buffer.</xref:System.Diagnostics.Process.StandardError%2A> Se si riattiva il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, l&quot;output salvato viene inviato al gestore dell&quot;evento e riprenderanno le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Se si desidera modificare il gestore dell&quot;evento prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell&quot;evento esistente prima di aggiungere il nuovo gestore eventi: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > non è possibile combinare le operazioni di lettura asincrone e sincrone in reindirizzato <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A> Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Se si annulla un&quot;operazione di lettura asincrona in <xref:System.Diagnostics.Process.StandardError%2A>ed è quindi necessario nuovamente di leggere dal flusso, è necessario utilizzare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>per riprendere le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Non seguire CancelErrorRead con una chiamata a metodi di lettura sincrona <xref:System.Diagnostics.Process.StandardError%2A>come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref:System.Diagnostics.Process.StandardError*>flusso non è abilitato per le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Annulla l&quot;operazione di lettura asincrona in reindirizzato <xref:System.Diagnostics.Process.StandardOutput*>flusso di un&quot;applicazione.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Avvia un&quot;operazione di lettura asincrona nel <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead termina l&quot;operazione di lettura asincrona.       Dopo l&quot;annullamento, è possibile riprendere le operazioni di lettura asincrone chiamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>nuovamente.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       Quando si chiama CancelOutputRead, tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardOutput%2A>vengono completate e il gestore dell&quot;evento viene disabilitato.</xref:System.Diagnostics.Process.StandardOutput%2A> Ogni ulteriore output reindirizzato a <xref:System.Diagnostics.Process.StandardOutput%2A>viene salvato in un buffer.</xref:System.Diagnostics.Process.StandardOutput%2A> Se si riattiva il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, l&quot;output salvato viene inviato al gestore dell&quot;evento e riprenderanno le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Se si desidera modificare il gestore dell&quot;evento prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell&quot;evento esistente prima di aggiungere il nuovo gestore eventi: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > non è possibile combinare le operazioni di lettura asincrone e sincrone in reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Se si annulla un&quot;operazione di lettura asincrona in <xref:System.Diagnostics.Process.StandardOutput%2A>ed è quindi necessario nuovamente di leggere dal flusso, è necessario utilizzare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>per riprendere le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Non seguire CancelOutputRead con una chiamata a metodi di lettura sincrona <xref:System.Diagnostics.Process.StandardOutput%2A>come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref:System.Diagnostics.Process.StandardOutput*>flusso non è abilitato per le operazioni di lettura asincrone.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Libera tutte le risorse che sono associate a questo componente."
  remarks: "Il metodo Close fa sì che il processo di arresto in attesa per l&quot;uscita se era in attesa, chiude l&quot;handle del processo e Cancella le proprietà specifiche del processo. Chiusura non chiudere i lettori di output, input e di errore standard e i writer nel caso in cui viene fatto riferimento esternamente.      > [!NOTE] > Il <xref:System.Diagnostics.Process.Dispose%2A>metodo chiama Close.</xref:System.Diagnostics.Process.Dispose%2A> Inserire il <xref:System.Diagnostics.Process>dell&quot;oggetto un `using` blocco Elimina le risorse senza la necessità di chiamare Close.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Chiude un processo che dispone di un&quot;interfaccia utente inviando un messaggio di chiusura alla corrispondente finestra principale."
  remarks: "Quando un processo è in esecuzione, il ciclo di messaggi è in stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata CloseMainWindow invia una richiesta di chiusura della finestra principale, che, in un&quot;applicazione ben formata, chiude le finestre figlio e revoca tutti in esecuzione i cicli di messaggi per l&quot;applicazione. La richiesta di terminazione del processo chiamando CloseMainWindow non forzare la chiusura dell&quot;applicazione. L&quot;applicazione può richiedere la verifica dell&quot;utente prima di chiudere o rifiutare la chiusura. Per forzare la chiusura dell&quot;applicazione, utilizzare il <xref:System.Diagnostics.Process.Kill%2A>metodo.</xref:System.Diagnostics.Process.Kill%2A> Il comportamento di CloseMainWindow è identico a quello di un utente chiudendo la finestra principale di un&quot;applicazione utilizzando il menu di sistema. Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone la chiusura immediatamente dell&quot;applicazione.       I dati modificati dal processo o le risorse allocate al processo possono essere perse se si chiama <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>causa una terminazione anomala processo e deve essere utilizzato solo quando necessario.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow consente una terminazione corretta del processo e chiude tutte le finestre, pertanto è preferibile per le applicazioni con un&quot;interfaccia. Se CloseMainWindow non riesce, è possibile utilizzare <xref:System.Diagnostics.Process.Kill%2A>per terminare il processo.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>è l&quot;unico modo per terminare i processi che non dispongono di interfacce grafiche.</xref:System.Diagnostics.Process.Kill%2A>       È possibile chiamare <xref:System.Diagnostics.Process.Kill%2A>e CloseMainWindow solo per i processi in esecuzione nel computer locale.</xref:System.Diagnostics.Process.Kill%2A> È Impossibile i processi in computer remoti per uscire dall&quot;installazione. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il messaggio di chiusura è stato inviato correttamente, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il processo associato non dispone di una finestra principale o se la finestra principale è disabilitata (ad esempio se è attualmente visualizzata una finestra modale)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare il &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; proprietà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo già terminato.       - oppure - non è associato alcun processo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Rilascia tutte le risorse usate dal processo."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per rilasciare le risorse gestite e non gestite. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> per rilasciare solo le risorse non gestite."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta se la <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> evento deve essere generato al termine del processo."
  remarks: "La proprietà EnableRaisingEvents indica se il componente deve ricevere notifica quando un processo di arresto del sistema operativo. La proprietà EnableRaisingEvents viene utilizzata nell&quot;elaborazione asincrona per notificare all&quot;applicazione che un processo è terminato. Per forzare l&quot;applicazione per attendere in modo sincrono un evento di uscita (che interrompe l&quot;elaborazione dell&quot;applicazione fino a quando non si è verificato l&quot;evento di uscita), utilizzare il <xref:System.Diagnostics.Process.WaitForExit%2A>metodo.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Se si utilizza Visual Studio e fare doppio clic su un <xref:System.Diagnostics.Process>componente nel progetto, un <xref:System.Diagnostics.Process.Exited>delegato dell&quot;evento e il gestore eventi vengono generati automaticamente.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Codice aggiuntivo imposta la proprietà EnableRaisingEvents `false`. È necessario modificare questa proprietà su `true` per il gestore eventi da eseguire alla chiusura del processo associato.       Quando un processo associato termina dopo essere stato arrestato dal sistema operativo sia mediante terminazione normale o anomala, il sistema operativo notifica ogni componente del processo a cui il processo è stato associato, purché sia il valore del componente EnableRaisingEvents `true`. Se il processo avviato da un componente, il componente può quindi accedere alle informazioni amministrative per il processo associato, che è ancora memorizzata dal sistema operativo. Tali informazioni includono il <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       Dopo la chiusura del processo associato, la <xref:System.Diagnostics.Process.Handle%2A>del componente non fa più riferimento a una risorsa di processo esistente.</xref:System.Diagnostics.Process.Handle%2A> In alternativa, può essere utilizzato solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema operativo è a conoscenza che sono presenti handle a processi terminati che non sono stati rilasciati da <xref:System.Diagnostics.Process>componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informazioni in memoria.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       È un costo associato guardare il video per un processo uscire dall&quot;installazione. Se è EnableRaisingEvents `true`, <xref:System.Diagnostics.Process.Exited>evento viene generato quando il processo associato venga terminato.</xref:System.Diagnostics.Process.Exited> Le procedure che è stato specificato per il <xref:System.Diagnostics.Process.Exited>evento eseguito all&quot;ora.</xref:System.Diagnostics.Process.Exited>       In alcuni casi, l&quot;applicazione avvia un processo, ma non devono ricevere una notifica della chiusura. Ad esempio, l&quot;applicazione può avviare Blocco note per consentire all&quot;utente di eseguire la modifica del testo, ma senza ulteriore utilizzare del blocco note. È possibile scegliere di non ricevere una notifica quando il processo viene chiuso, perché non è pertinente per l&quot;operazione continua dell&quot;applicazione. Impostare EnableRaisingEvents `false` consente di risparmiare risorse di sistema."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> evento deve essere generato quando il processo associato viene terminato (mediante un&quot;uscita o una chiamata a <xref:System.Diagnostics.Process.Kill*>); in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inserisce un <xref href=&quot;System.Diagnostics.Process&quot;> </xref> processi componenti in stato di interagire con il sistema operativo eseguiti in modalità speciale attivando la proprietà nativa <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> sul thread corrente."
  remarks: "Alcuni processi del sistema operativo eseguiti in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non è stato chiamato EnterDebugMode sul componente. Chiamare <xref:System.Diagnostics.Process.LeaveDebugMode%2A>quando non è più necessario l&quot;accesso a questi processi eseguiti in modalità speciale.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Si verifica quando un&quot;applicazione scrive nel proprio flusso <xref:System.Diagnostics.Process.StandardError*>flusso.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "L&quot;evento ErrorDataReceived indica che il processo associato ha scritto nel proprio flusso <xref:System.Diagnostics.Process.StandardError%2A>flusso.</xref:System.Diagnostics.Process.StandardError%2A>       L&quot;evento si verifica solo durante le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Per avviare le operazioni di lettura asincrone, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardError%2A>flusso di una <xref:System.Diagnostics.Process>, aggiungere il gestore eventi all&quot;evento ErrorDataReceived e chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Successivamente, l&quot;evento ErrorDataReceived segnala ogni volta che il processo scrive una riga al reindirizzato al <xref:System.Diagnostics.Process.StandardError%2A>flusso, fino a quando il processo viene chiuso o chiamate <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > L&quot;applicazione di elaborazione dell&quot;output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A>metodo per assicurarsi che il buffer di output è stato scaricato.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il valore specificato dal processo associato quando è stato terminato."
  remarks: "Utilizzare ExitCode per ottenere lo stato restituito il processo di sistema quando è stato terminato. È possibile utilizzare il codice di uscita molto, analogamente a un numero intero restituito da un `main()` stored procedure.       Il valore di codice di uscita per un processo riflette la specifica convenzione implementata dallo sviluppatore dell&quot;applicazione per tale processo. Se si utilizza il valore del codice di uscita per prendere decisioni nel codice, assicurarsi di conoscere la convenzione di codice di uscita utilizzata dal processo di applicazione.       In genere, gli sviluppatori di indicano l&quot;esito positivo da un valore di codice di uscita pari a zero e definiscono valori diversi da zero che è possibile utilizzare il metodo chiamante per identificare la causa di una chiusura anomala di processo come errori. Non è necessario seguire queste linee guida, ma sono la convenzione.       Se si tenta di ottenere il codice di uscita prima che il processo è terminato, il tentativo genera un&quot;eccezione. Esaminare il <xref:System.Diagnostics.Process.HasExited%2A>proprietà prima di verificare se il processo associato è terminato.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Quando l&quot;output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l&quot;elaborazione di output non deve avere completata quando <xref:System.Diagnostics.Process.HasExited%2A>restituisce `true`.</xref:System.Diagnostics.Process.HasExited%2A> Per garantire che la gestione degli eventi asincroni è stata completata, chiamare l&quot; <xref:System.Diagnostics.Process.WaitForExit>overload che non accetta alcun parametro prima dell&quot;archiviazione <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       È possibile utilizzare il <xref:System.Diagnostics.Process.CloseMainWindow%2A>o <xref:System.Diagnostics.Process.Kill%2A>metodo a causa di un processo venga terminato.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Esistono due modi di ricevere una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. La notifica sincrona si basa sulla chiamata di <xref:System.Diagnostics.Process.WaitForExit%2A>metodo sospendere l&quot;elaborazione dell&quot;applicazione fino a quando non viene terminato il componente associato.</xref:System.Diagnostics.Process.WaitForExit%2A> Notifica asincrona si basa sul <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited> Quando si utilizza la notifica asincrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve essere impostato su `true` per il <xref:System.Diagnostics.Process>componente per ricevere una notifica che il processo è terminato.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "Codice specificato dal processo associato quando è stato terminato."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non è terminato.       Il processo - oppure - <xref:System.Diagnostics.Process.Handle*>non è valido.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà ExitCode per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Si verifica quando un processo viene chiuso."
  remarks: "L&quot;evento Exited indica che il processo associato è stato terminato. Questa situazione indica che il processo di terminazione (interruzione) o è stato chiuso correttamente. Questo evento può verificarsi solo se il valore di <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>proprietà `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Esistono due modi di ricevere una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. Notifica sincrona, chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A>metodo per bloccare il thread corrente finché il processo viene chiuso.</xref:System.Diagnostics.Process.WaitForExit%2A> Notifica asincrona utilizza l&quot;evento Exited, che consente di continuare l&quot;esecuzione nel frattempo il thread chiamante. Nel secondo caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve essere impostato su `true` per l&quot;applicazione chiamante di ricevere l&quot;evento Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Quando il sistema operativo viene arrestato un processo, invia una notifica a tutti gli altri processi che hanno registrato i gestori per l&quot;evento Exited. A questo punto, l&quot;handle del processo di cui è appena stato terminato può essere utilizzato per accedere ad esempio alcune proprietà <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.HasExited%2A>che il sistema operativo gestisce fino a quando non rilascia l&quot;handle completamente.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Anche se si dispone di un handle a un processo terminato, non è possibile chiamare <xref:System.Diagnostics.Process.Start%2A>per ristabilire la connessione allo stesso processo.</xref:System.Diagnostics.Process.Start%2A> La chiamata a <xref:System.Diagnostics.Process.Start%2A>rilasciare il processo associato automaticamente e si connette a un processo con lo stesso file, ma un completamente nuovo <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.Start%2A>       Per ulteriori informazioni sull&quot;utilizzo dell&quot;evento Exited nelle applicazioni Windows Forms, vedere il <xref:System.Diagnostics.Process.SynchronizingObject%2A>proprietà.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;ora in cui è stato terminato il processo associato."
  remarks: "Se non è stato terminato il processo, il tentativo di recuperare la proprietà ExitTime genera un&quot;eccezione. Utilizzare <xref:System.Diagnostics.Process.HasExited%2A>prima di ottenere la proprietà ExitTime per determinare se il processo associato è terminato.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "Oggetto <xref:System.DateTime>che indica quando il processo associato è stato terminato.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà ExitTime per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e lo associa al processo attivo."
  remarks: "Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process>istanza e associarlo alla risorsa di processo nel computer locale.</xref:System.Diagnostics.Process>       Ad esempio simile <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A>metodi, GetCurrentProcess associa una risorsa esistente a un nuovo <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente associato alla risorsa di processo che esegue l&quot;applicazione chiamante."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Restituisce un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, dato l&quot;identificatore di un processo nel computer locale."
  remarks: "Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process>componente e associarlo a una risorsa di processo nel computer locale.</xref:System.Diagnostics.Process> La risorsa di processo deve esistere nel computer, perché GetProcessById non crea una risorsa di sistema, ma piuttosto generati dall&quot;applicazione associa una risorsa <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Un processo <xref:System.Diagnostics.Process.Id%2A>può essere recuperato solo per un processo attualmente in esecuzione nel computer.</xref:System.Diagnostics.Process.Id%2A> Una volta terminato il processo, GetProcessById genera un&quot;eccezione se viene passato un identificatore scaduto.       Su un particolare computer, l&quot;identificatore di un processo è univoco. GetProcessById restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione di una determinata applicazione, utilizzare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se esistono più processi del computer che esegue l&quot;applicazione specificata, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>restituisce una matrice contenente tutti i processi associati.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L&quot;identificatore di processo può essere visualizzato nel `Processes` riquadro Task Manager di Windows. Il `PID` colonna viene visualizzato l&quot;identificatore di processo che viene assegnato a un processo."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "Identificatore univoco del sistema di una risorsa di processo."
    return:
      type: System.Diagnostics.Process
      description: "Oggetto <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente associato alla risorsa locale del processo identificata dal <code> processId </code> parametro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il processo specificato dal <code> processId </code> parametro non è in esecuzione. L&quot;identificatore potrebbe essere scaduto."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non è stato avviato da questo oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Restituisce un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, dato un identificatore di processo e il nome di un computer sulla rete."
  remarks: "Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process>componente e associarlo a una risorsa di processo in un computer remoto sulla rete.</xref:System.Diagnostics.Process> La risorsa di processo deve esistere nel computer specificato, perché GetProcessById non crea una risorsa di sistema, ma piuttosto generati dall&quot;applicazione associa una risorsa <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Un processo <xref:System.Diagnostics.Process.Id%2A>può essere recuperato solo per un processo attualmente in esecuzione nel computer.</xref:System.Diagnostics.Process.Id%2A> Una volta terminato il processo, GetProcessById genera un&quot;eccezione se viene passato un identificatore scaduto.       Su un particolare computer, l&quot;identificatore di un processo è univoco. GetProcessById restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione di una determinata applicazione, utilizzare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se esistono più processi del computer che esegue l&quot;applicazione specificata, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>restituisce una matrice contenente tutti i processi associati.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L&quot;identificatore di processo può essere visualizzato nel `Processes` riquadro Task Manager di Windows. Il `PID` colonna viene visualizzato l&quot;identificatore di processo che viene assegnato a un processo.       Se non si specifica un `machineName`, viene usato il computer locale. In alternativa, è possibile specificare il computer locale tramite l&quot;impostazione `machineName` sul valore &quot;.&quot; o su una stringa vuota (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "Identificatore univoco del sistema di una risorsa di processo."
    - id: machineName
      type: System.String
      description: "Il nome del computer di rete."
    return:
      type: System.Diagnostics.Process
      description: "Oggetto <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente che è associato a una risorsa di processo remota identificata dal <code> processId </code> parametro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il processo specificato dal <code> processId </code> parametro non è in esecuzione. L&quot;identificatore potrebbe essere scaduto.       - o - <code> machineName </code> sintassi del parametro non è valida. Il nome potrebbe avere lunghezza zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non è stato avviato da questo oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Crea un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente per ogni risorsa di processo nel computer locale."
  remarks: "Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process>componenti e associarli a tutte le risorse di processo nel computer locale.</xref:System.Diagnostics.Process> Le risorse di processo devono esistere nel computer locale, perché GetProcesses crea risorse di sistema, ma piuttosto associa risorse generati dall&quot;applicazione <xref:System.Diagnostics.Process>componenti.</xref:System.Diagnostics.Process> Poiché il sistema operativo è in esecuzione i processi in background, questa matrice non è mai vuota.       Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero utilizzando il <xref:System.Diagnostics.Process.GetProcessById%2A>o <xref:System.Diagnostics.Process.GetProcessesByName%2A>metodo.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>Crea un <xref:System.Diagnostics.Process>componente associato al processo identificato nel sistema dall&quot;identificatore di processo che viene passato al metodo.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>Crea una matrice di <xref:System.Diagnostics.Process>componenti con risorse di processo associato che condividono il file eseguibile passare al metodo.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Nella stessa istanza del processo Host del servizio (svchost.exe) possono essere caricato da servizi di più finestre. GetProcesses non identifica i singoli servizi; a tale scopo, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> che rappresenta tutte le risorse di processo in esecuzione nel computer locale."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Crea un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente per ogni risorsa di processo nel computer specificato."
  remarks: "Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process>componenti e associarli a tutte le risorse di processo nel computer specificato (in genere remoto).</xref:System.Diagnostics.Process> Le risorse di processo devono esistere nel computer locale, perché <xref:System.Diagnostics.Process.GetProcesses%2A>crea risorse di sistema, ma piuttosto associa risorse generati dall&quot;applicazione <xref:System.Diagnostics.Process>componenti.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Poiché il sistema operativo è in esecuzione i processi in background, questa matrice non è mai vuota.       Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero utilizzando il <xref:System.Diagnostics.Process.GetProcessById%2A>o <xref:System.Diagnostics.Process.GetProcessesByName%2A>metodo.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>Crea un <xref:System.Diagnostics.Process>componente associato al processo identificato nel sistema dall&quot;identificatore di processo che viene passato al metodo.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>Crea una matrice di <xref:System.Diagnostics.Process>componenti con risorse di processo associato che condividono il file eseguibile passare al metodo.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Questo overload del metodo di <xref:System.Diagnostics.Process.GetProcesses%2A>metodo viene in genere utilizzato per recuperare l&quot;elenco delle risorse di processo in esecuzione in un computer remoto sulla rete, ma è possibile specificare il computer locale mediante il passaggio &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Nella stessa istanza del processo Host del servizio (svchost.exe) possono essere caricato da servizi di più finestre. GetProcesses non identifica i singoli servizi; a tale scopo, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "Il computer da cui leggere l&quot;elenco di processi."
    return:
      type: System.Diagnostics.Process[]
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> che rappresenta tutte le risorse di processo in esecuzione nel computer specificato."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il <code> machineName </code> sintassi del parametro non è valida. Potrebbe avere lunghezza zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma del sistema operativo non supporta questa operazione in computer remoti."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Sono presenti problemi di accesso il contatore delle prestazioni che API utilizzata per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;accesso a un&quot;API di sistema sottostante."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Crea una matrice di nuovi <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componenti e li associa a tutte le risorse di processo nel computer locale che condividono il nome del processo specificato."
  remarks: "Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process>componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer locale.</xref:System.Diagnostics.Process> Le risorse di processo devono esistere nel computer, perché GetProcessesByName crea risorse di sistema, ma piuttosto li associa generati dall&quot;applicazione <xref:System.Diagnostics.Process>componenti.</xref:System.Diagnostics.Process> Oggetto `processName` può essere specificato per un file eseguibile che non è attualmente in esecuzione nel computer locale, pertanto la matrice restituita dal metodo può essere vuota.       Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l&quot;estensione .exe o il percorso. Metodo GetProcessesByName è utile per ottenere e modificare tutti i processi che sono associati lo stesso file eseguibile. Ad esempio, è possibile passare un nome del file eseguibile come i `processName` parametro, per arrestare tutte le istanze in esecuzione del file eseguibile.       Anche se un processo <xref:System.Diagnostics.Process.Id%2A>è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale può eseguire l&quot;applicazione specificata dal `processName` parametro.</xref:System.Diagnostics.Process.Id%2A> Pertanto, <xref:System.Diagnostics.Process.GetProcessById%2A>restituisce un processo al massimo, ma GetProcessesByName restituisce una matrice contenente tutti i processi associati.</xref:System.Diagnostics.Process.GetProcessById%2A> Se è necessario modificare il processo utilizzando le chiamate API standard, è possibile eseguire query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo avere recuperato una matrice di <xref:System.Diagnostics.Process>componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "Il nome descrittivo del processo."
    return:
      type: System.Diagnostics.Process[]
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> che rappresenta le risorse di processo in esecuzione l&quot;applicazione specificata o il file."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Sono presenti problemi di accesso il contatore delle prestazioni che API utilizzata per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Crea una matrice di nuovi <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componenti e li associa a tutte le risorse di processo in un computer remoto che condividono il nome del processo specificato."
  remarks: "Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process>componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer specificato.</xref:System.Diagnostics.Process> Le risorse di processo devono esistere nel computer, perché <xref:System.Diagnostics.Process.GetProcessesByName%2A>non crea le risorse di sistema, ma piuttosto li associa generati dall&quot;applicazione <xref:System.Diagnostics.Process>componenti.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> Oggetto `processName` può essere specificato per un file eseguibile che non è attualmente in esecuzione nel computer locale, pertanto la matrice restituita dal metodo può essere vuota.       Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l&quot;estensione .exe o il percorso. <xref:System.Diagnostics.Process.GetProcessesByName%2A>è utile per ottenere e modificare tutti i processi che sono associati lo stesso file eseguibile.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Ad esempio, è possibile passare un nome del file eseguibile come i `processName` parametro, per arrestare tutte le istanze in esecuzione del file eseguibile.       Anche se un processo <xref:System.Diagnostics.Process.Id%2A>è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale può eseguire l&quot;applicazione specificata dal `processName` parametro.</xref:System.Diagnostics.Process.Id%2A> Pertanto, <xref:System.Diagnostics.Process.GetProcessById%2A>restituisce al massimo un processo ma <xref:System.Diagnostics.Process.GetProcessesByName%2A>restituisce una matrice contenente tutti i processi associati.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Se è necessario modificare il processo utilizzando le chiamate API standard, è possibile eseguire query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo avere recuperato una matrice di <xref:System.Diagnostics.Process>componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.</xref:System.Diagnostics.Process>       È possibile utilizzare questo overload per ottenere i processi nel computer locale e in un computer remoto. Utilizzare &quot;.&quot; per specificare il computer locale. Un altro overload esistente che utilizza il computer locale per impostazione predefinita.       È possibile accedere ai processi nei computer remoto solo per visualizzare informazioni sui processi, ad esempio le statistiche. Non è possibile chiudere, terminare (utilizzando <xref:System.Diagnostics.Process.Kill%2A>), oppure avviare i processi nel computer remoto.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "Il nome descrittivo del processo."
    - id: machineName
      type: System.String
      description: "Il nome del computer di rete."
    return:
      type: System.Diagnostics.Process[]
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> che rappresenta le risorse di processo in esecuzione l&quot;applicazione specificata o il file."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il <code> machineName </code> sintassi del parametro non è valida. Potrebbe avere lunghezza zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma del sistema operativo non supporta questa operazione in computer remoti."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Sono presenti problemi di accesso il contatore delle prestazioni che API utilizzata per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;accesso a un&quot;API di sistema sottostante."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;handle nativo del processo associato."
  remarks: "Un&quot;applicazione può ottenere un handle a un processo che può essere utilizzato come parametro per molte funzioni di controllo e le informazioni di processo. È possibile utilizzare questo handle per inizializzare un <xref:System.Threading.WaitHandle>o chiamare metodi nativi con platform invoke.</xref:System.Threading.WaitHandle>       Questo handle del processo è privato per un&quot;applicazione, in altre parole, non è possibile condividere gli handle di processo. Un processo dispone anche di un processo <xref:System.Diagnostics.Process.Id%2A>che, a differenza dell&quot;Handle, è univoco e, pertanto, valida in tutto il sistema.</xref:System.Diagnostics.Process.Id%2A>       Solo i processi avviati tramite una chiamata a <xref:System.Diagnostics.Process.Start%2A>impostare la proprietà di Handle dell&quot;oggetto corrispondente <xref:System.Diagnostics.Process>istanze.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "L&quot;handle del sistema operativo assegnato al processo associato quando è stato avviato il processo. Il sistema Usa questo handle per tenere traccia degli attributi del processo."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non è stato avviato o è stato terminato. Impossibile leggere la proprietà Handle Nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> istanza.       - o - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> istanza è stata collegata a un processo in esecuzione ma non si dispone delle autorizzazioni necessarie per ottenere un handle con diritti di accesso completo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà Handle per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il numero di handle aperti dal processo."
  remarks: "Gli handle forniscono un modo per un processo fare riferimento a oggetti. Un processo può ottenere l&quot;handle di file, risorse, le code di messaggi e molti altri oggetti di sistema operativo. Il sistema operativo recupera la memoria associata al processo solo quando il numero di handle è zero."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Il numero di handle del sistema operativo che aperti dal processo."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare il &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; proprietà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un valore che indica se il processo associato è stato terminato."
  remarks: "Il valore `true` per HasExited indica che il processo associato è stato terminato normalmente o in modo anomalo. È possibile richiedere o forzare il processo associato venga terminato chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>o <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Se un handle aperto per il processo, il sistema operativo rilascia la memoria del processo quando il processo è stato chiuso, ma mantiene le informazioni amministrative sul processo, ad esempio l&quot;handle, codice di uscita e il tempo di uscita. Per ottenere queste informazioni, è possibile utilizzare il <xref:System.Diagnostics.Process.ExitCode%2A>e <xref:System.Diagnostics.Process.ExitTime%2A>proprietà.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Queste proprietà vengono popolate automaticamente per i processi avviati da questo componente. Le informazioni amministrative vengono rilasciate quando tutti i <xref:System.Diagnostics.Process>componenti che sono associati il processo di sistema vengono eliminati definitivamente e contenere handle non sono più presenti al processo terminato.</xref:System.Diagnostics.Process>       Un processo può terminare indipendentemente dal codice. Se il processo utilizzando questo componente è stato avviato, il sistema aggiorna il valore della proprietà HasExited automaticamente, anche se il processo associato viene terminato in modo indipendente.      > [!NOTE] > Quando l&quot;output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l&quot;elaborazione di output non sia completata quando questa proprietà restituisce `true`. Per garantire che la gestione degli eventi asincroni è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit>overload che non accetta alcun parametro prima dell&quot;archiviazione HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il processo del sistema operativo a cui fa riferimento il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente è stato terminato; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "È presente alcun processo associato all&quot;oggetto."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Non è stato possibile recuperare il codice di uscita per il processo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà HasExited per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;identificatore univoco per il processo associato."
  remarks: "Il processo di Id non è valido se non è in esecuzione il processo associato. Pertanto, è necessario assicurarsi che il processo è in esecuzione prima di tentare di recuperare la proprietà Id. Finché non termina il processo, l&quot;identificatore di processo identifica in modo univoco il processo in tutto il sistema.       È possibile connettersi a un processo è in esecuzione in un computer locale o remoto in un nuovo <xref:System.Diagnostics.Process>istanza passando l&quot;identificatore di processo per il <xref:System.Diagnostics.Process.GetProcessById%2A>metodo.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>è un `static` metodo che crea un nuovo componente e imposta la proprietà Id per il nuovo <xref:System.Diagnostics.Process>istanza automaticamente.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Identificatori di processo possono essere riutilizzati dal sistema. Il valore della proprietà Id è univoco solo durante l&quot;esecuzione del processo associato. Dopo aver terminato il processo, il sistema può riutilizzare il valore della proprietà Id per un processo non correlato.       Poiché l&quot;identificatore è univoco nel sistema, è possibile passare, altri thread come alternativa a passare un <xref:System.Diagnostics.Process>istanza.</xref:System.Diagnostics.Process> Questa azione può risparmiare risorse di sistema e garantire che il processo è stato identificato correttamente."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Identificatore univoco generato dal sistema del processo di cui fa riferimento questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> istanza."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Proprietà Id del processo non è stata impostata.       - oppure - nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare il &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; proprietà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Arresta immediatamente il processo associato."
  remarks: "Kill impone la terminazione del processo, mentre <xref:System.Diagnostics.Process.CloseMainWindow%2A>richiede solo una terminazione.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Quando è in esecuzione un processo con un&quot;interfaccia grafica, il ciclo di messaggi è in stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata <xref:System.Diagnostics.Process.CloseMainWindow%2A>Invia una richiesta di chiusura della finestra principale, che, in un&quot;applicazione ben formata, chiude le finestre figlio e revoca tutti in esecuzione i cicli di messaggi per l&quot;applicazione.</xref:System.Diagnostics.Process.CloseMainWindow%2A> La richiesta di terminazione del processo chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>non forza la chiusura dell&quot;applicazione.</xref:System.Diagnostics.Process.CloseMainWindow%2A> L&quot;applicazione può richiedere la verifica dell&quot;utente prima di chiudere o rifiutare la chiusura. Per forzare la chiusura dell&quot;applicazione, utilizzare il metodo Kill. Il comportamento di <xref:System.Diagnostics.Process.CloseMainWindow%2A>è identico a quello di un utente chiudendo la finestra principale di un&quot;applicazione utilizzando il menu di sistema.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone la chiusura immediatamente dell&quot;applicazione.      > [!NOTE] > Terminare il metodo viene eseguito in modo asincrono. Dopo aver chiamato il metodo Kill, chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A>metodo per attendere che il processo di uscita o verificare il <xref:System.Diagnostics.Process.HasExited%2A>proprietà per determinare se il processo è terminato.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       I dati modificati dal processo o le risorse allocate al processo possono essere perse se si chiama Kill. Kill causa una terminazione anomala processo e deve essere utilizzato solo quando necessario. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Abilita una terminazione corretta del processo e chiude tutte le finestre, pertanto è preferibile per le applicazioni con un&quot;interfaccia.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Se <xref:System.Diagnostics.Process.CloseMainWindow%2A>ha esito negativo, è possibile utilizzare Kill per terminare il processo.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill è l&quot;unico modo per terminare i processi che non dispongono di interfacce grafiche.       È possibile chiamare Kill e <xref:System.Diagnostics.Process.CloseMainWindow%2A>solo per i processi in esecuzione nel computer locale.</xref:System.Diagnostics.Process.CloseMainWindow%2A> È Impossibile i processi in computer remoti per uscire dall&quot;installazione. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti.      > [!NOTE] > Se viene effettuata la chiamata al metodo Kill durante il processo è in fase di chiusura, un <xref:System.ComponentModel.Win32Exception>viene generata per accesso negato.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile terminare il processo associato.       - oppure - il processo verrà terminato.       - oppure - il processo associato è un eseguibile Win16."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di chiamare Kill per un processo è in esecuzione in un computer remoto. Il metodo è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo già terminato.       - oppure - nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Accetta un <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente dallo stato che permette di interagire con i processi del sistema operativo eseguiti in modalità speciale."
  remarks: "Alcuni processi del sistema operativo eseguiti in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non è stato chiamato <xref:System.Diagnostics.Process.EnterDebugMode%2A>sul componente.</xref:System.Diagnostics.Process.EnterDebugMode%2A> Chiamare LeaveDebugMode quando non è più necessario l&quot;accesso a questi processi eseguiti in modalità speciale."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il nome del computer che in cui è in esecuzione il processo associato."
  remarks: "È possibile visualizzare i dati statistici e le informazioni sui processi in esecuzione in computer remoti, ma è possono chiamare <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, o <xref:System.Diagnostics.Process.Kill%2A>in computer remoti.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > Quando il processo associato è in esecuzione nel computer locale, questa proprietà restituisce un punto (&quot;.&quot;) per il nome del computer. È consigliabile utilizzare il <xref:System.Environment.MachineName%2A?displayProperty=fullName>proprietà per ottenere il nome computer corretto.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "Il nome del computer in cui è in esecuzione il processo associato."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il modulo principale per il processo associato."
  remarks: "Un modulo di processo rappresenta i file DLL o .exe che viene caricato in un determinato processo. La proprietà MainModule consente di visualizzare le informazioni relative all&quot;eseguibile utilizzato per avviare il processo, inclusi il nome del modulo, nome file e i dettagli della memoria del modulo."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "Il <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> utilizzato per avviare il processo."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà MainModule per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Un processo a 32 bit sta tentando di accedere ai moduli di un processo a 64 bit."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>       - oppure - il processo è terminato."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;handle della finestra principale del processo associato."
  remarks: "La finestra principale è la finestra aperta dal processo che ha attualmente lo stato attivo (la <xref:System.Windows.Forms.Form.TopLevel%2A>form).</xref:System.Windows.Forms.Form.TopLevel%2A> È necessario utilizzare il <xref:System.Diagnostics.Process.Refresh%2A>per aggiornare il <xref:System.Diagnostics.Process>oggetto per cui ottenere l&quot;handle della finestra principale corrente, se è stata modificata.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> In generale, poiché verrà memorizzati nella cache l&quot;handle di finestra, utilizzare <xref:System.Diagnostics.Process.Refresh%2A>in anticipo per garantire che l&quot;handle corrente verranno recuperate.</xref:System.Diagnostics.Process.Refresh%2A>       È possibile ottenere la proprietà MainWindowHandle solo per i processi in esecuzione nel computer locale. La proprietà MainWindowHandle è un valore che identifica in modo univoco la finestra che viene associata al processo.       Un processo ha una finestra principale associata solo se il processo ha un&quot;interfaccia grafica. Se il processo associato non dispone di una finestra principale, il valore di MainWindowHandle è zero. Anche il valore è zero per i processi che sono stati nascosti, processi, ovvero che non sono visibili nella barra delle applicazioni. Può essere il caso per i processi che vengono visualizzati come icone nell&quot;area di notifica, all&quot;estrema destra della barra delle applicazioni.       Se è stato appena avviato un processo e si desidera utilizzare il relativo handle della finestra principale, è consigliabile utilizzare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metodo per consentire al processo di completare l&quot;avvio, garantendo che è stato creato l&quot;handle di finestra principale.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> In caso contrario, verrà generata un&quot;eccezione."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "L&quot;handle della finestra generati dal sistema della finestra principale del processo associato."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il MainWindowHandle non è definita perché il processo è terminato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà MainWindowHandle per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la didascalia della finestra principale del processo."
  remarks: "Un processo ha una finestra principale associata solo se il processo ha un&quot;interfaccia grafica. Se il processo associato non dispone di una finestra principale (in modo che <xref:System.Diagnostics.Process.MainWindowHandle%2A>è uguale a zero), MainWindowTitle è una stringa vuota (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Se è stato appena avviato un processo e si desidera utilizzare il titolo della finestra principale, è consigliabile utilizzare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metodo per consentire al processo di completare l&quot;avvio, garantendo che è stato creato l&quot;handle di finestra principale.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> In caso contrario, il sistema genera un&quot;eccezione.      > [!NOTE] > La finestra principale è la finestra che ha attualmente lo stato attivo; si noti che potrebbe non essere la finestra principale per il processo. È necessario utilizzare il <xref:System.Diagnostics.Process.Refresh%2A>per aggiornare il <xref:System.Diagnostics.Process>oggetto per cui ottenere l&quot;handle della finestra principale corrente, se è stata modificata.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "Il titolo della finestra principale del processo."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "La proprietà MainWindowTitle non è definita perché il processo è terminato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà MainWindowTitle per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta la dimensione massima consentita working set, in byte, per il processo associato."
  remarks: "Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni di esecuzione dell&quot;applicazione, incluse le pagine nel file con estensione dll e file DLL di sistema. Working set di dimensioni maggiori, aumenta la richiesta di memoria.       Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria uguale alla minima dimensione del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai superiore rispetto alla dimensione massima.       Il sistema imposta il valore predefinito del working set. È possibile modificare queste dimensioni utilizzando il MaxWorkingSet e <xref:System.Diagnostics.Process.MinWorkingSet%2A>membri.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Tuttavia, l&quot;impostazione di questi valori non garantisce che la memoria sia riservato o residenti.      > [!NOTE] > Quando si aumenta la dimensione del working set di un processo, si accettano quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del set working minimo o massimo che è troppo grande, poiché possono peggiorare le prestazioni del sistema."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Il working set massimo dimensioni che sono consentita in memoria per il processo, in byte."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La dimensione massima del working set non è valida. Deve essere maggiore o uguale alla minima dimensione del working set."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile recuperare informazioni sul working set dalla risorsa di processo associato.       oppure l&quot;identificatore di processo o l&quot;handle del processo è zero perché il processo non è stato avviato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà MaxWorkingSet per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>       - oppure - il processo è terminato."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta la dimensione minima consentita working set, in byte, per il processo associato."
  remarks: "Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni di esecuzione dell&quot;applicazione, incluse le pagine nel file con estensione dll e file DLL di sistema. Working set di dimensioni maggiori, aumenta la richiesta di memoria.       Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria uguale alla minima dimensione del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai superiore rispetto alla dimensione massima.       Il sistema imposta il valore predefinito del working set. È possibile modificare queste dimensioni utilizzando il <xref:System.Diagnostics.Process.MaxWorkingSet%2A>e membri MinWorkingSet.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Tuttavia, l&quot;impostazione di questi valori non garantisce che la memoria sia riservato o residenti.      > [!NOTE] > Quando si aumenta la dimensione del working set di un processo, si accettano quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del set working minimo o massimo che è troppo grande, poiché possono peggiorare le prestazioni del sistema."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Minima del working set dimensioni necessarie in memoria per il processo, in byte."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La dimensione minima del working set non è valido. Deve essere minore o uguale alla dimensione massima del working set."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile recuperare informazioni sul working set dalla risorsa di processo associato.       oppure l&quot;identificatore di processo o l&quot;handle del processo è zero perché il processo non è stato avviato."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà MinWorkingSet per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>       - oppure - il processo è terminato."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene i moduli che sono stati caricati dal processo associato."
  remarks: "Un modulo di processo rappresenta i file DLL o .exe che viene caricato in un determinato processo. Oggetto <xref:System.Diagnostics.ProcessModule>istanza consente di visualizzare informazioni su un modulo, inclusi il nome del modulo, nome file e i dettagli della memoria del modulo.</xref:System.Diagnostics.ProcessModule>       Un processo è possibile caricare più moduli in memoria. Ad esempio, file .exe che caricano altri file DLL dispongono di più moduli.       Dopo avere avviato il processo, la raccolta è vuota finché non il sistema ha caricato il processo. Se il processo dispone di una finestra principale, è possibile chiamare <xref:System.Diagnostics.Process.WaitForInputIdle%2A>prima di recuperare questa proprietà per assicurarsi che la raccolta è vuota quando si ottiene un elenco.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> che rappresenta i moduli che sono stati caricati dal processo associato."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà di moduli per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si sta tentando di accedere alla proprietà di moduli per il processo di sistema o il processo inattivo. Questi processi non dispone di moduli."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità di memoria, in byte, allocata dal sistema per il processo associato che non può essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema non di paging usata dal processo, in byte. Memoria di sistema è la memoria fisica utilizzata dal sistema operativo e viene divisa in pool di paging e. Le allocazioni di memoria non paginata rimangono nella memoria di sistema e non vengono inviate al file di paging della memoria virtuale.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte del Pool non di paging** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria di sistema, in byte, allocata per il processo associato che non può essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Genera il <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> evento."
  remarks: "OnExited è il metodo API che genera il <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited> La chiamata a cause OnExited il <xref:System.Diagnostics.Process.Exited>dell&quot;evento ed è l&quot;unico modo per generare l&quot;evento utilizzando il <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited viene principalmente utilizzato per la derivazione di classi dal componente.       In alternativa a OnExited, è possibile scrivere un proprio gestore eventi. Creare il propria delegato del gestore eventi e un metodo di gestione degli eventi.      > [!NOTE] > Se si utilizza l&quot;ambiente di Visual Studio, un delegato del gestore eventi (AddOnExited) e un metodo di gestione degli eventi (Process1_Exited) vengono creati automaticamente quando si trascina un <xref:System.Diagnostics.Process>componente in un form e fare doppio clic sull&quot;icona.</xref:System.Diagnostics.Process> Il codice creato per l&quot;esecuzione quando il <xref:System.Diagnostics.Process.Exited>evento si verifica è immesso nella routine Process1_Exited.</xref:System.Diagnostics.Process.Exited> Non è necessario creare il membro OnExited, perché è già stato implementato.       Viene generato un evento richiama il gestore dell&quot;evento tramite un delegato. Per una panoramica, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Si verifica ogni volta che un&quot;applicazione scrive nel proprio flusso <xref:System.Diagnostics.Process.StandardOutput*>flusso.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "L&quot;evento OutputDataReceived indica che l&quot;oggetto associato <xref:System.Diagnostics.Process>ha scritto una riga, terminare con un carattere di nuova riga, nel proprio flusso <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       L&quot;evento è abilitato durante le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Per avviare le operazioni di lettura asincrone, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardOutput%2A>flusso di una <xref:System.Diagnostics.Process>, aggiungere il gestore eventi all&quot;evento OutputDataReceived e chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Successivamente, l&quot;evento OutputDataReceived segnala ogni volta che il processo scrive una riga al reindirizzato al <xref:System.Diagnostics.Process.StandardOutput%2A>flusso, fino a quando il processo viene chiuso o chiamate <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > L&quot;applicazione di elaborazione dell&quot;output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A>metodo per assicurarsi che il buffer di output è stato scaricato.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità di memoria, in byte, allocata dal processo associato che può essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria nel file di paging della memoria virtuale usata dal processo, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio di indirizzi virtuali per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni di memoria utilizzata dal sistema operativo per il processo, utilizzare il <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>proprietà.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte File di paging** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità di memoria, in byte, allocata dal sistema per il processo associato che può essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema paginabile utilizzata dal processo, in byte. Memoria di sistema è la memoria fisica utilizzata dal sistema operativo e viene divisa in pool di paging e. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni della memoria dell&quot;applicazione utilizzata dal processo, utilizzare il <xref:System.Diagnostics.Process.PagedMemorySize64%2A>proprietà.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte del Pool di paging** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria di sistema, in byte, allocata per il processo associato che può essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità massima di memoria nel file di paging della memoria virtuale, in byte, utilizzata dal processo associato."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità massima di memoria, in byte, allocata dal processo associato che potrebbe essere scritta nel file di paging della memoria virtuale."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità massima di memoria nel file di paging della memoria virtuale, in byte, utilizzata dal processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione massima di memoria nel file di paging della memoria virtuale usata dal processo dall&quot;avvio, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio di indirizzi virtuali per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **Byte massimi File** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità massima di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato da quando è stato avviato."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità massima di memoria virtuale, in byte, utilizzata dal processo associato."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità massima di memoria virtuale, in byte, che il processo associato ha richiesto."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità massima di memoria virtuale, in byte, utilizzata dal processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione massima di memoria virtuale usata dal processo dall&quot;avvio, in byte. Il sistema operativo esegue il mapping di spazio degli indirizzi virtuali per ogni processo alle pagine caricate nella memoria fisica, o per le pagine memorizzate nel file di paging della memoria virtuale su disco.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **massimo valore byte virtuali** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità massima di memoria virtuale, in byte, allocata per il processo associato da quando è stato avviato."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene le dimensioni massime working set per il processo associato, in byte."
  remarks: "Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "La quantità massima di memoria fisica che il processo associato ha richiesto in una sola volta, in byte."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità massima di memoria fisica, espressa in byte, utilizzata dal processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione massima del working set di memoria utilizzata dal processo dall&quot;avvio, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni che il processo viene eseguito, incluse le istruzioni da moduli di processo e le librerie di sistema.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **max Working Set** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "La quantità massima di memoria fisica, in byte, allocata per il processo associato da quando è stato avviato."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta un valore che indica se la priorità del processo associato deve essere incrementata temporaneamente dal sistema operativo quando la finestra principale è attiva."
  remarks: "Quando un thread viene eseguito in un processo per cui la classe di priorità è uno dei valori di enumerazione priorità dinamica (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, o <xref:System.Diagnostics.ProcessPriorityClass>), il sistema incrementa temporaneamente la priorità del thread quando viene escluso da uno stato di attesa.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Questa azione impedisce ad altri processi di interrompere l&quot;elaborazione del thread corrente. L&quot;impostazione PriorityBoostEnabled influisce su tutti i thread esistenti e su qualsiasi thread successivamente creato dal processo. Per ripristinare il funzionamento normale, impostare la proprietà PriorityBoostEnabled su `false`.      > [!NOTE] > Aumento eccessivo della priorità può sottrarre risorse essenziali del sistema operativo e le funzioni di rete, causando problemi con le altre attività del sistema operativo."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se eseguito l&quot;incremento dinamico della priorità del processo da eseguire per un processo quando questa viene eliminata dallo stato di attesa; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile recuperare informazioni sull&quot;aumento della priorità dalla risorsa di processo associato."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.       - oppure - l&quot;identificatore di processo o l&quot;handle del processo è zero. (Non è stato avviato il processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà PriorityBoostEnabled per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta la categoria di priorità globale per il processo associato."
  remarks: "Una classe di priorità del processo include una gamma di livelli di priorità di thread. I thread con priorità diverse che sono in esecuzione nel processo di esecuzione rispetto alla classe di priorità del processo. Win32 utilizza quattro classi di priorità con sette livelli di priorità di base per ogni classe. Queste classi di priorità del processo vengono acquisite nel <xref:System.Diagnostics.ProcessPriorityClass>enumerazione, che consente di imposta la priorità del processo <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, o <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> In base al tempo trascorsi o degli altri incrementi, il livello di priorità di base possono essere modificati dal sistema operativo quando un processo deve essere inseriti prima degli altri per l&quot;accesso al processore. Inoltre, è possibile impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>per aumentare temporaneamente il livello di priorità di thread che sono stati eseguiti dallo stato di attesa.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> La priorità viene reimpostata quando il processo ritorna allo stato di attesa.       Il <xref:System.Diagnostics.Process.BasePriority%2A>proprietà consente di visualizzare la priorità iniziale viene assegnata a un processo.</xref:System.Diagnostics.Process.BasePriority%2A> Tuttavia, poiché è di sola lettura, è possibile utilizzare il <xref:System.Diagnostics.Process.BasePriority%2A>proprietà per impostare la priorità di un processo.</xref:System.Diagnostics.Process.BasePriority%2A> Per modificare la priorità, utilizzare la proprietà PriorityClass, che ottiene o imposta la categoria di priorità globale per il processo.       La classe di priorità non può essere visualizzata utilizzando Monitor di sistema. Nella tabella seguente viene illustrata la relazione tra il <xref:System.Diagnostics.Process.BasePriority%2A>e valori PriorityClass.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | Classe di priorità |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "La categoria di priorità per il processo associato, da cui il <xref:System.Diagnostics.Process.BasePriority*>del processo viene calcolata.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile impostare o recuperare dalla risorsa di processo associato informazioni priorità processo.       - oppure - l&quot;identificatore di processo o l&quot;handle del processo è zero. (Non è stato avviato il processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà di classe di priorità per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non è disponibile.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La classe di priorità è impostato su <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> quando si usa Windows 98 o Windows Millennium Edition (Windows Me). Queste piattaforme non supportano tali valori per la classe di priorità."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Classe di priorità non può essere impostata perché utilizza un valore valido, come definito nel <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> enumerazione."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria privata, in byte, allocata per il processo associato."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "Il numero di byte allocati dal processo associato che non può essere condivisa con altri processi."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria privata, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria utilizzata dal processo, in byte, che non può essere condivisa con altri processi.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte privati** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria, in byte, allocata per il processo associato che non può essere condivisa con altri processi."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il tempo privilegiato del processore per questo processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Oggetto <xref:System.TimeSpan>che indica la quantità di tempo impiegato dal processore nell&quot;eseguire il codice all&quot;interno del sistema operativo.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà PrivilegedProcessorTime per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il nome del processo."
  remarks: "La proprietà ProcessName contiene un nome di file eseguibile, ad esempio Outlook, che non include l&quot;estensione .exe o il percorso. È utile per ottenere e modificare tutti i processi che sono associati con lo stesso file eseguibile.      > [!NOTE] > Su [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] sistemi operativi, la proprietà ProcessName potrebbe essere troncata a 15 caratteri se non è possibile ottenere le informazioni sul modulo di processo.       È possibile chiamare <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando un nome di file eseguibile, per recuperare una matrice che contiene tutte le istanze in esecuzione nel computer specificato.</xref:System.Diagnostics.Process.GetProcessesByName%2A> È possibile utilizzare questa matrice, ad esempio, per arrestare tutte le istanze in esecuzione del file eseguibile."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "Il nome che verrà utilizzato per identificare il processo per l&quot;utente."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non dispone di un identificatore o nessun processo è associato il <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - oppure - è stato terminato il processo associato."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il processo non è presente nel computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta i processori in cui il thread di questo processo può essere pianificato per l&quot;esecuzione."
  remarks: "In Windows 2000 e versioni successive, un thread in un processo può eseguire la migrazione da un processore, con ogni migrazione il ricaricamento di cache del processore. Carichi pesanti sistema, specificando il processore in cui deve essere eseguito un thread specifico può migliorare le prestazioni riducendo il numero di volte in cui che la cache del processore viene ricaricata più volte. L&quot;associazione tra un processore e un thread viene chiamato l&quot;affinità del processore.       Ogni processore viene rappresentato sotto forma di bit. Bit 0 è il processore uno, il bit 1 è il processore due e così via. Se si imposta un bit sul valore 1, il processore corrispondente viene selezionato per l&quot;assegnazione di thread. Quando si imposta il valore ProcessorAffinity in zero, gli algoritmi di pianificazione del sistema operativo impostare l&quot;affinità del thread. Quando il valore ProcessorAffinity è impostato su qualsiasi valore diverso da zero, il valore viene interpretato come maschera di bit che specifica i processori sono selezionabili.       La tabella seguente illustra una selezione di valori ProcessorAffinity per un sistema con otto processori.      | Maschera di bit | Valore binario | Processori idonei |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 e 2 |   | 0x0007 | 00000000 00000111 | 1, 2 e 3 |   | 0x0009 | 00000000 00001001 | 1 e 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 e 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "Maschera di bit che rappresenta i processori quali è possono eseguire i thread nel processo associato. Il valore predefinito dipende dal numero di processori nel computer. Il valore predefinito è 2 <sup>n</sup> -1, dove n è il numero di processori."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Impossibile impostare o recuperare dalla risorsa di processo associato ProcessorAffinity informazioni.       - oppure - l&quot;identificatore di processo o l&quot;handle del processo è zero. (Non è stato avviato il processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà ProcessorAffinity per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo <xref:System.Diagnostics.Process.Id*>non era disponibile.</xref:System.Diagnostics.Process.Id*>       - oppure - il processo è terminato."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Elimina le informazioni relative al processo associato memorizzate nella cache all&quot;interno del componente del processo."
  remarks: "Dopo la chiamata di aggiornamento, la prima richiesta per informazioni su ciascuna proprietà fa sì che il componente del processo ottenere un nuovo valore dal processo associato.       Quando un <xref:System.Diagnostics.Process>è associato a una risorsa di processo, i valori delle proprietà del componente di <xref:System.Diagnostics.Process>immediatamente vengono popolati in base allo stato del processo associato.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Se le informazioni relative al processo associato viene successivamente modificato, tali modifiche non vengono riflesse nel <xref:System.Diagnostics.Process>valori memorizzati nella cache del componente.</xref:System.Diagnostics.Process> Il <xref:System.Diagnostics.Process>componente è uno snapshot della risorsa di processo al momento sono associate.</xref:System.Diagnostics.Process> Per visualizzare i valori correnti per il processo associato, chiamare il metodo di aggiornamento."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un valore che indica se l&quot;interfaccia utente del processo sta rispondendo."
  remarks: "Se un processo con un&quot;interfaccia utente, la proprietà Responding contatta l&quot;interfaccia utente per determinare se il processo risponde all&quot;input dell&quot;utente. Se l&quot;interfaccia non risponde immediatamente, la proprietà restituisce risposta `false`. Utilizzare questa proprietà per determinare se l&quot;interfaccia del processo associato ha smesso di rispondere.       Se il processo non dispone di un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, questa proprietà restituisce `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se l&quot;interfaccia utente del processo associato sta rispondendo al sistema; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà di risposta per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;handle nativo di questo processo."
  remarks: "L&quot;handle è disponibile solo se il componente chiamante ha avviato il processo."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "L&quot;handle nativo di questo processo."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;identificatore di sessione Servizi Terminal per il processo associato."
  remarks: "La proprietà SessionId identifica la sessione in cui è attualmente in esecuzione l&quot;applicazione."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "Identificatore di sessione Servizi Terminal per il processo associato."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Non c&quot;è alcuna sessione associata a questo processo."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "È presente alcun processo associato a questo identificatore di sessione.       - oppure - il processo associato non è presente nel computer."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La proprietà SessionId non è supportata in Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un flusso usato per leggere l&quot;output di errore dell&quot;applicazione."
  remarks: "Quando un <xref:System.Diagnostics.Process>scrive il testo nel proprio flusso di errore standard, che è in genere visualizzato nella console.</xref:System.Diagnostics.Process> Reindirizzando il flusso StandardError, è possibile modificare o eliminare l&quot;output di errore di un processo. Ad esempio, è possibile filtrare il testo, formattarlo in modo diverso o scrivere l&quot;output sia nella console e un determinato file di log.      > [!NOTE] > Per utilizzare StandardError, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>a `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> In caso contrario, la lettura dal flusso StandardError genera un&quot;eccezione.       In modo sincrono o asincrono, è possibile leggere il flusso StandardError reindirizzato. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>eseguire le operazioni di lettura sincrona nel flusso di output di errore del processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Questi sincrono letti operazioni non vengono completate fino a quando l&quot;oggetto associato <xref:System.Diagnostics.Process>scrive nel proprio flusso StandardError o chiude il flusso.</xref:System.Diagnostics.Process>       Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Inizia asincrona operazioni di lettura nel flusso StandardError.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Questo metodo consente a un gestore eventi designato per l&quot;output del flusso e viene restituito immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l&quot;output di flusso viene indirizzato al gestore dell&quot;evento.       Operazioni di lettura sincrona introducono una dipendenza tra il chiamante durante la lettura dal flusso StandardError e il processo figlio che scrive in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso reindirizzato di un processo figlio, è dipendente dal figlio. Il chiamante attende l&quot;operazione di lettura fino a quando l&quot;elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzato, è dipende dal padre. Il processo figlio attende durante la successiva operazione di scrittura padre legge dal flusso completo o chiude il flusso. La condizione di deadlock si verifica quando il chiamante e il processo figlio di reciproca per completare un&quot;operazione di attesa e non può proseguire. Per evitare deadlock, è possibile valutare le dipendenze tra il chiamante e il processo figlio.       Il codice c# seguente, ad esempio, viene illustrato come leggere da un flusso reindirizzato e attendere l&quot;uscita del processo figlio.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```L&quot;esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardError.ReadToEnd` prima `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il flusso reindirizzato. Il processo padre rimarrebbe indefinitamente in attesa per l&quot;uscita del processo figlio. Il processo figlio rimarrebbe indefinitamente in attesa per l&quot;elemento padre per la lettura dal flusso StandardError completo.       Si verifica un problema simile durante la lettura di tutto il testo di output standard e flussi di errore standard. Il codice c# seguente, ad esempio, esegue un&quot;operazione di lettura su entrambi i flussi.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```L&quot;esempio di codice consente di evitare la condizione di deadlock mediante l&quot;esecuzione asincrona di operazioni di lettura di <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> Risultati di una condizione di deadlock se il processo padre chiama `p.StandardOutput.ReadToEnd` seguito da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il relativo flusso di errore. Il processo padre rimarrebbe indefinitamente in attesa per il processo figlio chiudere la <xref:System.Diagnostics.Process.StandardOutput%2A>flusso.</xref:System.Diagnostics.Process.StandardOutput%2A> Il processo figlio rimarrebbe indefinitamente in attesa per l&quot;elemento padre per la lettura dal flusso StandardError completo.       Per evitare queste dipendenze e i potenziali deadlock, è possibile utilizzare le operazioni di lettura asincrone. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggendo l&quot;output di ogni flusso in un thread separato.      > [!NOTE] > Non è possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A>nel flusso StandardError o viceversa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A>per il flusso StandardError.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "Oggetto <xref:System.IO.StreamReader>che può essere utilizzato per leggere il flusso di errore standard dell&quot;applicazione.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un flusso usato per scrivere l&quot;input dell&quot;applicazione."
  remarks: "Oggetto <xref:System.Diagnostics.Process>può leggere il testo di input dal flusso di input standard, in genere la tastiera.</xref:System.Diagnostics.Process> Reindirizzando il flusso StandardInput, è possibile specificare a livello di codice l&quot;input. Anziché utilizzare l&quot;input da tastiera, ad esempio, è possibile fornire il testo dal contenuto di un file specificato o output da un&quot;altra applicazione.      > [!NOTE] > Per utilizzare StandardInput, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>a `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> In caso contrario, la scrittura di StandardInput genera un&quot;eccezione in flusso."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "Oggetto <xref:System.IO.StreamWriter>che può essere utilizzato per scrivere il flusso di input standard dell&quot;applicazione.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il flusso StandardInput non è stato definito perché &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; è impostato su <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene un flusso usato per leggere l&quot;output dell&quot;applicazione."
  remarks: "Quando un <xref:System.Diagnostics.Process>scrive il testo nel proprio flusso standard, che è in genere visualizzato nella console.</xref:System.Diagnostics.Process> Reindirizzando il flusso StandardOutput, è possibile modificare o eliminare l&quot;output di un processo. Ad esempio, è possibile filtrare il testo, formattarlo in modo diverso o scrivere l&quot;output sia nella console e un determinato file di log.      > [!NOTE] > Per utilizzare StandardOutput, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>a `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> In caso contrario, la lettura dal flusso StandardOutput genera un&quot;eccezione.       In modo sincrono o asincrono, è possibile leggere il flusso StandardOutput reindirizzato. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>eseguire le operazioni di lettura sincrona nel flusso di output del processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Questi sincrono letti operazioni non vengono completate fino a quando l&quot;oggetto associato <xref:System.Diagnostics.Process>scrive nel proprio flusso StandardOutput o chiude il flusso.</xref:System.Diagnostics.Process>       Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Inizia asincrona operazioni di lettura nel flusso StandardOutput.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Questo metodo consente a un gestore eventi designato per l&quot;output del flusso e viene restituito immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l&quot;output di flusso viene indirizzato al gestore dell&quot;evento.       Operazioni di lettura sincrona introducono una dipendenza tra il chiamante durante la lettura dal flusso StandardOutput e il processo figlio che scrive in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso reindirizzato di un processo figlio, è dipendente dal figlio. Il chiamante attende l&quot;operazione di lettura fino a quando l&quot;elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzato, è dipende dal padre. Il processo figlio attende durante la successiva operazione di scrittura padre legge dal flusso completo o chiude il flusso. La condizione di deadlock si verifica quando il chiamante e il processo figlio di reciproca per completare un&quot;operazione di attesa e non può proseguire. Per evitare deadlock, è possibile valutare le dipendenze tra il chiamante e il processo figlio.       Il codice c# seguente, ad esempio, viene illustrato come leggere da un flusso reindirizzato e attendere l&quot;uscita del processo figlio.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```L&quot;esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardOutput.ReadToEnd` prima `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima `p.StandardOutput.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il flusso reindirizzato. Il processo padre rimarrebbe indefinitamente in attesa per l&quot;uscita del processo figlio. Il processo figlio rimarrebbe indefinitamente in attesa per l&quot;elemento padre per la lettura dal flusso StandardOutput completo.       Si verifica un problema simile durante la lettura di tutto il testo di output standard e flussi di errore standard. Il codice c# seguente, ad esempio, esegue un&quot;operazione di lettura su entrambi i flussi.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```L&quot;esempio di codice consente di evitare la condizione di deadlock eseguendo le operazioni di lettura asincrona sul flusso StandardOutput. Risultati di una condizione di deadlock se il processo padre chiama `p.StandardOutput.ReadToEnd` seguito da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il relativo flusso di errore. Il processo padre rimarrebbe indefinitamente in attesa per il processo figlio chiudere il flusso StandardOutput. Il processo figlio rimarrebbe indefinitamente in attesa per l&quot;elemento padre da cui leggere la versione completa <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Per evitare queste dipendenze e i potenziali deadlock, è possibile utilizzare le operazioni di lettura asincrone. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggendo l&quot;output di ogni flusso in un thread separato.      > [!NOTE] > Non è possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un&quot; <xref:System.Diagnostics.Process>viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità.</xref:System.Diagnostics.Process> Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A>sul flusso StandardOutput o viceversa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A>per il <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "Oggetto <xref:System.IO.StreamReader>che può essere utilizzato per leggere il flusso di output standard dell&quot;applicazione.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia (o riutilizza) la risorsa di processo specificato dal <xref:System.Diagnostics.Process.StartInfo*>della proprietà di questa <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e lo associa al componente.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se una risorsa di processo è stata avviata. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo nuova (ad esempio, se è stato riutilizzato un processo esistente)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Cui è stato specificato alcun nome file di <xref href=&quot;System.Diagnostics.Process&quot;> </xref> del componente <> </> *>.       - o - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; appartenente il <> </> *> proprietà <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> mentre &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, o &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore nell&quot;apertura del file associato."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia la risorsa di processo specificato dal parametro contenente le informazioni di avvio del processo (ad esempio, il nome di file del processo da avviare) e associa la risorsa a un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "Il <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> che contiene le informazioni che viene utilizzate per avviare il processo, inclusi il nome del file e gli eventuali argomenti della riga di comando."
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> associato alla risorsa di processo o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, avvio può restituire un processo non null con il relativo <xref:System.Diagnostics.Process.HasExited*>proprietà già impostata su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In questo caso, il processo avviato può avere attivato un&quot;istanza esistente di se stesso e quindi sia terminato."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Cui è stato specificato alcun nome file di <code> startInfo </code> del parametro <> </> *> proprietà.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - o - <> </> *> proprietà del <code> startInfo </code> parametro <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> e <> </> *> proprietà non è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> o vuoto o <> </> *> proprietà non è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Il file specificato nella <code> startInfo </code> del parametro <xref:System.Diagnostics.ProcessStartInfo.FileName*>proprietà non è stata trovata.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;apertura del file associato.       - oppure - la somma della lunghezza degli argomenti e la lunghezza del percorso completo per il processo supera 2080. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: &quot;l&quot;area dati passata a una chiamata di sistema è troppo piccola.&quot; oppure &quot;Accesso negato&quot;."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia una risorsa di processo specificando il nome di un file di documento o dell&quot;applicazione e associa la risorsa a un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Il nome di un file di documento o l&quot;applicazione da eseguire nel processo."
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> associato alla risorsa di processo o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, avvio può restituire un processo non null con il relativo <xref:System.Diagnostics.Process.HasExited*>proprietà già impostata su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In questo caso, il processo avviato può avere attivato un&quot;istanza esistente di se stesso e quindi sia terminato."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;apertura del file associato."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Variabile di ambiente PATH include una stringa che contiene virgolette."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia una risorsa di processo specificando il nome di un&quot;applicazione e un set di argomenti della riga di comando e associa la risorsa a un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Il nome di un file di applicazione per l&quot;esecuzione del processo."
    - id: arguments
      type: System.String
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> associato alla risorsa di processo o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, avvio può restituire un processo non null con il relativo <xref:System.Diagnostics.Process.HasExited*>proprietà già impostata su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In questo caso, il processo avviato può avere attivato un&quot;istanza esistente di se stesso e quindi sia terminato."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;apertura del file associato.       - oppure - la somma della lunghezza degli argomenti e la lunghezza del percorso completo per il processo supera 2080. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: &quot;l&quot;area dati passata a una chiamata di sistema è troppo piccola.&quot; oppure &quot;Accesso negato&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Variabile di ambiente PATH include una stringa che contiene virgolette."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia una risorsa di processo specificando il nome di un&quot;applicazione, un nome utente, una password e un dominio e associa la risorsa a un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).      > [!NOTE] > Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete mediante un identificatore uniform resource identifier (URI), non una lettera di unità collegate.      > [!NOTE] > Se l&quot;indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.       Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process>istanza.</xref:System.Diagnostics.Process> L&quot;overload costituisce un&quot;alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process>istanza, l&quot;impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A>proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A>per il <xref:System.Diagnostics.Process>istanza.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l&quot;estensione .exe, l&quot;estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro &quot;Notepad.exe&quot; o &quot;Notepad&quot;. Se il `fileName` parametro rappresenta un file eseguibile, la `arguments` parametro potrebbe rappresentare un file per eseguire un&quot;azione, ad esempio file di testo in `Notepad.exe myfile.txt`.      > [!NOTE] > Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A>gli overload che hanno `userName`, `password`, e `domain` parametri.</xref:System.Diagnostics.Process.Start%2A>       Quando si utilizza <xref:System.Diagnostics.Process.Start%2A>per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema.</xref:System.Diagnostics.Process.Start%2A> Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A>o <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> È possibile verificare se un processo è già stato chiuso mediante la <xref:System.Diagnostics.Process.HasExited%2A>proprietà...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Il nome di un file di applicazione per l&quot;esecuzione del processo."
    - id: userName
      type: System.String
      description: "Il nome utente da usare all&quot;avvio del processo."
    - id: password
      type: System.Security.SecureString
      description: "Oggetto <xref href=&quot;System.Security.SecureString&quot;> </xref> che contiene la password da usare all&quot;avvio del processo."
    - id: domain
      type: System.String
      description: "Il dominio da usare all&quot;avvio del processo."
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> associato alla risorsa di processo o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, avvio può restituire un processo non null con il relativo <xref:System.Diagnostics.Process.HasExited*>proprietà già impostata su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In questo caso, il processo avviato può avere attivato un&quot;istanza esistente di se stesso e quindi sia terminato."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "È stato specificato alcun nome file."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore nell&quot;apertura del file associato."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avvia una risorsa di processo specificando il nome di un&quot;applicazione, un set di argomenti della riga di comando, un nome utente, una password e un dominio e associa la risorsa a un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, gli argomenti della riga di comando, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).      > [!NOTE] > Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete mediante un identificatore uniform resource identifier (URI), non una lettera di unità collegate.      > [!NOTE] > Se l&quot;indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.       Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process>istanza.</xref:System.Diagnostics.Process> L&quot;overload costituisce un&quot;alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process>istanza, l&quot;impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A>proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A>per il <xref:System.Diagnostics.Process>istanza.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l&quot;estensione .exe, l&quot;estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro &quot;Notepad.exe&quot; o &quot;Notepad&quot;. Se il `fileName` parametro rappresenta un file eseguibile, la `arguments` parametro potrebbe rappresentare un file per eseguire un&quot;azione, ad esempio file di testo in `Notepad.exe myfile.txt`.      > [!NOTE] > Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A>gli overload che hanno `userName`, `password`, e `domain` parametri.</xref:System.Diagnostics.Process.Start%2A>       Quando si utilizza <xref:System.Diagnostics.Process.Start%2A>per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema.</xref:System.Diagnostics.Process.Start%2A> Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A>o <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> È possibile verificare se un processo è già stato chiuso mediante la <xref:System.Diagnostics.Process.HasExited%2A>proprietà...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Il nome di un file di applicazione per l&quot;esecuzione del processo."
    - id: arguments
      type: System.String
      description: "Argomenti della riga di comando da passare all&quot;avvio del processo."
    - id: userName
      type: System.String
      description: "Il nome utente da usare all&quot;avvio del processo."
    - id: password
      type: System.Security.SecureString
      description: "Oggetto <xref href=&quot;System.Security.SecureString&quot;> </xref> che contiene la password da usare all&quot;avvio del processo."
    - id: domain
      type: System.String
      description: "Il dominio da usare all&quot;avvio del processo."
    return:
      type: System.Diagnostics.Process
      description: "Un nuovo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> associato alla risorsa di processo o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, avvio può restituire un processo non null con il relativo <xref:System.Diagnostics.Process.HasExited*>proprietà già impostata su <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In questo caso, il processo avviato può avere attivato un&quot;istanza esistente di se stesso e quindi sia terminato."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "È stato specificato alcun nome file."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore durante l&quot;apertura del file associato.       - oppure - la somma della lunghezza degli argomenti e la lunghezza del percorso completo al file associato supera 2080. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: &quot;l&quot;area dati passata a una chiamata di sistema è troppo piccola.&quot; oppure &quot;Accesso negato&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "L&quot;oggetto processo è già stato eliminato."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta le proprietà da passare per il <xref:System.Diagnostics.Process.Start*>metodo il <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo rappresenta il set di parametri da utilizzare per avviare un processo. Quando <xref:System.Diagnostics.Process.Start%2A>viene chiamato, il StartInfo viene utilizzato per specificare l&quot;avvio del processo.</xref:System.Diagnostics.Process.Start%2A> Il membro StartInfo solo necessario impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Avvio di un processo specificando il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà è simile a digitare le informazioni contenute nel **eseguire** delle finestre di dialogo **avviare** menu.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Pertanto, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà non ha bisogno rappresentare un file eseguibile.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Può trattarsi di qualsiasi tipo di file per cui l&quot;estensione è stata associata a un&quot;applicazione installata nel sistema. Ad esempio il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>possono avere estensione txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un file con estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l&quot;estensione .exe, l&quot;estensione .exe è facoltativa nel <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà su &quot;Notepad.exe&quot; o &quot;Notepad&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       È possibile avviare un&quot;applicazione ClickOnce impostando il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà al percorso (ad esempio, un indirizzo Web) da cui è stato installato l&quot;applicazione.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Avviare un&quot;applicazione ClickOnce specificandone il percorso di installazione sul disco rigido.       Se il nome del file comporta un file non eseguibile, ad esempio un file con estensione doc, è possibile includere un verbo per specificare l&quot;azione da eseguire sul file. Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>a &quot;Print&quot; per un file con estensione doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Il nome del file specificato nella <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà non è necessario avere un&quot;estensione se si immette manualmente un valore per il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>proprietà.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Tuttavia, se si utilizza il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>proprietà per determinare i verbi disponibili, è necessario includere l&quot;estensione.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       È possibile modificare i parametri specificati nella proprietà StartInfo fino al momento della chiamata di <xref:System.Diagnostics.Process.Start%2A>metodo del processo.</xref:System.Diagnostics.Process.Start%2A> Dopo avere avviato il processo, la modifica dei valori StartInfo non influisce o riavviare il processo associato. Se si chiama il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>metodo con il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>set di proprietà, non gestito `CreateProcessWithLogonW` funzione viene chiamata, che avvia il processo di una nuova finestra, anche se il <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>valore della proprietà è `true` o il <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>valore della proprietà è <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Se si utilizza il <xref:System.Diagnostics.Process.Start%2A>metodo per avviare un processo, la proprietà StartInfo non riflette i parametri utilizzati per avviare il processo.</xref:System.Diagnostics.Process.Start%2A> Ad esempio, se si utilizza <xref:System.Diagnostics.Process.GetProcesses%2A>per ottenere una matrice di processi in esecuzione nel computer, la proprietà StartInfo <xref:System.Diagnostics.Process>non contiene il nome file originale o gli argomenti utilizzati per avviare il processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Quando viene avviato il processo, il nome del file è il file che compila (sola lettura) <xref:System.Diagnostics.Process.MainModule%2A>proprietà.</xref:System.Diagnostics.Process.MainModule%2A> Se si desidera recuperare il file eseguibile che viene associato al processo dopo l&quot;avvio del processo, utilizzare il <xref:System.Diagnostics.Process.MainModule%2A>proprietà.</xref:System.Diagnostics.Process.MainModule%2A> Se si desidera impostare il file eseguibile di un <xref:System.Diagnostics.Process>dell&quot;istanza per cui non è stato avviato un processo associato, utilizzare la proprietà di StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Poiché i membri della proprietà StartInfo sono argomenti passati al <xref:System.Diagnostics.Process.Start%2A>metodo di un processo, la modifica di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>proprietà dopo l&quot;avvio del processo associato non verrà reimpostato il <xref:System.Diagnostics.Process.MainModule%2A>proprietà.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Queste proprietà vengono utilizzate solo per inizializzare il processo associato."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "Il <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> che rappresenta i dati con cui avviare il processo. Questi argomenti includono il nome del file eseguibile o il documento usato per avviare il processo."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Il valore che specifica il StartInfo è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;ora in cui è stato avviato il processo associato."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Oggetto che indica quando il processo avviato. Se il processo non è in esecuzione, viene generata un&quot;eccezione."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà StartTime per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo è terminato.       - oppure - non è stato avviato il processo."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Si è verificato un errore nella chiamata alla funzione di Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene o imposta l&quot;oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate in seguito a un evento di terminazione del processo."
  remarks: "Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>è `null`, metodi che gestiscono il <xref:System.Diagnostics.Process.Exited>eventi vengono chiamati su un thread dal pool di thread del sistema.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Per ulteriori informazioni sui pool di thread del sistema, vedere <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando il <xref:System.Diagnostics.Process.Exited>evento è gestito da un componente di Windows Form visivo, ad esempio un <xref:System.Windows.Forms.Button>, accesso al componente tramite il pool di thread di sistema potrebbero non funzionare o generare un&quot;eccezione.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Evitare questa situazione impostando SynchronizingObject per un componente di Windows Form, che chiama i metodi che gestiscono il <xref:System.Diagnostics.Process.Exited>sullo stesso thread in cui il componente è stato creato l&quot;evento.</xref:System.Diagnostics.Process.Exited>       Se il <xref:System.Diagnostics.Process>viene utilizzata all&quot;interno [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] in una finestra di progettazione Windows Form, SynchronizingObject viene impostata automaticamente al controllo che contiene il <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Ad esempio, se si inserisce un <xref:System.Diagnostics.Process>in una finestra di progettazione per `Form1` (che eredita da <xref:System.Windows.Forms.Form>) la proprietà SynchronizingObject di <xref:System.Diagnostics.Process>è impostato per l&quot;istanza di `Form1`: [!code-cpp [Process_SynchronizingObject n.&2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject n.&2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject n.&2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] in genere, questa proprietà viene impostata quando il componente si trova all&quot;interno di un controllo o un form, perché tali componenti sono associati a un thread specifico.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "Il <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> usato per effettuare il marshalling delle chiamate del gestore eventi generate come risultato di un <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> evento del processo."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il set di thread in esecuzione nel processo associato."
  remarks: "Un thread esegue codice in un processo. Ogni processo viene avviato con un singolo thread, il thread principale. Qualsiasi thread può creare thread aggiuntivi. Thread all&quot;interno di un processo di condividere lo spazio degli indirizzi del processo.       Utilizzare <xref:System.Diagnostics.ProcessThread>per ottenere tutti i thread associati al processo corrente.</xref:System.Diagnostics.ProcessThread> Il thread principale non necessariamente in corrispondenza dell&quot;indice zero nella matrice."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Matrice di tipo <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> che rappresenta il sistema operativo thread attualmente in esecuzione nel processo associato."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Il processo non dispone di un <xref:System.Diagnostics.Process.Id*>, o nessun processo è associato il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> istanza.</xref:System.Diagnostics.Process.Id*>       - oppure - è stato terminato il processo associato."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> accedere a questa proprietà in Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formatta il nome del processo come stringa, combinata al tipo di componente padre, se disponibile."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Il <> </> *> combinato con il componente di base <> </> *> valore restituito."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString non è supportato in Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il tempo totale processore per questo processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Oggetto <xref:System.TimeSpan>che indica la quantità di tempo impiegato dal processo associato nell&quot;utilizzo della CPU.</xref:System.TimeSpan> Questo valore è la somma di <> </> *> e <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà TotalProcessorTime per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene il tempo utente del processore per questo processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Oggetto <xref:System.TimeSpan>che indica la quantità di tempo impiegato dal processo associato nell&quot;esecuzione del codice all&quot;interno della parte di applicazione del processo (non all&quot;interno del nucleo centrale del sistema operativo).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Si sta tentando di accedere alla proprietà UserProcessorTime per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene le dimensioni della memoria virtuale del processo, in byte."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "La quantità di memoria virtuale, in byte, che il processo associato ha richiesto."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria virtuale, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria virtuale usata dal processo, in byte. Il sistema operativo esegue il mapping di spazio degli indirizzi virtuali per ogni processo alle pagine caricate nella memoria fisica, o per le pagine memorizzate nel file di paging della memoria virtuale su disco.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte virtuali** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria virtuale, in byte, allocata per il processo associato."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Indica il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente per attendere in modo indefinito la terminazione del processo associato."
  remarks: "WaitForExit rende il thread corrente di attendere che il processo associato venga terminato.  Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, utilizzare il <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited>       Questo metodo indica il <xref:System.Diagnostics.Process>componente attenderà un&quot;infinito quantità di tempo per i processo e gestori eventi uscire dall&quot;installazione.</xref:System.Diagnostics.Process> In questo modo un&quot;applicazione di rispondere. Ad esempio, se si chiama <xref:System.Diagnostics.Process.CloseMainWindow%2A>per un processo che dispone di un&quot;interfaccia utente, la richiesta al sistema operativo per terminare il processo associato potrebbe non essere gestita se il processo viene scritto il ciclo di messaggi non digitano mai.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > Nel [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versioni precedenti, in attesa per l&quot;overload WaitForExit <xref:System.Int32.MaxValue>millisecondi (circa 24 giorni), non per un periodo illimitato.</xref:System.Int32.MaxValue> Inoltre, le versioni precedenti non si attende che i gestori eventi per l&quot;uscita se la versione completa <xref:System.Int32.MaxValue>ora è stato raggiunto.</xref:System.Int32.MaxValue>       Questo overload assicura che l&quot;elaborazione è stata completata, inclusa la gestione degli eventi asincroni per l&quot;output standard reindirizzato. È necessario utilizzare questo overload dopo una chiamata al <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>overload quando l&quot;output standard è stato reindirizzato ai gestori eventi asincroni.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Quando un processo associato viene terminato (ovvero, quando viene chiuso dal sistema operativo mediante terminazione normale o anomala), il sistema memorizza le informazioni amministrative sul processo e lo restituisce al componente che ha chiamato WaitForExit. Il <xref:System.Diagnostics.Process>componente può quindi accedere alle informazioni, che include il <xref:System.Diagnostics.Process.ExitTime%2A>, utilizzando il <xref:System.Diagnostics.Process.Handle%2A>al processo terminato.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A>proprietà del componente non punta a una risorsa di processo esistente.</xref:System.Diagnostics.Process.Handle%2A> Al contrario, l&quot;handle può essere utilizzato solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle a processi terminati che non sono stati rilasciati da <xref:System.Diagnostics.Process>componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informazioni in memoria finché il <xref:System.Diagnostics.Process>componente specificamente libera le risorse.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Per questo motivo, ogni volta che si chiama <xref:System.Diagnostics.Process.Start%2A>per un&quot; <xref:System.Diagnostics.Process>istanza, <xref:System.Diagnostics.Process.Close%2A>quando il processo associato è terminato e non è più necessario informazioni amministrative su tale</xref:System.Diagnostics.Process.Close%2A> chiamata</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>libera la memoria allocata al processo terminato.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "L&quot;impostazione di attesa non è accessibile."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nessun processo <> </> *> è stata impostata e un <> </> *> da cui il <xref:System.Diagnostics.Process.Id*>proprietà può essere determinata non esiste.</xref:System.Diagnostics.Process.Id*>       - oppure - nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto.       oppure si sta tentando di chiamare WaitForExit per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Indica il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente attenderà il numero specificato di millisecondi per il processo associato venga terminato."
  remarks: "WaitForExit rende il thread corrente di attendere che il processo associato venga terminato. Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, utilizzare il <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited>       Questo metodo indica il <xref:System.Diagnostics.Process>componente attenderà una quantità limitata di tempo per la terminazione del processo.</xref:System.Diagnostics.Process> Se il processo associato viene terminato entro la fine dell&quot;intervallo perché viene negata la richiesta di terminazione, `false` viene restituito alla routine chiamante. È possibile specificare un numero negativo (<xref:System.Threading.Timeout.Infinite>) per `milliseconds`, e WaitForExit si comporterà come il <xref:System.Diagnostics.Process.WaitForExit>rapporto di overload.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Se si passa 0 (zero) per il metodo, viene restituito `true` solo se il processo è già stato terminato; in caso contrario, viene immediatamente restituito `false`.      > [!NOTE] > Nel [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versioni precedenti, se `milliseconds` è -1, il WaitForExit overload in attesa per <xref:System.Int32.MaxValue>millisecondi (circa 24 giorni), non per un periodo illimitato.</xref:System.Int32.MaxValue>       Quando l&quot;output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l&quot;elaborazione di output non sia completata quando questo metodo viene restituito. Per garantire che la gestione degli eventi asincroni è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit>overload che non accetta alcun parametro dopo avere ricevuto un `true` da questo overload.</xref:System.Diagnostics.Process.WaitForExit> Per garantire che il <xref:System.Diagnostics.Process.Exited>evento viene gestito correttamente nelle applicazioni Windows Form, impostare il <xref:System.Diagnostics.Process.SynchronizingObject%2A>proprietà.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Quando un processo associato termina (viene chiuso dal sistema operativo mediante terminazione normale o anomala), il sistema memorizza le informazioni amministrative sul processo e restituisce al componente che ha chiamato WaitForExit. Il <xref:System.Diagnostics.Process>componente può quindi accedere alle informazioni, che include il <xref:System.Diagnostics.Process.ExitTime%2A>, utilizzando il <xref:System.Diagnostics.Process.Handle%2A>al processo terminato.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A>proprietà del componente non punta a una risorsa di processo esistente.</xref:System.Diagnostics.Process.Handle%2A> Al contrario, l&quot;handle può essere utilizzato solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle a processi terminati che non sono stati rilasciati da <xref:System.Diagnostics.Process>componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informazioni in memoria finché il <xref:System.Diagnostics.Process>componente specificamente libera le risorse.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Per questo motivo, ogni volta che si chiama <xref:System.Diagnostics.Process.Start%2A>per un&quot; <xref:System.Diagnostics.Process>istanza, <xref:System.Diagnostics.Process.Close%2A>quando il processo associato è terminato e non è più necessario informazioni amministrative su tale</xref:System.Diagnostics.Process.Close%2A> chiamata</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>libera la memoria allocata al processo terminato.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "La quantità di tempo, espresso in millisecondi di attesa per il processo associato venga terminato. Il valore massimo è il valore massimo possibile di un intero a 32 bit, che rappresenta l&quot;infinito per il sistema operativo."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il processo associato è stato terminato; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "L&quot;impostazione di attesa non è accessibile."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nessun processo <> </> *> è stata impostata e un <> </> *> da cui il <xref:System.Diagnostics.Process.Id*>proprietà può essere determinata non esiste.</xref:System.Diagnostics.Process.Id*>       - oppure - nessun processo è associato a questo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto.       oppure si sta tentando di chiamare WaitForExit per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente per un&quot;attesa indefinita per il processo associato entri in uno stato inattivo. Questo overload viene applicato solo ai processi dotati di un&quot;interfaccia utente e, pertanto, un ciclo di messaggi."
  remarks: "Usare WaitForInputIdle per forzare l&quot;elaborazione dell&quot;applicazione in attesa fino a quando non ha restituito il ciclo di messaggi di stato di inattività. Quando è in esecuzione un processo con un&quot;interfaccia utente, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Restituisce quindi il processo del ciclo di messaggi. Un processo è detto in uno stato di inattività quando è in attesa per i messaggi all&quot;interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l&quot;applicazione deve attendere che un processo completare la creazione corrispondente finestra principale prima che l&quot;applicazione comunica con tale finestra.       Se un processo non dispone di un ciclo di messaggi, WaitForInputIdle genera un <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       L&quot;overload di WaitForInputIdle indica il <xref:System.Diagnostics.Process>componente per un&quot;attesa indefinita per il processo diventi inattivo nel ciclo di messaggi.</xref:System.Diagnostics.Process> Questa istruzione può causare un&quot;applicazione di rispondere. Ad esempio, se il processo viene scritto per uscire dal ciclo di messaggi immediatamente, come illustrato nel frammento di codice `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il processo associato ha raggiunto uno stato di inattività."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non ha un&quot;interfaccia grafica.       oppure si è verificato un errore sconosciuto. Il processo non riuscito entri in uno stato inattivo.       - oppure - processo già terminato.       - oppure - non è associato alcun processo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina il <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente attenderà il numero specificato di millisecondi per il processo associato entri in uno stato inattivo. Questo overload viene applicato solo ai processi dotati di un&quot;interfaccia utente e, pertanto, un ciclo di messaggi."
  remarks: "Usare WaitForInputIdle per forzare l&quot;elaborazione dell&quot;applicazione in attesa fino a quando non ha restituito il ciclo di messaggi di stato di inattività. Quando è in esecuzione un processo con un&quot;interfaccia utente, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Restituisce quindi il processo del ciclo di messaggi. Un processo è detto in uno stato di inattività quando è in attesa per i messaggi all&quot;interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l&quot;applicazione deve attendere che un processo completare la creazione corrispondente finestra principale prima che l&quot;applicazione comunica con tale finestra.       Se un processo non dispone di un ciclo di messaggi, WaitForInputIdle genera un <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       L&quot;overload di WaitForInputIdle indica il <xref:System.Diagnostics.Process>componente attenderà una quantità limitata di tempo per il processo diventi inattivo nel ciclo di messaggi.</xref:System.Diagnostics.Process> Se il processo associato non è diventato inattivo entro la fine dell&quot;intervallo perché il ciclo sta ancora elaborando i messaggi, `false` viene restituito alla routine chiamante.       Per ulteriori informazioni sulla gestione degli eventi, vedere [eventi](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Un valore pari a 1 per <xref:System.Int32>che specifica la quantità di tempo, in millisecondi di attesa per il processo associato diventi inattivo.</xref:System.Int32> Il valore 0 specifica una restituzione immediata, e il valore-1 specifica un&quot;attesa infinita."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il processo associato ha raggiunto uno stato inattivo; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il processo non ha un&quot;interfaccia grafica.       oppure si è verificato un errore sconosciuto. Il processo non riuscito entri in uno stato inattivo.       - oppure - processo già terminato.       - oppure - non è associato alcun processo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> oggetto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene l&quot;utilizzo della memoria fisica del processo associato, in byte."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente del working set di memoria utilizzata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "La quantità di memoria fisica totale del processo associato è usata, in byte."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ottiene la quantità di memoria fisica, in byte, allocata per il processo associato."
  remarks: "Il valore restituito da questa proprietà rappresenta la dimensione corrente del working set di memoria utilizzata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un&quot;applicazione può utilizzare senza generare un errore di pagina.       Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni che il processo viene eseguito, incluse le istruzioni in moduli di processo e le librerie di sistema.       Questa proprietà può essere utilizzata per monitorare l&quot;utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **Working Set** contatore delle prestazioni per il processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "La quantità di memoria fisica, in byte, allocata per il processo associato."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
