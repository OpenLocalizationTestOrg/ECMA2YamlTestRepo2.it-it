### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "Il <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modulo contiene le procedure che consentono di eseguire operazioni su file, directory o cartella e del sistema. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funzionalità offre la produttività e prestazioni migliori nelle operazioni dei / o file rispetto all&quot;utilizzo di <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modulo. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Questo modulo supporta le parole chiave del linguaggio Visual Basic e membri di libreria run-time che accedono ai file e cartelle."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Modifica la directory corrente o una cartella. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file di <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>(funzione). Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "Il `ChDir` funzione consente di modificare la directory predefinita, ma non l&quot;unità predefinita. Ad esempio, se l&quot;unità predefinita è di tipo C, l&quot;istruzione seguente modifica la directory predefinita sull&quot;unità D, ma C rimane l&quot;unità predefinita: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] è possibile apportare relativo modifiche alla directory è necessario digitare due punti, come indicato di seguito: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > il `ChDir` funzione richiede l&quot;autorizzazione di accesso al codice non gestito, che può influenzare l&quot;esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission>e.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obbligatorio. Oggetto <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> espressione che identifica la directory o la cartella diventa la nuova directory predefinita o una cartella. `Path`può includere l&quot;unità. Se viene specificata alcuna unità, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> cambia la directory predefinita o una cartella nell&quot;unità corrente."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>è vuoto."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Viene specificata l&quot;unità non valida o unità non è disponibile."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Cambia l&quot;unità corrente."
  remarks: "Il `ChDrive` funzione richiede l&quot;autorizzazione di accesso al codice non gestito, che può influenzare l&quot;esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission>e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Obbligatorio. Espressione stringa che specifica un&quot;unità esistente. Se si specifica una stringa di lunghezza zero (&quot;&quot;), l&quot;unità corrente rimane invariato. Se il `Drive` argomento è una stringa di caratteri a più <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> utilizza solo la prima lettera."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Viene specificata l&quot;unità non valida o unità non è disponibile."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Cambia l&quot;unità corrente."
  remarks: "Il `ChDrive` funzione richiede l&quot;autorizzazione di accesso al codice non gestito, che può influenzare l&quot;esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission>e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Obbligatorio. Espressione stringa che specifica un&quot;unità esistente. Se si specifica una stringa di lunghezza zero (&quot;&quot;), l&quot;unità corrente rimane invariato. Se il `Drive` argomento è una stringa di caratteri a più <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> utilizza solo la prima lettera."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Viene specificata l&quot;unità non valida o unità non è disponibile."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce una stringa che rappresenta il percorso corrente. Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Stringa che rappresenta il percorso corrente."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce una stringa che rappresenta il percorso corrente. Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Facoltativa. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>espressione che specifica un&quot;unità esistente. Se viene specificata alcuna unità, o se `Drive` è una stringa di lunghezza zero (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> restituisce il percorso dell&quot;unità corrente."
    return:
      type: System.String
      description: "Stringa che rappresenta il percorso corrente."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce una stringa che rappresenta il nome di un file, una directory o una cartella che corrisponde a un modello specificato o un attributo di file o l&quot;etichetta di volume dell&quot;unità. Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto di <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> (funzione). Vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>Per ulteriori informazioni.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Il `Dir` funzione supporta l&quot;utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.       `VbVolume`Restituisce l&quot;etichetta di volume dell&quot;unità anziché un nome file specifico.       È necessario fornire un `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l&quot;elemento successivo, è possibile eseguire chiamate successive al `Dir` funzione senza parametri.      > [!IMPORTANT] > Per eseguire correttamente il `Dir` funzione richiede il <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>flag di <xref:System.Security.Permissions.FileIOPermission>per essere concesso al codice in esecuzione.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Il `Attributes` argomento valori di enumerazione sono i seguenti: | | |   |-|-|-|   | Valore | Costante | Descrizione |   | `Normal`|`vbnormal`| Per impostazione predefinita. Specifica i file senza attributi. |   | `ReadOnly`|`vbReadOnly`| Specifica i file di sola lettura e, inoltre, i file senza attributi. |   | `Hidden`|`vbHidden`| Specifica i file nascosti e anche i file senza attributi. |   | `System`|`vbSystem`| Specifica i file di sistema e file senza attributi. |   | `Volume`|`vbVolume`| Specifica l&quot;etichetta di volume. Se qualsiasi altro attributo viene specificato, `vbVolume` viene ignorato. |   | `Directory`|`vbDirectory`| Specifica una directory o cartelle e anche i file senza attributi. |   | `Archive`|`vbArchive`| File è stato modificato dall&quot;ultimo backup. |   | `Alias`|`vbAlias`| File con un nome diverso. |      > [!NOTE] > Queste enumerazioni vengono specificate il linguaggio Visual Basic e possono essere utilizzate ovunque nel codice anziché i valori effettivi."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Stringa che rappresenta il nome di un file, una directory o una cartella che corrisponde a un modello specificato o un attributo di file o l&quot;etichetta di volume dell&quot;unità."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce una stringa che rappresenta il nome di un file, una directory o una cartella che corrisponde a un modello specificato o un attributo di file o l&quot;etichetta di volume dell&quot;unità. Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto di <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> (funzione). Vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>Per ulteriori informazioni.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Il `Dir` funzione supporta l&quot;utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.       `VbVolume`Restituisce l&quot;etichetta di volume dell&quot;unità anziché un nome file specifico.       È necessario fornire un `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l&quot;elemento successivo, è possibile eseguire chiamate successive al `Dir` funzione senza parametri.      > [!IMPORTANT] > Per eseguire correttamente il `Dir` funzione richiede il <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>flag di <xref:System.Security.Permissions.FileIOPermission>per essere concesso al codice in esecuzione.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Il `Attributes` argomento valori di enumerazione sono i seguenti: | | |   |-|-|-|   | Valore | Costante | Descrizione |   | `Normal`|`vbnormal`| Per impostazione predefinita. Specifica i file senza attributi. |   | `ReadOnly`|`vbReadOnly`| Specifica i file di sola lettura, oltre ai file senza attributi. |   | `Hidden`|`vbHidden`| Specifica i file nascosti, oltre ai file senza attributi. |   | `System`|`vbSystem`| Specifica il file di sistema, oltre ai file senza attributi. |   | `Volume`|`vbVolume`| Specifica l&quot;etichetta di volume. Se qualsiasi altro attributo viene specificato, `vbVolume` viene ignorato. |   | `Directory`|`vbDirectory`| Specifica inoltre directory o cartelle, ai file senza attributi. |   | `Archive`|`vbArchive`| File è stato modificato dall&quot;ultimo backup. |   | `Alias`|`vbAlias`| File con un nome diverso. |      > [!NOTE] > Queste enumerazioni vengono specificate il linguaggio Visual Basic e possono essere utilizzate ovunque nel codice al posto dei valori effettivi."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Facoltativa. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un nome file, il nome di directory o una cartella o l&quot;etichetta di volume dell&quot;unità. Una stringa di lunghezza zero (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) viene restituito se `PathName` non viene trovato."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Facoltativa. Espressione numerica o di enumerazione il cui valore specifica attributi di file. Se omesso, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> restituisce file che corrispondono `PathName` non dispongono di attributi."
    return:
      type: System.String
      description: "Stringa che rappresenta il nome di un file, una directory o una cartella che corrisponde a un modello specificato o un attributo di file o l&quot;etichetta di volume dell&quot;unità."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un valore booleano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando la fine di un file aperto in <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> o sequenziali <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> è stato raggiunto."
  remarks: "Utilizzare `EOF` per evitare l&quot;errore generato dal tentativo di ottenere l&quot;input oltre la fine di un file.       Il `EOF` risultato della funzione `False` fino a quando non è stata raggiunta la fine del file. Con i file aperti per `Random` o `Binary` accesso, `EOF` restituisce `False` fino all&quot;ultima esecuzione `FileGet` funzione in grado di leggere un record completo.       Con i file aperti per `Binary` accedere, un tentativo di leggere il file utilizzando il `Input` funzione finché `EOF` restituisce `True` genera un errore. Utilizzare il `LOF` e `Loc` funzioni anziché `EOF` durante la lettura di file binari con `Input`, oppure utilizzare `Get` quando si utilizza il `EOF` (funzione). Con i file aperti per `Output`, `EOF` restituisce sempre `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> che contiene qualsiasi numero di file valido."
    return:
      type: System.Boolean
      description: "Restituisce un valore booleano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando la fine di un file aperto in <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> o sequenziali <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> è stato raggiunto."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un&quot;enumerazione che rappresenta la modalità di file per i file aperti mediante il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto di <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>(funzione). Vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>Per ulteriori informazioni.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Questa funzione restituisce un&quot;enumerazione che rappresenta la modalità di file per i file aperti mediante il `FileOpen` (funzione)."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Qualsiasi numero di file valido."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "I seguenti valori di enumerazione indicano la modalità di accesso ai file:       <table><tbody><tr><td> Valore       </td><td> Modalità       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Si conclude input/output (i/o) in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>offre la produttività e prestazioni migliori nelle operazioni dei / o file. Vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> per ulteriori informazioni."
  remarks: "Il `FileClose` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [come: Leggi testo da file con un oggetto StreamReader](~/add/includes/ajax-current-ext-md.md),[procedura: scrivere testo in file con un oggetto StreamWriter](~/add/includes/ajax-current-ext-md.md), e [procedura dettagliata: modifica dei file e directory in Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se si omette `FileNumbers`, tutti i file attivi aperti con la `FileOpen` funzione vengono chiusi.       Quando si chiudono i file che sono state aperte per `Output` o `Append`, il buffer finale dell&quot;output viene scritto nel buffer del sistema operativo per tale file. Tutti i buffer associato chiuso spazio file viene rilasciato.       Quando il `FileClose` funzione viene eseguita, l&quot;associazione di un file con il relativo file di numero."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Facoltativa. Matrice di parametri di 0 o più canali per essere chiuso."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Copia un file. Il <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> offre produttività e prestazioni migliori nelle operazioni dei / o rispetto <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>Per ulteriori informazioni.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Se si tenta di utilizzare il `FileCopy` funzione su un file attualmente aperto, si verifica un errore.       `FileCopy`richiede l&quot;attendibilità totale per funzionare nell&quot;unità locale."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica il nome del file da copiare. `Source`può includere la directory o la cartella e l&quot;unità del file di origine."
    - id: Destination
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica il nome del file di destinazione. `Destination`può includere la directory o la cartella e l&quot;unità del file di destinazione."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>o <code>Destination</code> non è valido o non specificato."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "File è già aperto."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "File non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> valore che indica la data e ora in cui è stato scritto un file. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un nome di file. `PathName`può includere la directory o una cartella e l&quot;unità."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>valore che indica la data e ora di un file è stato creato o dell&quot;ultima modifica."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>non è valido o contiene caratteri jolly."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "File di destinazione non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Boolean
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Byte
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Char
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.DateTime
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Decimal
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Double
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int16
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int32
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int64
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Single
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.ValueType
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.String
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di due byte per la stringa che descrive la lunghezza. Il valore predefinito è <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Array
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere trattata come dinamica e se un descrittore della matrice che descrive le dimensioni e i limiti della matrice è necessario."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di due byte per la stringa che descrive la lunghezza. Il valore predefinito è <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file aperto su disco in una variabile.  Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Object
      description: "Obbligatorio. Nome di variabile valida in cui i dati vengono letti."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la lettura."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valore che specifica la lunghezza di un file in byte. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Se il file specificato è aperto quando il `FileLen` funzione viene chiamata, il valore restituito rappresenta le dimensioni del file al momento è stato aperto.      > [!NOTE] > Per ottenere la lunghezza corrente di un file aperto, usare il `LOF` (funzione)."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un file. `PathName`può includere la directory o una cartella e l&quot;unità."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>valore che specifica la lunghezza di un file in byte."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "File non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Apre un file di input o output. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `FileOpen` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       Prima di poter eseguire qualsiasi operazione dei / o su di esso, è necessario aprire un file. `FileOpen`Alloca un buffer dei / o al file e determina la modalità di accesso da utilizzare con il buffer.      > [!IMPORTANT] > Durante la scrittura in un file, un&quot;applicazione potrebbe essere necessario creare un file, se il file a cui sta tentando di scrivere non esiste. A tale scopo, sono necessarie le autorizzazioni per la directory in cui viene creato il file. Tuttavia, se il file specificato da `FileName` esiste, l&quot;applicazione deve `Write` autorizzazioni solo per il file stesso. Quando possibile, per migliorare la sicurezza, creare il file durante la distribuzione e concedere `Write` le autorizzazioni per tale file solo, anziché per l&quot;intera directory. Per migliorare la sicurezza, scrivere dati nella directory dell&quot;utente anziché nella directory radice o la directory dei file di programma.       Aprire il canale è reperibile tramite il `FreeFile()` (funzione).      > [!IMPORTANT] > Il `FileOpen` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione, che potrebbe influire sulla relativa esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido. Utilizzare il <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> funzione per ottenere il successivo numero di file disponibili."
    - id: FileName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un nome di file, potrebbe includere la directory o cartella e unità."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Obbligatorio. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Facoltativa. Enumerazione che specifica le operazioni consentite sul file aperto: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, o <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Per impostazione predefinita <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Facoltativa. Enumerazione che specifica le operazioni non consentite sul file aperto da altri processi: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, e <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Per impostazione predefinita <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Facoltativa. Numero minore o uguale a 32.767 (byte). Per i file aperti per l&quot;accesso casuale, questo valore è la lunghezza del record. Per i file sequenziali, questo valore è il numero di caratteri con memorizzazione nel buffer."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Lunghezza del record è negativo (e non è uguale a -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>è già aperto, o <code>FileName</code> non è valido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen`funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Boolean
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Byte
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Char
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.DateTime
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Decimal
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Double
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il`VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int16
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int32
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int64
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen`funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Single
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel`RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.ValueType
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Object
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Object
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.String
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePut` è in genere letti da un file mediante `FileGet`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l&quot;ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l&quot;ultima `Seek` funzione viene scritto.       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un&quot;eccezione.      -Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.      - `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.          > [!NOTE] > Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco, # # modalità binaria per i file aperti in `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità: - il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.      -Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.      - `FilePut` scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Ad esempio, le istruzioni seguenti scrivere 11 byte nel file numero 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] : scrittura in un file utilizzando il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Array
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere considerata dinamica e se scrivere un descrittore della matrice per la stringa che descrive la lunghezza."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Facoltativa. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; non è uguale a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive i dati da una variabile in un file su disco.  Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `FilePutObject` funzione viene utilizzata al posto di `FilePut` per evitare ambiguità in fase di compilazione se tipo `Object` invece viene passato un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.       `FilePutObject`scrive e legge i descrittori che descrivono l&quot;oggetto. Se si intende scrivere il `Variant` tipo `FilePutObject` è obbligatorio. In caso di dubbi, se si utilizza un oggetto per il secondo parametro, è consigliabile utilizzare sempre `FilePutObject` e `FileGetObject`.       `FilePutObject`è valido solo in `Random` e `Binary` modalità.       I dati scritti con `FilePutObject` è in genere letti da un file mediante `FileGetObject`.       Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, `FilePutObject` scrive un record o il byte successivo dopo l&quot;ultimo `FileGetObject` o `FilePutObject` funzione (o il record o byte a cui fa riferimento l&quot;ultima `Seek` funzione).       Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePutObject`Scrive il descrittore di lunghezza quando l&quot;argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePutObject`, è necessario eseguire la stessa operazione con `FileGetObject`, e assicurarsi che la stringa venga inizializzata alla lunghezza prevista.      ## Casuale modalità per i file aperti in `Random` modalità, le seguenti regole: - se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePutObject` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l&quot;inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, viene generata un&quot;eccezione.      -Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePutObject` scrive due byte che identificano il `VarType` dell&quot;oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePutObject` scrive sei byte: due byte che identificano l&quot;oggetto come `VarType(`3`)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.      -Se la variabile scritta è un oggetto che contiene una stringa, `FilePutObject` scriverà un descrittore di due byte che identifica il `VarType(`8`)` dell&quot;oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.      -Se la variabile scritta è una matrice, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions).      ## Binario modalità per i file aperti in `Binary` modalità, tutti il `Random` si applicano le regole della modalità, ad eccezione di: - il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePutObject`Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Object
      description: "Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco."
    - id: RecordNumber
      type: System.Int64
      description: "Facoltativa. Numero di record (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> file in modalità) o numero di byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> file in modalità) al quale inizia la scrittura."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Assegna la larghezza di riga di output in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione)."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: RecordWidth
      type: System.Int32
      description: "Obbligatorio. Espressione numerica nell&quot;intervallo da 0, 255, che indica il numero di caratteri visualizzati in una riga prima dell&quot;avvio di una nuova riga. Se `RecordWidth` è uguale a 0, non sono previsti limiti per la lunghezza di una riga. Il valore predefinito per `RecordWidth` è 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valore che rappresenta il numero di file successivo disponibile per il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione)."
  remarks: "Utilizzare `FreeFile` per fornire un numero di file che non è già in uso."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Restituisce un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valore che rappresenta il numero di file successivo disponibile per il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione)."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Più di 255 file sono in uso."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> valore che rappresenta gli attributi di un file, una directory o una cartella. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Per determinare quali attributi sono impostati, utilizzare il `And` operatore per eseguire un confronto bit per bit tra il valore restituito dal `GetAttr` funzione e il valore dell&quot;attributo di file desiderato. Se il risultato è diverso da zero, tale attributo è impostato per il file denominato. Ad esempio, il valore restituito i seguenti `And` espressione è zero se la `Archive` attributo non è impostato: ```vb#   Result = GetAttr(FName) And vbArchive   ``` viene restituito un valore diverso da zero se la `Archive` attributo è impostato."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un nome di file, directory o una cartella. `PathName`può includere la directory o una cartella e l&quot;unità."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "Il valore restituito da <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> è la somma dei valori di enumerazione seguente:       <table><tbody><tr><td> Valore       </td><td> Descrizione delle costanti       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normale.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Sola lettura.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Nascosto.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>File di sistema.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Directory o una cartella.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>File è stato modificato dall&quot;ultimo backup.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>File con un nome diverso.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Queste enumerazioni vengono specificate tramite il linguaggio Visual Basic. I nomi utilizzabile in qualsiasi punto nel codice al posto dei valori effettivi.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>non è valido o contiene caratteri jolly."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "File di destinazione non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Boolean
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Byte
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Char
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.DateTime
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Decimal
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Double
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int16
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int32
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Int64
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Object
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.Single
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge i dati da un file sequenziale aperto e assegna i dati variabili."
  remarks: "Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.       Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.      |||   |-|-|   | Dati | Valore assegnato alla variabile |   | Riga vuota o valori delimitati da virgole di delimitazione | Vuoto |   | NULL # #| `DBNull`|   | # TRUE o FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Data e/o dell&quot;ora rappresentate dall&quot;espressione |   |#ERROR `errornumber` #| `errornumber` (la variabile è un oggetto contrassegnato come errore) |       Se si raggiunge la fine del file durante l&quot;immissione di un elemento di dati, l&quot;input viene arrestato e si verifica un errore.      > [!NOTE] > Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.      > [!IMPORTANT] > La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Value
      type: System.String
      description: "Obbligatorio. Variabile che verrà assegnati i valori letti dal file, ovvero non può essere una variabile di matrice o un oggetto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valore che contiene i caratteri di un file aperto in <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modalità. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `InputString` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con il `InputString` funzione viene in genere scritti in un file mediante `Print` o `FilePut`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.       A differenza di `Input` funzione, il `InputString` funzione restituisce tutti i caratteri letti. Ciò include virgole, ritorni a capo, avanzamento riga, tra virgolette e gli spazi iniziali.       Con i file aperti per `Binary` accedere, un tentativo di leggere il file mediante il `InputString` funzione finché `EOF` restituisce `True` genera un errore. Utilizzare il `LOF` e `Loc` funzioni anziché `EOF` quando si legge i file binari in `InputString`, oppure utilizzare `FileGet` quando si utilizza il `EOF` (funzione).      > [!NOTE] > Durante la lettura da file, non prendere decisioni di protezione sul contenuto del file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non può essere un file di origine Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: CharCount
      type: System.Int32
      description: "Obbligatorio. Qualsiasi espressione numerica valida che specifica il numero di caratteri da leggere."
    return:
      type: System.String
      description: "Restituisce <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valore che contiene i caratteri di un file aperto in <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modalità. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>non esiste."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Elimina i file da un disco. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`supporta l&quot;utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.       **Nota sulla sicurezza** per eseguire, il `Kill` funzione richiede `Read` e `PathDiscovery` flag di <xref:System.Security.Permissions.FileIOPermission>per essere concesso al codice in esecuzione.</xref:System.Security.Permissions.FileIOPermission> Per ulteriori informazioni, vedere <xref:System.Security.SecurityException> [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica uno o più nomi di file da eliminare. `PathName`può includere la directory o una cartella e l&quot;unità."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Aprire il file di destinazione."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Destinazione file non trovati."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Autorizzazione negata."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Legge una riga singola da un file sequenziale aperto e assegna a un <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabile."
  remarks: "Il `LineInput` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       I dati letti con `LineInput` vengono generalmente scritti in un file utilizzando `Print`.      > [!IMPORTANT] > Durante la lettura da file, non prendere decisioni sul contenuto di un file in base all&quot;estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.       Il `LineInput` funzione legge da un file di un carattere alla volta finché incontra un ritorno a capo (`Chr(`13`)`) o un ritorno a capo/avanzamento riga (`Chr(`13`)` + `Chr(`10`)`) sequenza. Le sequenze di avanzamento di ritorno a capo/riga vengono ignorate anziché aggiunte alla stringa di caratteri.      > [!IMPORTANT] > La lettura da un file utilizzando il `LineInput` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess>enumerazione.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    return:
      type: System.String
      description: "Legge una riga singola da un file sequenziale aperto e assegna a un <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabile."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Raggiunta la fine del file."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valore che specifica la posizione di lettura/scrittura corrente in un file aperto."
  remarks: "Il `Loc` funzione è in base zero, utilizzarla per recuperare il primo byte in un file, verrà restituito 0.       Il `Loc` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       Di seguito viene descritto il valore restituito per ogni modalità di accesso ai file: | | |   |-|-|   | Modalità | Valore restituito |   | `Random`| Numero dell&quot;ultimo record letto o scritto nel file. |   | `Sequential`| Posizione corrente di byte nel file diviso per 128. Tuttavia, le informazioni restituite dalla `Loc` per file sequenziali è necessaria né utilizzato. |   | `Binary`| Posizione dell&quot;ultimo byte letti o scritti. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> numero di file."
    return:
      type: System.Int64
      description: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valore che specifica la posizione di lettura/scrittura corrente in un file aperto."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Record
      type: System.Int64
      description: "Facoltativa. Numero del record o byte da bloccare o sbloccare"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: FromRecord
      type: System.Int64
      description: "Facoltativa. Numero del primo record o byte per bloccare o sbloccare."
    - id: ToRecord
      type: System.Int64
      description: "Facoltativa. Numero dell&quot;ultimo record o byte per bloccare o sbloccare."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> che rappresenta le dimensioni, in byte, di un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Utilizzare il `FileLen` funzione per ottenere la lunghezza di un file che non è aperta."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> che contiene un numero di file valido."
    return:
      type: System.Int64
      description: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> che rappresenta le dimensioni, in byte, di un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Crea una nuova directory. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Questa funzione crea una nuova directory."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che identifica la directory da creare. Il `Path` può includere l&quot;unità. Se viene specificata alcuna unità, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> Crea nuova directory dell&quot;unità corrente."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>non è specificato o è vuota."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Autorizzazione negata."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Directory già esistente."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive dati in formato di visualizzazione in un file sequenziale."
  remarks: "Il `Print` e `PrintLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`non include una riga feed alla fine di una linea. Tuttavia, `PrintLine` includono un avanzamento riga.       I dati scritti con `Print` è in genere letti da un file mediante `LineInput` o `Input`.       Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota per il file, ad `Print`, niente è output. Più espressioni separate da una virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.       Per `Boolean` dati, ovvero `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.       Dati di data vengono scritti nel file utilizzando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.       Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` elenco dati `DBNull`, `Null` viene scritta nel file.       Per `Error` dati, l&quot;output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.       Tutti i dati scritti nel file utilizzando `Print` internazionali; ovvero, i dati sia formattati correttamente utilizzando il separatore decimale appropriato. Se l&quot;utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.       La scrittura in un file mediante il `Print` o `PrintLine` funzioni richiede `Write` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Output
      type: System.Object[]
      description: "Facoltativa. Zero o più espressioni delimitato da virgole da scrivere in un file.       Il `Output` impostazioni degli argomenti sono: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: modalità File non è valida.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` non esiste."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive dati in formato di visualizzazione in un file sequenziale."
  remarks: "Il `Print` e `PrintLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`non include una riga feed alla fine di una linea. Tuttavia,`PrintLine` includono un avanzamento riga.       I dati scritti con `Print` è in genere letti da un file mediante `LineInput` o `Input`.       Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota per il file, ad `Print`, niente è output. Più espressioni separate da una virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.       Per `Boolean` dati, ovvero `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.       Dati di data vengono scritti nel file utilizzando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.       Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` elenco dati `DBNull`, `Null` viene scritta nel file.       Per `Error` dati, l&quot;output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.       Tutti i dati scritti nel file utilizzando `Print` internazionali; ovvero, i dati sia formattati correttamente utilizzando il separatore decimale appropriato. Se l&quot;utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.       La scrittura in un file mediante il `Print` o `PrintLine` funzioni richiede `Write` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Output
      type: System.Object[]
      description: "Facoltativa. Zero o più espressioni delimitato da virgole da scrivere in un file.       Il `Output` impostazioni degli argomenti sono: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: modalità File non è valida.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` non esiste."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Rinomina un file su disco o una directory. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il`Rename` funzione Rinomina un file e lo sposta in una directory diversa, se necessario. Il `Rename` funzione è possibile spostare un file in unità, ma è possibile rinominare solo una directory esistente quando entrambi `NewPath` e `OldPath` si trovano nella stessa unità. `Rename`non è possibile creare un nuovo file o directory.       Utilizzo di `Rename` funzione in un file aperto viene generato un errore. Prima di rinominarlo, è necessario chiudere un file aperto. `Rename`argomenti non possono includere più caratteri (*) e caratteri jolly (?) con caratteri a singolo.      > [!IMPORTANT] > Quando si utilizza `Rename` per copiare un file da un percorso non protetto in un percorso protetto, il file manterrà i diritti meno restrittivi. Verifica per accertarsi di non introdurre possibili rischi di sicurezza."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica il percorso e nome del file esistente. `OldPath`può includere la directory e l&quot;unità del file."
    - id: NewPath
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica il percorso e il nuovo nome di file. `NewPath`può includere la directory e unità del percorso di destinazione. Il nome del file specificato da `NewPath` esiste già."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Percorso non è valido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>file non esiste."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Impossibile rinominare in dispositivi diversi."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Chiude tutti i file su disco aperti mediante il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Reset` funzione chiude tutti i file aperti per la `FileOpen` funzione e ha la stessa funzione `FileClose()` senza parametri."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Rimuove una directory esistente. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Si verifica un errore se si tenta di utilizzare `RmDir` in una directory che contiene i file. Utilizzare il `Kill` funzione eliminare tutti i file prima di tentare di rimuovere una directory."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che identifica la directory o cartella da rimuovere. `Path`può includere l&quot;unità. Se viene specificata alcuna unità, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> rimuove la directory dell&quot;unità corrente."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>non è specificato o è vuota."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Directory di destinazione contiene file."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Directory non esiste."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> che specifica la posizione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funzione, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.       Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file: | | |   |-|-|   | Modalità | Valore restituito |   | `Random`| Numero del record successivo letto o scritto |   | `Binary`, `Input`, `Output`, `Append`| Posizione di byte in cui viene eseguita l&quot;operazione successiva. È il primo byte in un file nella posizione 1, il secondo byte in posizione 2 e così via. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> che contiene un numero di file valido."
    return:
      type: System.Int64
      description: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> che specifica la posizione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funzione, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione)."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Restituisce un <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> che specifica la posizione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funzione, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto usando il <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.       Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file: | | |   |-|-|   | Modalità | Valore restituito |   | `Random`| Numero del record successivo letto o scritto |   | `Binary`, `Input`, `Output`, `Append`| Posizione di byte in cui viene eseguita l&quot;operazione successiva. È il primo byte in un file nella posizione 1, il secondo byte in posizione 2 e così via. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> che contiene un numero di file valido."
    - id: Position
      type: System.Int64
      description: "Obbligatorio. Numero compreso nell&quot;intervallo tra 1 e 2.147.483.647, che indica dove la successiva operazione di lettura/scrittura deve verificarsi."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Imposta le informazioni per un file di attributo. Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Se si tenta di impostare gli attributi di un file aperto, si verifica un errore di run-time.       Il `Attributes` argomento valori di enumerazione sono i seguenti: | | |   |-|-|-|   | Valore | Costante | Descrizione |   | `Normal`|`vbNormal`| Normale (impostazione predefinita). |   | `ReadOnly`|`vbReadOnly`| Sola lettura. |   | `Hidden`|`vbHidden`| Nascosto. |   | `System`|`vbSystem`| File di sistema. |   | `Volume`|`vbVolume`| Etichetta di volume |   | `Directory`|`vbDirectory`| Directory o una cartella. |   | `Archive`|`vbArchive`| File è stato modificato dall&quot;ultimo backup. |   | `Alias`|`vbAlias`| File con un nome diverso. |      > [!NOTE] > Queste enumerazioni vengono specificate il linguaggio Visual Basic. I nomi possono essere utilizzati in qualsiasi punto nel codice anziché i valori effettivi."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Obbligatorio. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>espressione che specifica un nome di file. `PathName`può includere una directory o la cartella e unità."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Obbligatorio. Costante o espressione numerica, la cui somma specifica gli attributi di file."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>tipo non valido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzione per posizionare l&quot;output."
  remarks: "Se `Count` è minore della larghezza della riga di output, la posizione successiva immediatamente seguirà il numero di spazi stampati. Se`Count` è maggiore della larghezza della riga di output, `SPC` calcola la posizione successiva utilizzando la formula: `currentprintposition`(+ (`Count``Mod``width`)), ad esempio, se la posizione di stampa è 24, la larghezza della riga di output è 80 e si specifica `SPC(`90`)`, la stampa successiva inizierà dalla posizione 34 (posizione di stampa corrente + il resto di 90/80). Se la differenza tra la posizione di stampa e la larghezza della riga di output è minore di `Count` (o `Count` `Mod` *larghezza*), il `SPC` funzione passerà all&quot;inizio della riga successiva e genera spazi uguali a `Count` – (*larghezza* – *currentprintposition*).      > [!NOTE] > Assicurarsi che le colonne di tabella sono sufficiente a consentire caratteri ampi."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Obbligatorio. Il numero di spazi da inserire prima di visualizzare o stampare l&quot;espressione successiva in un elenco."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzione per posizionare l&quot;output."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzioni per posizionare l&quot;output."
  remarks: "Se la posizione di stampa nella riga corrente è maggiore `Column`, `TAB` passerà al valore di colonna è uguale a `Column` nella riga successiva di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa alla colonna 1. Se `Column` è maggiore della larghezza di riga di output, `TAB` calcola la posizione successiva utilizzando la formula: larghezza di colonna Mod ad esempio, se *larghezza* è 80 e si specifica `TAB(`90`)`, la stampa successiva inizierà dalla colonna 10 (il resto di 90/80). Se `Column` è minore della posizione di stampa corrente, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, posizione di stampa la stampa inizierà dalla calcolata nella stessa riga.       La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si utilizza il `Print` o `PrintLine` funzioni per la stampa su file, l&quot;ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).       Il `TAB` funzione può essere utilizzata anche con il `WriteLine` (funzione). Non può essere utilizzato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>o <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Assicurarsi che le colonne di tabella sono sufficiente a contenere i caratteri &quot;wide&quot;."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzioni per posizionare l&quot;output."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzioni per posizionare l&quot;output."
  remarks: "Se la posizione di stampa nella riga corrente è maggiore di `Column`, `TAB` passerà al valore di colonna è uguale a `Column` nella riga successiva di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa alla colonna 1. Se `Column` è maggiore della larghezza della riga di output, `TAB` calcola la posizione successiva utilizzando la formula: larghezza di colonna Mod ad esempio, se *larghezza* è 80 e si specifica `TAB(`90`)`, la stampa successiva inizierà dalla colonna 10 (il resto di 90/80). Se `Column` è minore della posizione di stampa corrente, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, posizione di stampa la stampa inizierà dalla calcolata nella stessa riga.       La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si utilizza il `Print` o `PrintLine` funzioni per la stampa su file, l&quot;ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).       Il `TAB` funzione può essere utilizzata anche con il `WriteLine` (funzione). Non può essere utilizzato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>o <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Assicurarsi che le colonne di tabella sono sufficiente a contenere i caratteri &quot;wide&quot;."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Facoltativa. Il numero di colonna spostato prima di visualizzare o stampare l&quot;espressione successiva in un elenco. Se omesso, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> sposta il punto di inserimento all&quot;inizio dell&quot;area di stampa successiva."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Utilizzato con il <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> o <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funzioni per posizionare l&quot;output."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: Record
      type: System.Int64
      description: "Facoltativa. Numero del record o byte da bloccare o sbloccare"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controlla l&quot;accesso ad altri processi a tutto o parte di un file aperto usando il <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> (funzione). Il <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> nelle funzionalità garantisce la produttività e prestazioni migliori rispetto alle operazioni dei / o file <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Per ulteriori informazioni, vedere <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l&quot;accesso al file stesso.       `Lock`e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.       Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l&quot;intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.       Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l&quot;intero file, indipendentemente dall&quot;intervallo specificato da `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Qualsiasi numero di file valido."
    - id: FromRecord
      type: System.Int64
      description: "Facoltativa. Numero del primo record o byte per bloccare o sbloccare."
    - id: ToRecord
      type: System.Int64
      description: "Facoltativa. Numero dell&quot;ultimo record o byte per bloccare o sbloccare."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive dati in un file sequenziale. I dati scritti con <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> è in genere letti da un file mediante <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Il `Write` e `WriteLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separate da una virgola.       A differenza di `Print` funzione, il `Write` funzione inserisce virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell&quot;elenco. Quando `Write` viene utilizzato per scrivere dati in un file, solo numerico, `Boolean`, data, null e `Error` sono supportati i formati di dati. Le seguenti convenzioni universali in modo che i dati possono sempre essere letti e interpretati correttamente mediante `Input`, indipendentemente dalle impostazioni locali:-dati numerici viene sempre scritto utilizzando il punto come separatore decimale.      -Per `Boolean` dati, ovvero `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.      -Data dati vengono scritti nel file utilizzando il formato di data universale. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.      -Viene scritto alcun dato per il file se `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.      -Per `Error` dati, l&quot;output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene tradotta, indipendentemente dalle impostazioni locali.       `WriteLine`Inserisce un carattere di nuova riga (vale a dire un ritorno a capo/avanzamento riga, o `Chr(13) + Chr(10)`), dopo l&quot;ultimo carattere scritto `Output` al file.       È possibile incorporare in una stringa tra virgolette con virgolette doppie, o &quot;&quot;. Ad esempio, [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] restituisce una stringa con il valore di `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       La scrittura in un file mediante il `Write` o `WriteLine` funzioni richiede `Append` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> espressione che contiene qualsiasi numero di file valido."
    - id: Output
      type: System.Object[]
      description: "Facoltativa. Uno o più espressioni delimitato da virgole da scrivere in un file."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modalità file non è valida."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Scrive dati in un file sequenziale. I dati scritti con <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> è in genere letti da un file mediante <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Il `Write` e `WriteLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separate da una virgola.       A differenza di `Print` funzione, il `Write` funzione inserisce virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell&quot;elenco. Quando `Write` viene utilizzato per scrivere dati in un file, solo numerico, `Boolean`, data, null e `Error` sono supportati i formati di dati. Le seguenti convenzioni universali in modo che i dati possono sempre essere letti e interpretati correttamente mediante `Input`, indipendentemente dalle impostazioni locali:-dati numerici viene sempre scritto utilizzando il punto come separatore decimale.      -Per `Boolean` dati, ovvero `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.      -Data dati vengono scritti nel file utilizzando il formato di data universale. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.      -Viene scritto alcun dato per il file se `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.      -Per `Error` dati, l&quot;output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene tradotta, indipendentemente dalle impostazioni locali.       `WriteLine`Inserisce un carattere di nuova riga (vale a dire un ritorno a capo/avanzamento riga, o `Chr(13) + Chr(10)`), dopo l&quot;ultimo carattere scritto `Output` al file.       È possibile incorporare in una stringa tra virgolette con virgolette doppie, o &quot;&quot;. Ad esempio, [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] restituisce una stringa con il valore di `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       La scrittura in un file mediante il `Write` o `WriteLine` funzioni richiede `Append` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obbligatorio. Un <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> espressione che contiene qualsiasi numero di file valido."
    - id: Output
      type: System.Object[]
      description: "Facoltativa. Uno o più espressioni delimitato da virgole da scrivere in un file."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
