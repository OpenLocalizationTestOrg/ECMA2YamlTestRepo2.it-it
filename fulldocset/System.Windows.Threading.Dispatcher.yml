### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "Fornisce servizi per la gestione della coda di elementi di lavoro per un thread."
  remarks: "Il Dispatcher gestisce una coda con priorità degli elementi di lavoro per un thread specifico.       Creazione di un Dispatcher in un thread, diventa l&quot;unico Dispatcher che possono essere associate al thread, anche se il Dispatcher è stato arrestato.       Se si tenta di ottenere il <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>per il thread corrente e un Dispatcher non è associato al thread, verrà creato un Dispatcher.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Quando si crea un <xref:System.Windows.Threading.DispatcherObject>.</xref:System.Windows.Threading.DispatcherObject> viene inoltre creato un Dispatcher Se si crea un Dispatcher in un thread in background, assicurarsi di arrestare il dispatcher prima della chiusura del thread.       Se un Dispatcher viene arrestato, non può essere riavviato.       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject>accessibile solo dal Dispatcher è associato.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è associato al Dispatcher sul [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere il <xref:System.Windows.Controls.ContentControl.Content%2A>proprietà del <xref:System.Windows.Controls.Button>, il thread in background deve delegare l&quot;operazione per il Dispatcher associato il [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda del Dispatcher all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato in un Dispatcher che arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Tutti i metodi nel Dispatcher, ad eccezione di <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, sono a thread libero.</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       Gli oggetti che derivano da <xref:System.Windows.Threading.DispatcherObject>presentano affinità di thread.</xref:System.Windows.Threading.DispatcherObject>       Gli oggetti che derivano da <xref:System.Windows.Freezable>sono a thread libero quando sono bloccati.</xref:System.Windows.Freezable>  Per ulteriori informazioni, vedere [panoramica sugli oggetti Freezable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato in modo asincrono con gli argomenti specificati nel thread che il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è stato creato."
  remarks: "Il <xref:System.Windows.Threading.DispatcherOperation>oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>può essere usato in vari modi per interagire con il delegato specificato, ad esempio: - modifica il <xref:System.Windows.Threading.DispatcherPriority>del delegato mentre è in attesa esecuzione nella coda degli eventi.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Rimozione del delegato dalla coda degli eventi.      -In attesa per il delegato da restituire.      -Il recupero del valore restituito dal delegato dopo di esso viene eseguito.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrona; Pertanto, restituendo immediatamente il controllo per l&quot;oggetto chiamante dopo la chiamata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato su un <xref:System.Windows.Threading.Dispatcher>oggetto arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Il delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto che viene restituito immediatamente dopo <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>viene chiamato, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue in modo asincrono il delegato specificato con la priorità specificata nel thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "Se vengono apportate più chiamate BeginInvoke contemporaneamente <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell&quot;ordine in cui sono state effettuate.</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Restituisce un <xref:System.Windows.Threading.DispatcherOperation>oggetto che può essere utilizzato per interagire con il delegato quando il delegato incluso nella coda degli eventi.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Il <xref:System.Windows.Threading.DispatcherOperation>oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>può essere usato in vari modi per interagire con il delegato specificato, ad esempio: - modifica il <xref:System.Windows.Threading.DispatcherPriority>del delegato mentre è in attesa esecuzione nella coda degli eventi.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Rimozione del delegato dalla coda degli eventi.      -In attesa per il delegato da restituire.      -Il recupero del valore restituito dal delegato dopo di esso viene eseguito.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrona; Pertanto, restituendo immediatamente il controllo per l&quot;oggetto chiamante dopo la chiamata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato su un <xref:System.Windows.Threading.Dispatcher>oggetto arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Il delegato a un metodo che non accetta alcun argomento, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto che viene restituito immediatamente dopo <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>viene chiamato, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è un valido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato in modo asincrono con gli argomenti specificati, la priorità specificata sul thread che il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è stato creato."
  remarks: "Il <xref:System.Windows.Threading.DispatcherOperation>oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>può essere usato in vari modi per interagire con il delegato specificato, ad esempio: - modifica il <xref:System.Windows.Threading.DispatcherPriority>del delegato mentre è in attesa esecuzione nella coda degli eventi.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Rimozione del delegato dalla coda degli eventi.      -In attesa per il delegato da restituire.      -Il recupero del valore restituito dal delegato dopo di esso viene eseguito.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrona; Pertanto, restituendo immediatamente il controllo per l&quot;oggetto chiamante dopo la chiamata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato su un <xref:System.Windows.Threading.Dispatcher>oggetto arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Il delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto che viene restituito immediatamente dopo <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>viene chiamato, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato in modo asincrono la priorità specificata e con l&quot;argomento specificato sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "`Arg`può essere `null` se non sono richiesti argomenti.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Restituisce un <xref:System.Windows.Threading.DispatcherOperation>oggetto che può essere utilizzato per interagire con il delegato quando il delegato incluso nella coda degli eventi.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Il <xref:System.Windows.Threading.DispatcherOperation>oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>può essere usato in vari modi per interagire con il delegato specificato, ad esempio: - modifica il <xref:System.Windows.Threading.DispatcherPriority>del delegato mentre è in attesa esecuzione nella coda degli eventi.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Rimozione del delegato dalla coda degli eventi.      -In attesa per il delegato da restituire.      -Il recupero del valore restituito dal delegato dopo di esso viene eseguito.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrona; Pertanto, restituendo immediatamente il controllo per l&quot;oggetto chiamante dopo la chiamata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>chiamate vengono eseguite contemporaneamente <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell&quot;ordine in cui sono state effettuate.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato su un <xref:System.Windows.Threading.Dispatcher>oggetto arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta un argomento, viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto che viene restituito immediatamente dopo <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>viene chiamato, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è un valido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato in modo asincrono la priorità specificata e con la matrice di argomenti specificati nel thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "Il `arg` parametro può essere `null` se non sono richiesti argomenti.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Restituisce un <xref:System.Windows.Threading.DispatcherOperation>oggetto che può essere utilizzato per interagire con il delegato quando il delegato incluso nella coda degli eventi.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Il <xref:System.Windows.Threading.DispatcherOperation>oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>può essere usato in vari modi per interagire con il delegato specificato, ad esempio: - modifica il <xref:System.Windows.Threading.DispatcherPriority>del delegato mentre è in attesa esecuzione nella coda degli eventi.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Rimozione del delegato dalla coda degli eventi.      -In attesa per il delegato da restituire.      -Il recupero del valore restituito dal delegato dopo di esso viene eseguito.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrona; Pertanto, restituendo immediatamente il controllo per l&quot;oggetto chiamante dopo la chiamata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>chiamate vengono eseguite contemporaneamente <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell&quot;ordine in cui sono state effettuate.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>viene chiamato su un <xref:System.Windows.Threading.Dispatcher>oggetto arrestato, la proprietà status dell&quot; restituito <xref:System.Windows.Threading.DispatcherOperation>è impostato su <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta più argomenti, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto che viene restituito immediatamente dopo <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>viene chiamato, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione nel <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>non è una priorità valida."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Avvia la chiusura del <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> in modo asincrono."
  remarks: "BeginInvokeShutdown richiede le autorizzazioni senza restrizioni dell&quot;interfaccia utente.       Quando il <xref:System.Windows.Threading.Dispatcher>inizia l&quot;arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non arresta completamente finché la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Al termine dell&quot;arresto, il Dispatcher di <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità da cui iniziare l&quot;arresto del dispatcher."
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se il thread chiamante è il thread associato a questo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Solo il <xref:System.Windows.Threading.Dispatcher>che un <xref:System.Windows.Threading.DispatcherObject>viene creato in cui possono accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  Utilizzare <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>per accedere all&quot;oggetto da un thread diverso.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       CheckAccess può essere chiamato da qualsiasi thread.       La differenza tra CheckAccess e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>CheckAccess restituisce un valore booleano che indica se il thread chiamante dispone dell&quot;accesso per il <xref:System.Windows.Threading.Dispatcher>e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>genera un&quot;eccezione.</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il thread chiamante è il thread associato a questo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ottiene il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> per il thread attualmente in esecuzione e crea un nuovo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> se non è già associato al thread."
  remarks: "Se un <xref:System.Windows.Threading.Dispatcher>non è associato il thread corrente, un nuovo <xref:System.Windows.Threading.Dispatcher>verrà creato.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  Non è il caso di <xref:System.Windows.Threading.Dispatcher.FromThread%2A>metodo.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>restituirà `null` se non è disponibile un dispatcher associato al thread specificato.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "Il dispatcher associato al thread corrente."
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Disabilita l&quot;elaborazione del <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda."
  remarks: "Disabilitare l&quot;elaborazione del dispatcher è un metodo avanzato è pensato per eliminare la possibilità di reentrancy non correlata.       Gli effetti della disabilitazione dell&quot;elaborazione sono i seguenti:- [!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)] blocchi verranno non message pump internamente.      - <xref:System.Windows.Threading.DispatcherFrame>oggetti non sono consentiti per essere inserita.</xref:System.Windows.Threading.DispatcherFrame>      -L&quot;elaborazione dei messaggi non è consentito.       Il <xref:System.Windows.Threading.DispatcherProcessingDisabled>struttura DisableProcessing restituisce quando viene chiamata consente di abilitare di nuovo l&quot;elaborazione del dispatcher.</xref:System.Windows.Threading.DispatcherProcessingDisabled>  La chiamata <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>sul <xref:System.Windows.Threading.DispatcherProcessingDisabled>struttura elaborazione verrà riattivata.</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       DisableProcessing può essere chiamato solo sul thread di <xref:System.Windows.Threading.Dispatcher>è associato.</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "Una struttura utilizzata per abilitare nuovamente l&quot;elaborazione del dispatcher."
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Richiede che tutti i frame uscire, inclusi i frame annidati."
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ottiene il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> per il thread specificato."
  remarks: "Se non è disponibile per il thread specificato, un dispatcher `null` verranno restituiti.       FromThread non crea un <xref:System.Windows.Threading.Dispatcher>su un thread che non dispone di un <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>   Un nuovo <xref:System.Windows.Threading.Dispatcher>viene creato su un thread che non dispone già di un <xref:System.Windows.Threading.Dispatcher>durante il tentativo di ottenere il <xref:System.Windows.Threading.Dispatcher>utilizzando il <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>proprietà.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "Il thread per ottenere il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> da."
    return:
      type: System.Windows.Threading.Dispatcher
      description: "Il dispatcher per <code> thread </code>."
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> ha terminato l&quot;arresto."
  remarks: "Quando il <xref:System.Windows.Threading.Dispatcher>inizia l&quot;arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non si arresta completamente fino a quando la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Al termine dell&quot;arresto, il Dispatcher di <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>viene generato l&quot;evento e la proprietà HasShutdownFinished è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il dispatcher ha completato l&quot;arresto; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è in corso l&quot;arresto."
  remarks: "Quando il <xref:System.Windows.Threading.Dispatcher>inizia l&quot;arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>evento viene generato e HasShutdownStarted è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non arresta completamente finché la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Al termine dell&quot;arresto, il Dispatcher di <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> avviato la fase di chiusura; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ottiene la raccolta di hook che forniscono informazioni aggiuntive sull&quot;evento relativamente il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Il <xref:System.Windows.Threading.DispatcherHooks>classe vengono fornite informazioni aggiuntive sul <xref:System.Windows.Threading.Dispatcher>, ad esempio quando il <xref:System.Windows.Threading.Dispatcher>è inattivo o quando un&quot;operazione è stata completata.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "Gli hook associati a questo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo sincrono con una priorità specificata sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità determina l&quot;ordine viene richiamato il callback specificato rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue in modo sincrono il delegato specificato con la priorità specificata sul thread in cui il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che non accetta argomenti, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>è uguale a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è una priorità valida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo sincrono con una priorità specificata sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità determina l&quot;ordine viene richiamato il callback specificato rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Oggetto che indica se annullare l&quot;azione."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato entro l&quot;intervallo di tempo designato la priorità specificata con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: timeout
      type: System.TimeSpan
      description: "La quantità massima di tempo di attesa del completamento dell&quot;operazione."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con la priorità specificata con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con la priorità specificata con l&quot;argomento specificato in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "`Arg`può essere `null` se un argomento non è necessaria In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta un argomento, viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>è uguale a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è una priorità valida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato in modo sincrono la priorità specificata e con il valore di timeout specificato sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è stato creato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: timeout
      type: System.TimeSpan
      description: "Il tempo massimo di attesa per l&quot;operazione da completare."
    - id: method
      type: System.Delegate
      description: "Il delegato a un metodo che non accetta alcun argomento, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo sincrono con una priorità specificata sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità determina l&quot;ordine viene richiamato il callback specificato rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Oggetto che indica se annullare l&quot;azione."
    - id: timeout
      type: System.TimeSpan
      description: "La quantità minima di tempo di attesa per l&quot;operazione di avvio."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato entro l&quot;intervallo di tempo designato la priorità specificata con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject> Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button> Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta i parametri specificati `args`, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: timeout
      type: System.TimeSpan
      description: "La quantità massima di tempo di attesa del completamento dell&quot;operazione."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con la priorità specificata con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "`Arg`può essere `null` se un argomento non è necessaria In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta più argomenti, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>è uguale a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è una priorità valida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con la priorità specificata con l&quot;argomento specificato in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "`Arg`può essere `null` se un argomento non è necessaria In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: timeout
      type: System.TimeSpan
      description: "Il tempo massimo di attesa per l&quot;operazione da completare."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta più argomenti, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato. Può trattarsi di <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se non sono richiesti argomenti."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>è uguale a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è una priorità valida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue il delegato specificato con la priorità specificata con gli argomenti specificati in modo sincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  remarks: "`Arg`può essere `null` se non è necessario un argomento.       In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject>può accedere all&quot;oggetto.</xref:System.Windows.Threading.DispatcherObject>  Ad esempio, un thread in background che viene rimosso dal thread principale della UI non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button>che è stato creato nel thread UI.</xref:System.Windows.Controls.Button>  Affinché il thread in background accedere alla proprietà di contenuto di <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher>associata al thread dell&quot;interfaccia utente.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Questa operazione viene eseguita tramite uno <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>è asincrono.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  L&quot;operazione viene aggiunta alla coda degli eventi <xref:System.Windows.Threading.Dispatcher>all&quot;indirizzo specificato <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>è un&quot;operazione sincrona. Pertanto, controllo non verrà restituito per l&quot;oggetto chiamante fino a dopo il callback restituisce.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità, rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda degli eventi, il metodo specificato viene richiamata."
    - id: timeout
      type: System.TimeSpan
      description: "Il tempo massimo di attesa per l&quot;operazione da completare."
    - id: method
      type: System.Delegate
      description: "Un delegato a un metodo che accetta più argomenti, che viene inserito il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> coda eventi."
    - id: arg
      type: System.Object
      description: "Oggetto da passare come argomento al metodo specificato."
    - id: args
      type: System.Object[]
      description: "Matrice di oggetti da passare come argomenti al metodo specificato."
    return:
      type: System.Object
      description: "Il valore restituito dal delegato richiamato oppure <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il delegato non restituisce alcun valore."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>è uguale a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è un valido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    return:
      type: TResult
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Da aggiungere."
    return:
      type: TResult
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Da aggiungere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Da aggiungere."
    return:
      type: TResult
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Da aggiungere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Da aggiungere."
    - id: timeout
      type: System.TimeSpan
      description: "Da aggiungere."
    return:
      type: TResult
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo asincrono sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto, che viene restituito immediatamente dopo la chiamata di metodo InvokeAsync, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo asincrono con una priorità specificata sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità determina l&quot;ordine viene richiamato il callback specificato rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto, che viene restituito immediatamente dopo la chiamata di metodo InvokeAsync, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Esegue l&quot;oggetto specificato <xref:System.Action>in modo asincrono con una priorità specificata sul thread di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Un delegato da richiamare tramite il dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità determina l&quot;ordine viene richiamato il callback specificato rispetto alle altre operazioni in sospeso il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Oggetto che indica se annullare l&quot;azione."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Un oggetto, che viene restituito immediatamente dopo la chiamata di metodo InvokeAsync, che può essere utilizzato per interagire con il delegato mentre è in attesa di esecuzione dell&quot;evento della coda."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Da aggiungere."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Da aggiungere."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Da aggiungere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Da aggiungere."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Da aggiungere."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Avvia il processo di arresto di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> in modo sincrono."
  remarks: "InvokeShutdown richiede le autorizzazioni senza restrizioni dell&quot;interfaccia utente.       Quando il <xref:System.Windows.Threading.Dispatcher>inizia l&quot;arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non arresta completamente finché la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Al termine dell&quot;arresto, il Dispatcher di <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Immette un ciclo di esecuzione."
  remarks: "Oggetto <xref:System.Windows.Threading.DispatcherFrame>rappresenta un ciclo che elabora gli elementi di lavoro in sospeso.</xref:System.Windows.Threading.DispatcherFrame>       Il Dispatcher elabora la coda di elementi di lavoro in un ciclo.  Il ciclo viene considerato un frame.  Il ciclo iniziale viene in genere avviato dall&quot;applicazione chiamando <xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>       PushFrame entra in un ciclo rappresentato dal parametro `frame`.  A ogni iterazione del ciclo, il <xref:System.Windows.Threading.Dispatcher>controllerà il <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>proprietà la <xref:System.Windows.Threading.DispatcherFrame>classe per determinare se il ciclo deve continuare o se deve essere arrestata.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>Consente di <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>proprietà da impostare in modo esplicito e rispetta la <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>proprietà <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  Ciò significa che, quando il <xref:System.Windows.Threading.Dispatcher>inizia l&quot;arresto, frame che utilizzano il valore predefinito <xref:System.Windows.Threading.DispatcherFrame>implementazione viene chiusa, che consente a tutti i frame annidati uscire dall&quot;installazione.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "Il frame per il dispatcher da elaborare."
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       - oppure - l&quot;elaborazione del Dispatcher è stata disabilitata."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Inserisce il frame di esecuzione principale nella coda degli eventi di <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Il <xref:System.Windows.Threading.Dispatcher>Elabora la coda degli eventi in un ciclo.</xref:System.Windows.Threading.Dispatcher>  Il ciclo viene considerato un frame.  Il ciclo iniziale viene in genere avviato dall&quot;applicazione mediante la chiamata di esecuzione.       Il frame di esecuzione principale continuerà fino a quando il <xref:System.Windows.Threading.Dispatcher>viene arrestato.</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Si verifica quando il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> termina l&quot;arresto."
  remarks: "Quando il processo di arresto di un <xref:System.Windows.Threading.Dispatcher>viene avviato, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non si arresta completamente fino a quando la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Quando il Dispatcher termina l&quot;arresto, viene generato l&quot;evento ShutdownFinished e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Si verifica quando il <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> inizia l&quot;arresto."
  remarks: "Quando il processo di arresto di un <xref:System.Windows.Threading.Dispatcher>viene avviato, viene generato l&quot;evento ShutdownStarted e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>è impostato su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       Il <xref:System.Windows.Threading.Dispatcher>non si arresta completamente fino a quando la coda degli eventi viene rimosso.</xref:System.Windows.Threading.Dispatcher>       Al termine dell&quot;arresto, il Dispatcher di <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>è impostata su `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Una volta avviato il processo di arresto, tutte in sospeso di lavoro vengono interrotti elementi nella coda."
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ottiene il thread si <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> è associato."
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "Il thread."
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Si verifica quando una thread viene generata un&quot;eccezione intercettata durante l&quot;esecuzione di un delegato per mezzo di <> </> *> o <> </> *>."
  remarks: "Questo evento viene generato quando un&quot;eccezione generata durante l&quot;esecuzione di un delegato per mezzo di <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>non viene intercettata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Un gestore può contrassegnare l&quot;eccezione come gestito, che impedirà il gestore dell&quot;eccezione interna la chiamata.       Gestori eventi per questo evento devono essere scritto con attenzione per evitare di creare eccezioni secondarie e per rilevare eventuali che si verificano. È consigliabile evitare di allocare memoria o effettuare operazioni con uso intensivo nel gestore di qualsiasi risorsa.       Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>evento fornisce un mezzo per non generare l&quot;evento UnhandledException.</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>evento viene generato per primo e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>sul <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>è impostato su `false`, non verrà generato l&quot;evento UnhandledException.</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Si verifica quando una thread viene generata un&quot;eccezione intercettata durante l&quot;esecuzione di un delegato per mezzo di <> </> *> o <> </> *> quando in fase di filtro."
  remarks: "Questo evento viene generato in fase di filtro per un&quot;eccezione generata durante l&quot;esecuzione di un delegato per mezzo di <xref:System.Windows.Threading.Dispatcher.Invoke%2A>o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>e non viene intercettata.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Lo stack di chiamate non viene rimosso a questo punto (eccezione first-chance).       Gestori eventi per questo evento devono essere scritto con attenzione per evitare di creare eccezioni secondarie e per rilevare eventuali che si verificano.  È consigliabile evitare di allocare memoria o effettuare operazioni con uso intensivo nel gestore di qualsiasi risorsa.       L&quot;evento UnhandledExceptionFilter fornisce un mezzo per non generare la <xref:System.Windows.Threading.Dispatcher.UnhandledException>evento.</xref:System.Windows.Threading.Dispatcher.UnhandledException>  Viene generato l&quot;evento UnhandledExceptionFilter prima e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>nel <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>è impostato su `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException>non verrà generato l&quot;evento.</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se l&quot;oggetto specificato <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref> una priorità valida."
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità da controllare."
    - id: parameterName
      type: System.String
      description: "Stringa che verrà restituita l&quot;eccezione che si verifica se la priorità non è valida."
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>non è un valido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se il thread chiamante ha accesso a questo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Solo il thread di <xref:System.Windows.Threading.Dispatcher>viene creato sarà accessibile <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       Questo metodo è pubblico; Pertanto, qualsiasi thread può verificare se ha accesso a <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       La differenza tra <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>e VerifyAccess <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>restituisce un valore booleano se il thread chiamante non dispone di accesso per il <xref:System.Windows.Threading.Dispatcher>e VerifyAccess genera un&quot;eccezione.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il thread chiamante non ha accesso a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Crea un oggetto awaitable che restituisce il controllo torna al dispatcher corrente in modo asincrono e offre l&quot;opportunità per il dispatcher elaborare gli altri eventi."
  remarks: "Questo metodo fornisce un modo rilasciare temporaneamente il controllo di esecuzione per il dispatcher corrente in modo è possibile eseguire altre operazioni, ad esempio elaborare altri eventi. Utilizzare il `await`, o `Await` in Visual Basic, l&quot;operatore sul valore restituito per restituire il controllo al dispatcher corrente. Utilizzare questo metodo se desidera possibilità di elaborare gli eventi, mentre l&quot;app esegue il lavoro nel thread UI dell&quot;app. Ad esempio, è possibile utilizzare questo metodo in un ciclo a esecuzione prolungata che aggiorna un controllo.       Questo metodo equivale a chiamare il <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>metodo e passando <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Un oggetto awaitable che restituisce il controllo torna al dispatcher corrente in modo asincrono e offre l&quot;opportunità per il dispatcher elaborare gli altri eventi."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Crea un oggetto awaitable che restituisce il controllo torna al dispatcher corrente in modo asincrono e offre l&quot;opportunità per il dispatcher elaborare gli altri eventi.  Il lavoro che si verifica quando il controllo torna al codice in attesa il risultato di questo metodo è pianificato con la priorità specificata."
  remarks: "Questo metodo fornisce un modo rilasciare temporaneamente il controllo di esecuzione per il dispatcher corrente in modo è possibile eseguire altre operazioni, ad esempio elaborare altri eventi. Utilizzare il `await`, o `Await` in Visual Basic, l&quot;operatore sul valore restituito per restituire il controllo al dispatcher corrente. Utilizzare questo metodo se desidera possibilità di elaborare gli eventi, mentre l&quot;app esegue il lavoro nel thread UI dell&quot;app. Ad esempio, è possibile utilizzare questo metodo in un ciclo a esecuzione prolungata che aggiorna un controllo."
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "La priorità in cui pianificare la continuazione."
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Un oggetto awaitable che restituisce il controllo torna al dispatcher corrente in modo asincrono e offre l&quot;opportunità per il dispatcher elaborare gli altri eventi."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
