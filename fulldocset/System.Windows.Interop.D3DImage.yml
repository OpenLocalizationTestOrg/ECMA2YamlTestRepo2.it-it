### YamlMime:ManagedReference
items:
- uid: System.Windows.Interop.D3DImage
  id: D3DImage
  children:
  - System.Windows.Interop.D3DImage.#ctor
  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  - System.Windows.Interop.D3DImage.Clone
  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CloneCurrentValue
  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CopyBackBuffer
  - System.Windows.Interop.D3DImage.CreateInstanceCore
  - System.Windows.Interop.D3DImage.Finalize
  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.Height
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  - System.Windows.Interop.D3DImage.Lock
  - System.Windows.Interop.D3DImage.Metadata
  - System.Windows.Interop.D3DImage.PixelHeight
  - System.Windows.Interop.D3DImage.PixelWidth
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  - System.Windows.Interop.D3DImage.Unlock
  - System.Windows.Interop.D3DImage.Width
  langs:
  - csharp
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
  type: Class
  summary: "Un <xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> che visualizza una superficie di Direct3D creati dall&quot;utente."
  remarks: "Utilizzare la classe D3DImage per ospitare contenuto Direct3D in un&quot;applicazione Windows Presentation Foundation (WPF).       Chiamare il <xref:System.Windows.Interop.D3DImage.Lock%2A>metodo per modificare il contenuto Direct3D visualizzato dal D3DImage.</xref:System.Windows.Interop.D3DImage.Lock%2A> Chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo per assegnare una superficie Direct3D in un D3DImage.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Chiamare il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>metodo per tenere traccia degli aggiornamenti all&quot;area di Direct3D.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Chiamare il <xref:System.Windows.Interop.D3DImage.Unlock%2A>metodo per visualizzare le aree modificate.</xref:System.Windows.Interop.D3DImage.Unlock%2A>       La classe D3DImage gestisce due buffer di visualizzazione, ovvero il *buffer nascosto* e *buffer anteriore*. Il buffer rappresenta la superficie di Direct3D.  Le modifiche apportate al buffer nascosto vengono copiate nel front buffer quando si chiama il <xref:System.Windows.Interop.D3DImage.Unlock%2A>(metodo), in cui vengono visualizzati nell&quot;hardware.</xref:System.Windows.Interop.D3DImage.Unlock%2A> In alcuni casi, il front buffer non è più disponibile. La mancanza di disponibilità può essere causata dal blocco dello schermo, applicazioni Direct3D esclusive a schermo intero, cambio utente o altre attività di sistema. In questo caso, l&quot;applicazione WPF notifica gestendo il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Modalità di risposta dell&quot;applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Risponde a un Buffer di primo piano non disponibile quando WPF non utilizzerà per il Rendering Software quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>overload o chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>eseguire l&quot;overload con il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando il front buffer non è più disponibile e viene visualizzato nulla.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento per notificare all&quot;applicazione WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>riavviare il rendering con una superficie Direct3D valida dell&quot;evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Per riavviare il rendering, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Risponde a un Buffer di primo piano non disponibile quando WPF rientra indietro per il Rendering Software quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>eseguire l&quot;overload con il `enableSoftwareFallback` parametro impostato su `true`, il sistema di rendering mantiene il relativo riferimento al buffer nascosto quando il front buffer non è disponibile, in modo non è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando il buffer anteriore sarà nuovamente disponibile.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>  Potrebbero verificarsi situazioni in cui il dispositivo dell&quot;utente non è più disponibile.  In questo caso, chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>per rilasciare il riferimento di WPF al buffer nascosto.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Per reimpostare il dispositivo, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>con il `backBuffer` parametro impostato su `null`e quindi chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>con `backBuffer` impostato su una superficie Direct3D valida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      > [!NOTE] > Le prestazioni dipendono notevolmente le impostazioni dell&quot;area di Direct3D. Per ulteriori informazioni, vedere [considerazioni sulle prestazioni per l&quot;interoperabilità di WPF e Direct3D9](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > D3DImage la classe non visualizza contenuto Direct3D quando WPF il rendering software, ad esempio tramite una connessione Desktop remoto, a meno che non si chiama <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>e specificare `true` per il `enableSoftwareFallback` parametro.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>"
  example:
  - "The following code example shows how to declare a D3DImage in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-xml[System.Windows.Interop.D3DImage#10](~/add/codesnippet/xaml/d3dhost/window1.xaml#10)]"
  syntax:
    content: 'public class D3DImage : System.Windows.Media.ImageSource'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  - System.Windows.Media.Animation.Animatable
  - System.Windows.Media.ImageSource
  implements: []
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)
  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Media.ImageSource.ToString
  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor
  id: '#ctor'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe."
  remarks: "La risoluzione dello schermo predefinito è 1/96 di pollice."
  syntax:
    content: public D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  id: '#ctor(System.Double,System.Double)'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe con la risoluzione dello schermo specificata."
  remarks: "La risoluzione dello schermo predefinito è 1/96 di pollice."
  syntax:
    content: public D3DImage (double dpiX, double dpiY);
    parameters:
    - id: dpiX
      type: System.Double
      description: "La risoluzione dello schermo sull&quot;asse x."
    - id: dpiY
      type: System.Double
      description: "La risoluzione dello schermo sull&quot;asse y."
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>dpiX</code>o <code>dpiY</code> è minore di zero."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  id: AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Specifica l&quot;area del buffer nascosto modificata."
  remarks: "Chiamare il metodo AddDirtyRect per indicare le modifiche apportate dal codice al buffer nascosto. Per eseguire il rendering dell&quot;area modificata nel buffer nascosto deve avere un&quot;area modificata corrispondente in <xref:System.Windows.Interop.D3DImage>.</xref:System.Windows.Interop.D3DImage>       Chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>e <xref:System.Windows.Interop.D3DImage.Lock%2A>metodi prima di chiamare il metodo AddDirtyRect.</xref:System.Windows.Interop.D3DImage.Lock%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Chiamare il <xref:System.Windows.Interop.D3DImage.Unlock%2A>metodo per copiare le aree modificate nel front buffer.</xref:System.Windows.Interop.D3DImage.Unlock%2A>      > [!NOTE] > Dopo alcune chiamate al metodo AddDirtyRect, le aree modificate vengono unite in un&quot;unica area. Ciò significa che è necessario disporre di dati validi di fuori di aree modificate."
  example:
  - "The following code example shows how to call the AddDirtyRect method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);
    parameters:
    - id: dirtyRect
      type: System.Windows.Int32Rect
      description: "Un <xref href=&quot;System.Windows.Int32Rect&quot;> </xref> che rappresenta l&quot;area modificata."
  overload: System.Windows.Interop.D3DImage.AddDirtyRect*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "La bitmap non è stata bloccata da una chiamata al <> </> *> o <> </> *> metodi.       - oppure - buffer nascosto non è stato assegnato da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer*>metodo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer*>"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Uno o più delle seguenti condizioni sono true.       <code>dirtyRect.X</code>&lt; 0       <code>dirtyRect.Y</code> &lt; 0       <code>dirtyRect.Width</code> &lt; 0 or <code>dirtyRect.Width</code> &gt; <>*>       <code>dirtyRect.Height</code> &lt; 0 or <code>dirtyRect.Height</code> &gt;<>*>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Clone
  id: Clone
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Crea un clone modificabile di questo <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> oggetto, eseguendo copie complete dei valori dell&quot;oggetto. Durante la copia delle proprietà di dipendenza, questo metodo copia risorsa riferimenti e i data binding (che potrebbe non risolvere più), ma non le animazioni né i relativi valori correnti."
  remarks: "Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable>oggetti (o qualsiasi <xref:System.Windows.Freezable>oggetto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Per comodità, questo metodo nasconde la versione ereditata con un&quot;implementazione fortemente tipizzata.       Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage Clone ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Un clone modificabile dell&quot;oggetto corrente. L&quot;oggetto clonato <> </> *> proprietà sarà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> anche se l&quot;origine <> </> *> era di proprietà<xref uid=&quot;langword_csharp_true.&quot; name=&quot;true.&quot; href=&quot;&quot;></xref>"
  overload: System.Windows.Interop.D3DImage.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  id: CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Rende l&quot;istanza un clone (copia completa) dell&quot;oggetto specificato <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizzando i valori di proprietà di base (non animati)."
  syntax:
    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Oggetto da clonare."
  overload: System.Windows.Interop.D3DImage.CloneCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  id: CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Crea un clone modificabile di questo <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> oggetto, eseguendo copie complete dei valori correnti di tale oggetto. I riferimenti alle risorse, data binding e le animazioni non vengono copiate, ma vengono copiati i relativi valori correnti."
  remarks: "Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable>oggetti (o qualsiasi <xref:System.Windows.Freezable>oggetto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Per comodità, questo metodo nasconde la versione ereditata con un&quot;implementazione fortemente tipizzata.       Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Un clone modificabile dell&quot;oggetto corrente. L&quot;oggetto clonato <> </> *> proprietà sarà <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> anche se l&quot;origine <> </> *> proprietà <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  id: CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Rende l&quot;istanza un clone modificabile (copia completa) dell&quot;oggetto specificato <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizzando i valori di proprietà correnti."
  syntax:
    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Il <xref href=&quot;System.Windows.Freezable&quot;> </xref> da clonare."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  id: CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Crea una copia del software del <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Viene chiamato il metodo CopyBackBuffer dai client, ad esempio il sistema di stampa e la <xref:System.Windows.Media.Imaging.RenderTargetBitmap>classe.</xref:System.Windows.Media.Imaging.RenderTargetBitmap>       Eseguire l&quot;override del metodo CopyBackBuffer per implementare la logica personalizzata e restituire un diverso <xref:System.Windows.Media.Imaging.BitmapSource>.</xref:System.Windows.Media.Imaging.BitmapSource> Ad esempio, è possibile restituire un segnaposto <xref:System.Windows.Media.Imaging.BitmapSource>se CopyBackBuffer implementazione predefinita restituisce `null`.</xref:System.Windows.Media.Imaging.BitmapSource>"
  syntax:
    content: protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();
    parameters: []
    return:
      type: System.Windows.Media.Imaging.BitmapSource
      description: "Oggetto <xref href=&quot;System.Windows.Media.Imaging.BitmapSource&quot;> </xref> che rappresenta una copia del software corrente dello stato del buffer nascosto; in caso contrario, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se il buffer non può essere letto."
  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  id: CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Quando viene implementato in una classe derivata, crea una nuova istanza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe derivata."
  remarks: "Se si deriva dal <xref:System.Windows.Interop.D3DImage>(classe), è necessario eseguire l&quot;override del metodo CreateInstanceCore per consentire la corretta clonazione.</xref:System.Windows.Interop.D3DImage> L&quot;implementazione predefinita esegue un `return new D3DImage()`, che non sarà corretto se l&quot;istanza è una classe diversa."
  syntax:
    content: protected override System.Windows.Freezable CreateInstanceCore ();
    parameters: []
    return:
      type: System.Windows.Freezable
      description: "Nuova istanza."
  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Finalize
  id: Finalize
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Consente di liberare risorse ed esegue altre operazioni di pulizia prima che il <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> venga recuperata tramite garbage collection."
  remarks: "Questo metodo esegue l&quot;override <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> Il codice dell&quot;applicazione non deve chiamare questo metodo. un oggetto `Finalize` metodo viene richiamato automaticamente durante l&quot;operazione di garbage collection, a meno che la finalizzazione del garbage collector non è stata disabilitata da una chiamata al <xref:System.GC.SuppressFinalize%2A>metodo.</xref:System.GC.SuppressFinalize%2A>       Per ulteriori informazioni, vedere [metodi Finalize e distruttori](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [la pulizia di risorse non gestite](~/add/includes/ajax-current-ext-md.md), e [si esegue l&quot;override del metodo Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Rende la <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> non modificabile o determina se è possibile renderla non modificabile."
  remarks: "La <xref:System.Windows.Interop.D3DImage>classe non consente il blocco perché le modifiche sono sempre a causa della disponibilità del front-buffer.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: protected override sealed bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "Non ha alcun effetto."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>in tutti i casi."
  overload: System.Windows.Interop.D3DImage.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  id: GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Rende l&quot;istanza un clone bloccato dell&quot;oggetto specificato <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizzando i valori di proprietà di base (non animati)."
  syntax:
    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "L&quot;istanza da copiare."
  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Rende l&quot;istanza corrente di un clone bloccato dell&quot;oggetto specificato <xref href=&quot;System.Windows.Freezable&quot;> </xref>. Se l&quot;oggetto ha proprietà di dipendenza animate, i valori animati correnti vengono copiati."
  syntax:
    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Il <xref href=&quot;System.Windows.Freezable&quot;> </xref> da copiare e bloccare."
  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Height
  id: Height
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene l&quot;altezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Il valore dell&quot;altezza può cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Height { get; }
    return:
      type: System.Double
      description: "L&quot;altezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, nell&quot;unità di misura. Un&quot;unità di misura è 1/96 di pollice."
  overload: System.Windows.Interop.D3DImage.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  id: IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene un valore che indica se è presente un front buffer."
  remarks: "In alcuni casi, il front buffer non è più disponibile. La mancanza di disponibilità può essere causata dal blocco dello schermo, applicazioni Direct3D esclusive a schermo intero, cambio utente o altre attività di sistema. In questo caso, l&quot;applicazione WPF notifica gestendo il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Modalità di risposta dell&quot;applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Per ulteriori informazioni, vedere le note in una <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>      <a name=&quot;dependencyPropertyInfo_IsFrontBufferAvailable&quot;></a># # Informazioni proprietà di dipendenza | | |   |-|-|   | Campo dell&quot;identificatore | <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|   | Impostare le proprietà dei metadati su `true`| None |</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>"
  example:
  - "The following code example shows how to check the IsFrontBufferAvailable property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#2](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#2)]"
  syntax:
    content: public bool IsFrontBufferAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se è presente un front buffer. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  id: IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Si verifica quando il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>le modifiche alle proprietà.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  remarks: "Gestire IsFrontBufferAvailableChanged per ricevere una notifica quando viene modificato lo stato del buffer anteriore. Modalità di risposta dell&quot;applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Per ulteriori informazioni, vedere le note in una <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  id: IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Identifica la <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>proprietà di dipendenza.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Lock
  id: Lock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Blocca il <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e consente di eseguire operazioni nel buffer nascosto."
  remarks: "Chiamare il metodo di blocco per modificare il buffer nascosto chiamando il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>e <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodi.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Mentre il <xref:System.Windows.Interop.D3DImage>è bloccato, l&quot;applicazione può inoltre eseguire il rendering della superficie Direct3D assegnata al buffer nascosto.</xref:System.Windows.Interop.D3DImage>      > [!NOTE] > Blocco di metodo mantiene il blocco quando il sistema di rendering legge il buffer nascosto per aggiornare il front buffer. Utilizzare il <xref:System.Windows.Interop.D3DImage.TryLock%2A>metodo per evitare il blocco per un periodo illimitato.</xref:System.Windows.Interop.D3DImage.TryLock%2A>"
  example:
  - "The following code example shows how to call the Lock method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Lock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Lock*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il conteggio dei blocchi è uguale a <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Metadata
  id: Metadata
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene i metadati associati con l&quot;origine dell&quot;immagine."
  syntax:
    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }
    return:
      type: System.Windows.Media.ImageMetadata
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>in tutti i casi."
  overload: System.Windows.Interop.D3DImage.Metadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelHeight
  id: PixelHeight
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene l&quot;altezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixel."
  remarks: "Il valore dell&quot;oggetto PixelHeight può cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelHeight property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelHeight { get; }
    return:
      type: System.Int32
      description: "L&quot;altezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixel."
  overload: System.Windows.Interop.D3DImage.PixelHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelWidth
  id: PixelWidth
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene la larghezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixel."
  remarks: "Il valore dell&quot;oggetto PixelWidth può cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelWidth property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelWidth { get; }
    return:
      type: System.Int32
      description: "La larghezza del <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixel."
  overload: System.Windows.Interop.D3DImage.PixelWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Assegna una superficie Direct3D come origine del buffer nascosto."
  remarks: "Chiamare il metodo SetBackBuffer per assegnare una superficie Direct3D al buffer nascosto.      > [!NOTE] > Le prestazioni dipendono notevolmente le impostazioni dell&quot;area di Direct3D. Per ulteriori informazioni, vedere [considerazioni sulle prestazioni per l&quot;interoperabilità di WPF e Direct3D9](~/add/includes/ajax-current-ext-md.md).       La chiamata dell&quot;overload SetBackBuffer è identica alla chiamata di <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>eseguire l&quot;overload con il `enableSoftwareFallback` parametro impostato su `false`.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando si chiama SetBackBuffer oppure chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>con il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando anteriore buffer non è più disponibile e viene visualizzato nulla.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento per notificare all&quot;applicazione WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>riavviare il rendering con una superficie Direct3D valida dell&quot;evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Per riavviare il rendering, è necessario chiamare SetBackBuffer.       L&quot;elenco seguente mostra le impostazioni del buffer nascosto necessarie per il `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` o `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` campionamento multiplo è consentito su `IDirect3DSurface9Ex` copre solo."
  example:
  - "The following code example shows how to call the SetBackBuffer method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Il tipo di area Direct3D. Deve essere un valore valido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "La superficie Direct3D da assegnare come buffer nascosto."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> non è stato bloccato da una chiamata al <> </> *> o <> </> *> metodi."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>backBufferType</code>non è un valido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "I parametri di creazione per <code> backBuffer </code> non soddisfano i requisiti per il <code> backBufferType </code>- o -il <code> backBuffer </code> dispositivo non è valido."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Assegna una superficie Direct3D come origine del buffer nascosto."
  remarks: "Quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>overload o chiamare l&quot;overload SetBackBuffer il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando il front buffer non è più disponibile e viene visualizzato nulla.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento per notificare all&quot;applicazione WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>riavviare il rendering con una superficie Direct3D valida dell&quot;evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Per riavviare il rendering, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Quando si chiama SetBackBuffer con il `enableSoftwareFallback` parametro impostato su `true`, il sistema di rendering mantiene il relativo riferimento al buffer nascosto quando il front buffer non è disponibile, in modo non è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando il buffer anteriore sarà nuovamente disponibile.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Potrebbero verificarsi situazioni in cui il dispositivo dell&quot;utente non è più disponibile.  In questo caso, chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>per rilasciare il riferimento di WPF al buffer nascosto.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Per reimpostare il dispositivo, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>con `backBuffer` impostato su `null`e quindi chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>con `backBuffer` impostato su una superficie Direct3D valida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       L&quot;elenco seguente mostra le impostazioni del buffer nascosto necessarie per il `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` o `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` campionamento multiplo è consentito su `IDirect3DSurface9Ex` copre solo."
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Il tipo di area Direct3D. Deve essere un valore valido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "La superficie Direct3D da assegnare come buffer nascosto."
    - id: enableSoftwareFallback
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>eseguire il fallback sul rendering software. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  id: TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tenta di bloccare il <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e attende il periodo di tempo specificato."
  syntax:
    content: public bool TryLock (System.Windows.Duration timeout);
    parameters:
    - id: timeout
      type: System.Windows.Duration
      description: "La durata di attesa del blocco da acquisire."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se è stato acquisito il blocco; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.TryLock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>è impostato su <xref:System.Windows.Duration.Automatic*>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il conteggio dei blocchi è uguale a <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Unlock
  id: Unlock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Decrementa il conteggio dei blocchi per il <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Quando il conteggio dei blocchi per il <xref:System.Windows.Interop.D3DImage>raggiunge lo zero, il <xref:System.Windows.Interop.D3DImage>è completamente sbloccato.</xref:System.Windows.Interop.D3DImage> </xref:System.Windows.Interop.D3DImage> Il <xref:System.Windows.Interop.D3DImage>è contrassegnato per il rendering se l&quot;immagine è stata modificata aree che sono state specificate tramite le precedenti chiamate al <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>metodo.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> </xref:System.Windows.Interop.D3DImage>       Quando vengono eseguito il commit delle modifiche e il rendering viene eseguito, eventuali chiamate aggiuntive dal <xref:System.Windows.Interop.D3DImage.Lock%2A>blocco di metodo fino a quando il thread di rendering è copiato il contenuto del buffer nascosto nel front buffer.</xref:System.Windows.Interop.D3DImage.Lock%2A> Questa sincronizzazione è possibile evitare gli elementi di visualizzazione, ad esempio di rimozione.      > [!NOTE] > Non aggiornare l&quot;area di Direct3D durante il <xref:System.Windows.Interop.D3DImage>è sbloccato.</xref:System.Windows.Interop.D3DImage>"
  example:
  - "The following code example shows how to call the Unlock method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Unlock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Unlock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Width
  id: Width
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ottiene la larghezza di <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Il valore della larghezza può cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Width { get; }
    return:
      type: System.Double
      description: "La larghezza del <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, nell&quot;unità di misura. Un&quot;unità di misura è 1/96 di pollice."
  overload: System.Windows.Interop.D3DImage.Width*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.ImageSource
  isExternal: false
  name: System.Windows.Media.ImageSource
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Interop.D3DImage.#ctor
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
- uid: System.Windows.Int32Rect
  parent: System.Windows
  isExternal: false
  name: Int32Rect
  nameWithType: Int32Rect
  fullName: System.Windows.Int32Rect
- uid: System.Windows.Interop.D3DImage.Clone
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
- uid: System.Windows.Interop.D3DImage
  parent: System.Windows.Interop
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
- uid: System.Windows.Freezable
  parent: System.Windows
  isExternal: false
  name: Freezable
  nameWithType: Freezable
  fullName: System.Windows.Freezable
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
- uid: System.Windows.Media.Imaging.BitmapSource
  parent: System.Windows.Media.Imaging
  isExternal: false
  name: BitmapSource
  nameWithType: BitmapSource
  fullName: System.Windows.Media.Imaging.BitmapSource
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
- uid: System.Windows.Interop.D3DImage.Finalize
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.Height
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Interop.D3DImage.Lock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
- uid: System.Windows.Interop.D3DImage.Metadata
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
- uid: System.Windows.Media.ImageMetadata
  parent: System.Windows.Media
  isExternal: false
  name: ImageMetadata
  nameWithType: ImageMetadata
  fullName: System.Windows.Media.ImageMetadata
- uid: System.Windows.Interop.D3DImage.PixelHeight
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Interop.D3DImage.PixelWidth
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
- uid: System.Windows.Interop.D3DResourceType
  parent: System.Windows.Interop
  isExternal: false
  name: D3DResourceType
  nameWithType: D3DResourceType
  fullName: System.Windows.Interop.D3DResourceType
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
- uid: System.Windows.Duration
  parent: System.Windows
  isExternal: false
  name: Duration
  nameWithType: Duration
  fullName: System.Windows.Duration
- uid: System.Windows.Interop.D3DImage.Unlock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
- uid: System.Windows.Interop.D3DImage.Width
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
- uid: System.Windows.Interop.D3DImage.#ctor*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage.D3DImage
- uid: System.Windows.Interop.D3DImage.AddDirtyRect*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect
  nameWithType: D3DImage.AddDirtyRect
- uid: System.Windows.Interop.D3DImage.Clone*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone
  nameWithType: D3DImage.Clone
- uid: System.Windows.Interop.D3DImage.CloneCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore
  nameWithType: D3DImage.CloneCore
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue
  nameWithType: D3DImage.CloneCurrentValue
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore
  nameWithType: D3DImage.CloneCurrentValueCore
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer
  nameWithType: D3DImage.CopyBackBuffer
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore
  nameWithType: D3DImage.CreateInstanceCore
- uid: System.Windows.Interop.D3DImage.Finalize*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize
  nameWithType: D3DImage.Finalize
- uid: System.Windows.Interop.D3DImage.FreezeCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore
  nameWithType: D3DImage.FreezeCore
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore
  nameWithType: D3DImage.GetAsFrozenCore
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore
- uid: System.Windows.Interop.D3DImage.Height*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.Lock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock
  nameWithType: D3DImage.Lock
- uid: System.Windows.Interop.D3DImage.Metadata*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
- uid: System.Windows.Interop.D3DImage.PixelHeight*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
- uid: System.Windows.Interop.D3DImage.PixelWidth*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer
  nameWithType: D3DImage.SetBackBuffer
- uid: System.Windows.Interop.D3DImage.TryLock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock
  nameWithType: D3DImage.TryLock
- uid: System.Windows.Interop.D3DImage.Unlock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock
  nameWithType: D3DImage.Unlock
- uid: System.Windows.Interop.D3DImage.Width*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
