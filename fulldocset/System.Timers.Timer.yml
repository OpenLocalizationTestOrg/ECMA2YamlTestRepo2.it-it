### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "Genera un evento dopo un intervallo specificato, con un&quot;opzione per generare eventi ricorrenti.       Per esaminare il codice sorgente di .NET Framework per questo tipo, vedere il [origine riferimento](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)."
  remarks: "> [!NOTE]> Per visualizzare il codice sorgente di .NET Framework per questo tipo, vedere il [origine riferimento](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082). È possibile esplorare il codice sorgente online, scaricare i riferimenti per la visualizzazione offline e scorrere le origini (inclusi aggiornamenti e patch) durante l&quot;esecuzione del debug. vedere [istruzioni](http://referencesource.microsoft.com/).       Il componente Timer è un timer basate su server che genera un <xref:System.Timers.Timer.Elapsed>eventi dell&quot;applicazione dopo il numero di millisecondi di <xref:System.Timers.Timer.Interval%2A>proprietà trascorsa.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> È possibile configurare l&quot;oggetto Timer per generare l&quot;evento solo una o più volte utilizzando la <xref:System.Timers.Timer.AutoReset%2A>proprietà.</xref:System.Timers.Timer.AutoReset%2A> In genere, viene dichiarato un oggetto Timer a livello di classe in modo che rimanga nell&quot;ambito fino a quando necessario. È quindi possibile gestire il <xref:System.Timers.Timer.Elapsed>evento per fornire l&quot;elaborazione normale.</xref:System.Timers.Timer.Elapsed> Ad esempio, si supponga un server critico che deve rimanere in esecuzione 24 ore su 24, 7 giorni a settimana. È possibile creare un servizio che utilizza un oggetto Timer per verificare periodicamente il server e verificare che il sistema sia in esecuzione. Se il sistema non risponde, il servizio tenterà di riavviare il server o un amministratore di notifica.      > [!IMPORTANT] > Il Timer (classe) è disponibile in .NET Framework solo. Non è incluso nella libreria Standard di .NET e non è disponibile su altre piattaforme, ad esempio .NET Core o la piattaforma Windows universale. Su queste piattaforme, nonché per la portabilità in tutte le piattaforme .NET, è consigliabile utilizzare la <xref:System.Threading.Timer?displayProperty=fullName>classe invece.</xref:System.Threading.Timer?displayProperty=fullName>       Questo tipo implementa il <xref:System.IDisposable>interfaccia.</xref:System.IDisposable> Dopo aver utilizzando il tipo, è necessario eliminarlo di esso direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A>metodo in un `try` / `catch` blocco.</xref:System.IDisposable.Dispose%2A> Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio, ad esempio `using` (in c#) o `Using` (in Visual Basic). Per ulteriori informazioni, vedere la sezione &quot;Utilizzo di oggetti che implementano IDisposable&quot; nel <xref:System.IDisposable>argomento relativo all&quot;interfaccia.</xref:System.IDisposable>       La classe di Timer basate su server è progettata per l&quot;utilizzo con thread di lavoro in un ambiente con multithreading. Timer server possono spostarsi tra i thread per gestire l&quot;eccezione generata <xref:System.Timers.Timer.Elapsed>evento, precisione maggiore dei timer di Windows nella generazione dell&quot;evento nel tempo.</xref:System.Timers.Timer.Elapsed>       Il componente Timer genera il <xref:System.Timers.Timer.Elapsed>evento, in base al valore (in millisecondi) del <xref:System.Timers.Timer.Interval%2A>proprietà.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> È possibile gestire questo evento per eseguire l&quot;elaborazione che è necessario. Ad esempio, si supponga di disporre di un&quot;applicazione di vendita online che inserisce continuamente ordini di vendita in un database. Il servizio che compila le istruzioni per la spedizione opera su un batch di ordini anziché elaborare individualmente ogni ordine. È possibile utilizzare un Timer per avviare l&quot;elaborazione di ogni 30 minuti del batch.      > [!IMPORTANT] > System.Timers.Timer la classe è la stessa risoluzione l&quot;orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed>viene generato l&quot;evento a un intervallo definito per la risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A>proprietà è minore rispetto alla risoluzione del clock di sistema.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Per ulteriori informazioni, vedere il <xref:System.Timers.Timer.Interval%2A>proprietà.</xref:System.Timers.Timer.Interval%2A>       Quando <xref:System.Timers.Timer.AutoReset%2A>è impostato su `false`, genera un oggetto Timer il <xref:System.Timers.Timer.Elapsed>evento una sola volta, dopo il primo <xref:System.Timers.Timer.Interval%2A>trascorsa.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> Per continuare a generare il <xref:System.Timers.Timer.Elapsed>eventi regolarmente in base all&quot;intervallo definito dal <xref:System.Timers.Timer.Interval%2A>, impostare <xref:System.Timers.Timer.AutoReset%2A>per `true`, ovvero il valore predefinito.</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Il componente Timer intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed>evento.</xref:System.Timers.Timer.Elapsed> Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework. Si noti tuttavia che ciò non vale per i gestori di eventi che eseguire in modo asincrono e includono il `await` (operatore) (in c#) o `Await` (operatore) (in Visual Basic). Le eccezioni generate in questi gestori eventi vengono propagate nel thread chiamante, come illustrato nell&quot;esempio seguente. Per ulteriori informazioni sulle eccezioni generate nei metodi asincroni, vedere [eccezioni](~/add/includes/ajax-current-ext-md.md).       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ] se il <xref:System.Timers.Timer.SynchronizingObject%2A>proprietà `null`, <xref:System.Timers.Timer.Elapsed>evento viene generato in un <xref:System.Threading.ThreadPool>thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   Se l&quot;elaborazione dei <xref:System.Timers.Timer.Elapsed>evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l&quot;evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool>thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> In questo caso, il gestore dell&quot;evento deve essere rientrante.      > [!NOTE] > Il metodo di gestione degli eventi può essere eseguito su un singolo thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A>metodo o imposta il <xref:System.Timers.Timer.Enabled%2A>proprietà `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed>dell&quot;evento dopo l&quot;arresto del timer.</xref:System.Timers.Timer.Elapsed> Nell&quot;esempio di codice per il <xref:System.Timers.Timer.Stop%2A>metodo illustrato un modo per evitare la race condition.</xref:System.Timers.Timer.Stop%2A>       Anche se <xref:System.Timers.Timer.SynchronizingObject%2A>non `null`, <xref:System.Timers.Timer.Elapsed>gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A>o <xref:System.Timers.Timer.Stop%2A>metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A>è impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed>evento è sempre in coda per l&quot;esecuzione in un pool di thread.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> Un modo per risolvere questa condizione di competizione consiste nell&quot;impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed>evento ignori gli eventi successivi.</xref:System.Timers.Timer.Elapsed>       Se si usa la classe Timer con un elemento dell&quot;interfaccia utente, ad esempio un form o controllo, senza inserire il timer su tale elemento dell&quot;interfaccia utente, assegnare il form o controllo che contiene il Timer per il <xref:System.Timers.Timer.SynchronizingObject%2A>proprietà, in modo che l&quot;evento viene sottoposto a marshalling al thread dell&quot;interfaccia utente.</xref:System.Timers.Timer.SynchronizingObject%2A>       Per un elenco di valori predefiniti delle proprietà per un&quot;istanza di Timer, vedere il <xref:System.Timers.Timer.%23ctor%2A>costruttore.</xref:System.Timers.Timer.%23ctor%2A>      > [!TIP] > Tenere presente che la libreria di classi .NET Framework include quattro classi denominate `Timer`, ognuna di che offre funzionalità diverse: >>-Timer (in questo argomento): viene generato un evento a intervalli regolari. La classe è destinata all&quot;utilizzo come basato su server o il componente del servizio in un ambiente con multithreading non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.   >- <xref:System.Threading.Timer?displayProperty=fullName>: esegue un metodo di callback singolo in un pool di thread a intervalli regolari.</xref:System.Threading.Timer?displayProperty=fullName> Il metodo di callback viene definito quando il timer viene creata un&quot;istanza e non può essere modificato. Analogamente alla classe Timer, questa classe è destinata come basato su server o un componente di servizio in un ambiente con multithreading non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.   >- <xref:System.Windows.Forms.Timer?displayProperty=fullName>: un componente di Windows Form che genera un evento a intervalli regolari.</xref:System.Windows.Forms.Timer?displayProperty=fullName> Il componente non dispone di alcuna interfaccia utente e viene progettato per l&quot;uso in un ambiente a thread singolo.   >- <xref:System.Web.UI.Timer?displayProperty=fullName>: un componente ASP.NET che esegue i postback asincroni o sincroni di pagina web a intervalli regolari.</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Timers.Timer&quot;> </xref> classe e imposta tutte le proprietà sui rispettivi valori iniziali."
  remarks: "La tabella seguente illustra i valori di proprietà iniziali per un&quot;istanza di <xref:System.Timers.Timer>.</xref:System.Timers.Timer>      | Proprietà | Il valore iniziale |   |--------------|-------------------|   | <xref:System.Timers.Timer.AutoReset%2A>| `true`|   | <xref:System.Timers.Timer.Enabled%2A>| `false`|   | <xref:System.Timers.Timer.Interval%2A>|&100; millisecondi |   | <xref:System.Timers.Timer.SynchronizingObject%2A>| Un riferimento null (`Nothing` in Visual Basic). |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Timers.Timer&quot;> </xref> classe e imposta il <xref:System.Timers.Timer.Interval*>proprietà al numero specificato di millisecondi.</xref:System.Timers.Timer.Interval*>"
  remarks: "Questo costruttore imposta la <xref:System.Timers.Timer.Interval%2A>proprietà della nuova istanza di timer, ma non abilita il timer.</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "Tempo, in millisecondi, tra gli eventi. Il valore deve essere maggiore di zero e minore o uguale a &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il valore di <code> interval </code> parametro è minore o uguale a zero oppure maggiore di &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Ottiene o imposta un valore booleano che indica se il <xref href=&quot;System.Timers.Timer&quot;> </xref> deve generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento una sola volta (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) o più volte (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)."
  remarks: "Se il <xref:System.Timers.Timer>è già abilitata quando il <xref:System.Timers.Timer.Start%2A>metodo viene chiamato, l&quot;intervallo viene reimpostato.</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> Se è AutoReset `false`, <xref:System.Timers.Timer.Start%2A>metodo deve essere chiamato per riavviare il conteggio.</xref:System.Timers.Timer.Start%2A>       Reimpostare l&quot;intervallo interessa quando il <xref:System.Timers.Timer.Elapsed>viene generato l&quot;evento.</xref:System.Timers.Timer.Elapsed> Ad esempio, se si imposta l&quot;intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A>proprietà `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A>è impostata.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Se l&quot;intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed>evento viene generato per la prima volta 13 secondi dopo il <xref:System.Timers.Timer.Enabled%2A>è stata impostata su `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il <xref href=&quot;System.Timers.Timer&quot;> </xref> deve generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento ogni volta che l&quot;intervallo scade; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se deve generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento solo una volta, dopo la prima volta l&quot;intervallo scade. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Avvia l&quot;inizializzazione in fase di esecuzione di un <xref href=&quot;System.Timers.Timer&quot;> </xref> utilizzato in un form o da un altro componente."
  remarks: "Il [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] ambiente di progettazione questo metodo per avviare l&quot;inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.EndInit%2A>metodo termina l&quot;inizializzazione.</xref:System.Timers.Timer.EndInit%2A> Utilizzo di BeginInit e <xref:System.Timers.Timer.EndInit%2A>metodi impedisce il controllo venga utilizzato prima che il completamento dell&quot;inizializzazione.</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Rilascia le risorse usate dal <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  remarks: "Il metodo Close chiama a sua volta il `Dispose` metodo."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Rilascia tutte le risorse usate dall&quot;oggetto corrente <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>per rilasciare le risorse gestite e non gestite. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> per rilasciare solo le risorse non gestite."
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "Si verifica quando l&quot;intervallo scade."
  remarks: "Se viene generato l&quot;evento Elapsed il <xref:System.Timers.Timer.Enabled%2A>proprietà `true` e l&quot;intervallo di tempo (in millisecondi) definito dal <xref:System.Timers.Timer.Interval%2A>proprietà trascorre.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> Se il <xref:System.Timers.Timer.AutoReset%2A>proprietà `true`, l&quot;evento viene generato ripetutamente in un intervallo definito dal <xref:System.Timers.Timer.Interval%2A>proprietà; in caso contrario, l&quot;evento viene generato una sola volta, la prima volta il <xref:System.Timers.Timer.Interval%2A>valore allo scadere dell&quot;intervallo.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       Se <xref:System.Timers.Timer.Interval%2A>viene impostato dopo la <xref:System.Timers.Timer>è avviato, il conteggio viene reimpostato.</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> Ad esempio, se si imposta l&quot;intervallo di 5 secondi e quindi impostare <xref:System.Timers.Timer.Enabled%2A>a `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A>è impostata.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Se l&quot;intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, l&quot;evento Elapsed viene generato per la prima volta 13 secondi dopo che <xref:System.Timers.Timer.Enabled%2A>è stato impostato su `true`.</xref:System.Timers.Timer.Enabled%2A>       Se il <xref:System.Timers.Timer.SynchronizingObject%2A>proprietà `null`, viene generato l&quot;evento Elapsed su un <xref:System.Threading.ThreadPool>thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> Se l&quot;elaborazione dell&quot;evento trascorso dura più a lungo rispetto a <xref:System.Timers.Timer.Interval%2A>, l&quot;evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool>thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> In questo caso, il gestore dell&quot;evento deve essere rientrante.      > [!NOTE] > Il metodo di gestione degli eventi può essere eseguito su un singolo thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A>metodo o imposta il <xref:System.Timers.Timer.Enabled%2A>proprietà `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Ciò potrebbe comportare la generazione dell&quot;evento trascorso dopo l&quot;arresto del timer. Nell&quot;esempio di codice per il <xref:System.Timers.Timer.Stop%2A>metodo illustrato un modo per evitare la race condition.</xref:System.Timers.Timer.Stop%2A>       Anche se <xref:System.Timers.Timer.SynchronizingObject%2A>non `null`, eventi Elapsed possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A>o <xref:System.Timers.Timer.Stop%2A>metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A>è impostata su `false`, poiché il segnale per generare l&quot;evento Elapsed è sempre in coda per l&quot;esecuzione in un pool di thread.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> Un modo per risolvere questa race condition è impostare un flag che indica il gestore eventi per l&quot;evento Elapsed ignori gli eventi successivi.       Il <xref:System.Timers.Timer>componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per l&quot;evento Elapsed.</xref:System.Timers.Timer> Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework."
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Ottiene o imposta un valore che indica se il <xref href=&quot;System.Timers.Timer&quot;> </xref> deve generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento."
  remarks: "Impostare Enabled su `true` equivale a chiamare il metodo <xref:System.Timers.Timer.Start%2A>, mentre l&quot;impostazione è abilitata per `false` è equivalente alla chiamata <xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Start%2A>      > [!NOTE] > Il segnale per generare il <xref:System.Timers.Timer.Elapsed>evento sempre in coda per l&quot;esecuzione in un <xref:System.Threading.ThreadPool>thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed>evento generato dopo che la proprietà Enabled è impostata su `false`.</xref:System.Timers.Timer.Elapsed> L&quot;esempio di codice per il <xref:System.Timers.Timer.Stop%2A>metodo illustrato un modo per aggirare questa race condition.</xref:System.Timers.Timer.Stop%2A>       Se Enabled è impostato su `true` e <xref:System.Timers.Timer.AutoReset%2A>è impostato su `false`, <xref:System.Timers.Timer>Genera il <xref:System.Timers.Timer.Elapsed>evento solo una volta, la prima volta l&quot;intervallo scade.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Se l&quot;intervallo viene impostato dopo la <xref:System.Timers.Timer>è avviato, il conteggio viene reimpostato.</xref:System.Timers.Timer> Ad esempio, se si imposta l&quot;intervallo di 5 secondi e quindi imposta la proprietà Enabled `true`, il conteggio inizia al momento abilitato è impostata. Se l&quot;intervallo viene reimpostato su 10 secondi quando count è 3 secondi, il <xref:System.Timers.Timer.Elapsed>evento viene generato per la prima volta 13 secondi dopo che è stato impostato su abilitato `true`.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Alcune finestre di progettazione, ad esempio quelle in Microsoft Visual Studio, impostare la proprietà Enabled `true` durante l&quot;inserimento di un nuovo <xref:System.Timers.Timer>.</xref:System.Timers.Timer>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il <xref href=&quot;System.Timers.Timer&quot;> </xref> deve generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento; in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Non impostare questa proprietà perché il timer è stato eliminato."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Il <xref:System.Timers.Timer.Interval*>è stata impostata su un valore maggiore di &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; prima che il timer è stato abilitato.</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Termina l&quot;inizializzazione in fase di esecuzione di un <xref href=&quot;System.Timers.Timer&quot;> </xref> utilizzato in un form o da un altro componente."
  remarks: "Il [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] ambiente di progettazione questo metodo per terminare l&quot;inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.BeginInit%2A>metodo avvia l&quot;inizializzazione.</xref:System.Timers.Timer.BeginInit%2A> Utilizzo di <xref:System.Timers.Timer.BeginInit%2A>EndInit metodi e impedisce il controllo venga utilizzato prima che il completamento dell&quot;inizializzazione.</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Ottiene o imposta l&quot;intervallo, espresso in millisecondi, in cui generare il <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento."
  remarks: "Utilizzare la proprietà di intervallo per determinare la frequenza con cui il <xref:System.Timers.Timer.Elapsed>viene generato l&quot;evento.</xref:System.Timers.Timer.Elapsed> Poiché la <xref:System.Timers.Timer>classe dipende dall&quot;orologio di sistema, ha la stessa risoluzione l&quot;orologio di sistema.</xref:System.Timers.Timer> Ciò significa che il <xref:System.Timers.Timer.Elapsed>a un intervallo definito per la risoluzione del clock di sistema se la proprietà Interval è inferiore rispetto alla risoluzione del clock di sistema viene generato l&quot;evento.</xref:System.Timers.Timer.Elapsed> Nell&quot;esempio seguente imposta la proprietà dell&quot;intervallo di 5 millisecondi. Quando viene eseguito un [!INCLUDE[win7](~/add/includes/win7-md.md)] sistema il cui orologio di sistema con una risoluzione di circa 15 millisecondi, viene generato l&quot;evento circa ogni 15 millisecondi anziché ogni 5 millisecondi.       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ] è possibile utilizzare il codice seguente per determinare la risoluzione del clock di sistema nel sistema corrente: [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ] se l&quot;applicazione richiede la risoluzione maggiore rispetto a quello offerto dalla <xref:System.Timers.Timer>classe o l&quot;orologio di sistema, utilizzare i timer multimediali ad alta risoluzione, vedere [procedura: utilizzare il Timer ad alta risoluzione](http://msdn.microsoft.com/library/aa964692.aspx).</xref:System.Timers.Timer>           Se l&quot;intervallo viene impostato dopo la <xref:System.Timers.Timer>è avviato, il conteggio viene reimpostato.</xref:System.Timers.Timer> Ad esempio, se si imposta l&quot;intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A>proprietà `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A>è impostata.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Se l&quot;intervallo viene reimpostato su 10 secondi quando count è 3 secondi, il <xref:System.Timers.Timer.Elapsed>evento viene generato per la prima volta 13 secondi dopo che <xref:System.Timers.Timer.Enabled%2A>è stato impostato su `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       Se <xref:System.Timers.Timer.Enabled%2A>è impostato su `true` e <xref:System.Timers.Timer.AutoReset%2A>è impostato su `false`, <xref:System.Timers.Timer>Genera il <xref:System.Timers.Timer.Elapsed>evento solo una volta, la prima volta l&quot;intervallo scade.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>viene quindi impostato su `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Se <xref:System.Timers.Timer.Enabled%2A>e <xref:System.Timers.Timer.AutoReset%2A>sono impostati entrambi su `false`, e il timer in precedenza abilitato, l&quot;impostazione della proprietà di intervallo causa il <xref:System.Timers.Timer.Elapsed>dell&quot;evento una volta, come se il <xref:System.Timers.Timer.Enabled%2A>era impostata su `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> Per impostare l&quot;intervallo senza la generazione dell&quot;evento, è possibile impostare temporaneamente il <xref:System.Timers.Timer.Enabled%2A>proprietà `true`, impostare la proprietà Interval all&quot;intervallo di tempo desiderato e quindi impostare immediatamente il <xref:System.Timers.Timer.Enabled%2A>proprietà nuovamente a `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "Il tempo, in millisecondi, tra <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> eventi. Il valore deve essere maggiore di zero e minore o uguale a &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;. Il valore predefinito è 100 millisecondi."
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "L&quot;intervallo è minore o uguale a zero.       L&quot;intervallo è maggiore di - oppure - &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;, e il timer è attualmente abilitato. (Se il timer non è attualmente abilitato, viene generata alcuna eccezione fino a quando non sarà abilitata.)"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Ottiene o imposta il sito che associa il <xref href=&quot;System.Timers.Timer&quot;> </xref> al contenitore in modalità progettazione."
  remarks: "Siti associano un <xref:System.ComponentModel.Component>per un <xref:System.ComponentModel.Container>e abilitare la comunicazione tra di essi, nonché fornendo un modo per il contenitore gestire i relativi componenti.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "Un <xref href=&quot;System.ComponentModel.ISite&quot;> </xref> interfaccia che rappresenta il sito che associa il <xref href=&quot;System.Timers.Timer&quot;> </xref> oggetto al contenitore."
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Avvia la generazione di <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento impostando <xref:System.Timers.Timer.Enabled*>a <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Se viene chiamato l&quot;inizio e <xref:System.Timers.Timer.AutoReset%2A>è impostato su `false`, <xref:System.Timers.Timer>Genera il <xref:System.Timers.Timer.Elapsed>evento solo una volta, la prima volta l&quot;intervallo scade.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> Se viene chiamata iniziale e <xref:System.Timers.Timer.AutoReset%2A>è `true`, <xref:System.Timers.Timer>Genera il <xref:System.Timers.Timer.Elapsed>ora il primo evento, l&quot;intervallo scade e continua a generare l&quot;evento nell&quot;intervallo specificato.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       È inoltre possibile avviare intervallo impostando <xref:System.Timers.Timer.Enabled%2A>a `true`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Se <xref:System.Timers.Timer.AutoReset%2A>è `false`, deve essere chiamato il metodo Start per avviare nuovamente il conteggio.</xref:System.Timers.Timer.AutoReset%2A>       Una chiamata al metodo di avvio quando è abilitato il timer non ha effetto."
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il <xref href=&quot;System.Timers.Timer&quot;> </xref> viene creato con un intervallo maggiore o uguale a &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1 oppure impostarlo su un intervallo minore di zero."
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Arresta la generazione di <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> evento impostando <xref:System.Timers.Timer.Enabled*>a <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "È anche possibile terminare la temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A>a `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Il segnale per generare il <xref:System.Timers.Timer.Elapsed>evento sempre in coda per l&quot;esecuzione in un <xref:System.Threading.ThreadPool>thread, pertanto il metodo di gestione degli eventi può essere eseguito su un singolo thread allo stesso tempo che una chiamata al metodo di arresto viene eseguito in un altro thread.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed>evento generato dopo che viene chiamato il metodo di arresto.</xref:System.Timers.Timer.Elapsed> Nell&quot;esempio di codice nella sezione successiva viene illustrato un modo per aggirare questa race condition."
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Ottiene o imposta l&quot;oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza è trascorso un intervallo."
  remarks: "Quando SynchronizingObject è `null`, il metodo che gestisce il <xref:System.Timers.Timer.Elapsed>eventi viene chiamato su un thread dal pool di thread del sistema.</xref:System.Timers.Timer.Elapsed> Per ulteriori informazioni sui pool di thread di sistema, vedere <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando il <xref:System.Timers.Timer.Elapsed>evento è gestito da un componente di Windows Form visivo, ad esempio un pulsante, l&quot;accesso al componente tramite il pool di thread del sistema potrebbe essere il risultato di un&quot;eccezione o semplicemente potrebbero non funzionare.</xref:System.Timers.Timer.Elapsed> Per evitare questo effetto impostando SynchronizingObject su un componente di Windows Form, che determina il metodo che gestisce il <xref:System.Timers.Timer.Elapsed>sullo stesso thread che il componente è stato creato l&quot;evento.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Anche se la proprietà SynchronizingObject non è `null`, <xref:System.Timers.Timer.Elapsed>gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A>o <xref:System.Timers.Timer.Stop%2A>metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A>è impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed>evento è sempre in coda per l&quot;esecuzione in un pool di thread.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> Un modo per risolvere questa condizione di competizione consiste nell&quot;impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed>evento ignori gli eventi successivi.</xref:System.Timers.Timer.Elapsed>       Se il <xref:System.Timers.Timer>viene utilizzato all&quot;interno di Visual Studio in una finestra di progettazione Windows Form, SynchronizingObject viene impostata automaticamente al controllo che contiene il <xref:System.Timers.Timer>.</xref:System.Timers.Timer> </xref:System.Timers.Timer> Ad esempio, se si inserisce un <xref:System.Timers.Timer>in una finestra di progettazione per `Form1` (che eredita da <xref:System.Windows.Forms.Form>), la proprietà SynchronizingObject di <xref:System.Timers.Timer>è impostato per l&quot;istanza di `Form1`.</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "Il <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> che rappresenta l&quot;oggetto utilizzato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo. Il valore predefinito è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
