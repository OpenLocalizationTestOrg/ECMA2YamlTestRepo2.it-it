### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Fornisce un&quot;interfaccia generica in una sequenza di record."
  remarks: "L&quot;interfaccia IRecordSequence fornisce un&quot;interfaccia astratta a un flusso orientato ai record. Un&quot;istanza di IRecordSequence consente di leggere e scrivere i record del log.       L&quot;interfaccia IRecordSequence offre le funzionalità seguenti: aggiungere log registra l&quot;utilizzo di <xref:System.IO.Log.IRecordSequence.Append%2A>metodi.</xref:System.IO.Log.IRecordSequence.Append%2A>      -Leggere i record accodati utilizzando il <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -Scrivere un record di riavvio speciale utilizzando il <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metodo.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Lettura record di riavvio dall&quot;utilizzando record di riavvio scritta più recentemente il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -Scaricare i record dell&quot;archivio durevole utilizzando il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Riservare spazio per l&quot;aggiunta di record.      -Libera spazio anticipando la base del log.      -Ricezione <xref:System.IO.Log.IRecordSequence.TailPinned>le notifiche degli eventi per spostare la base del log per liberare spazio.</xref:System.IO.Log.IRecordSequence.TailPinned>       Record di log vengono aggiunti a un&quot;istanza di IRecordSequence e ogni record di log viene assegnato un numero di sequenza univoco. Numeri di sequenza sono a incremento progressivo costante all&quot;interno di una sequenza di record specificato. Un record di log è costituito da dati opachi, forniti all&quot;istanza di IRecordSequence in un <xref:System.Collections.IList>di ArraySegments di byte.</xref:System.Collections.IList>       L&quot;interfaccia IRecordSequence espone anche alcune proprietà di base che fornisce informazioni sui limiti del log.      -La <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>proprietà contiene il numero di sequenza del primo record valido nella sequenza di record.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -La <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>proprietà contiene un numero di sequenza è garantito che siano maggiori rispetto al numero di sequenza dell&quot;ultimo record accodato.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -La <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>proprietà contiene il numero di sequenza dell&quot;ultima area di riavvio scritta.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -La <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>proprietà contiene la dimensione del record più grande che può essere aggiunto a o letto dalla sequenza.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -La <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>proprietà contiene la dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Se il <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>è impostata su `true`e un <xref:System.IO.Log.IRecordSequence.Append%2A>operazione non riesce perché non è disponibile spazio nella sequenza, la sequenza di record tenterà di liberare spazio, quindi ripetere l&quot;operazione di Accodamento.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Sposta in avanti il numero di sequenza di base del log."
  remarks: "Quando si utilizza un <xref:System.IO.Log.LogRecordSequence>istanza e tenta di anticipare il numero di sequenza per liberare spazio nel log, il nuovo numero di sequenza di base deve risiedere in un extent del log diverso per l&quot;extent precedente venga contrassegnato come vuoto.</xref:System.IO.Log.LogRecordSequence> Non è possibile liberare extent parzialmente."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nuovo numero di sequenza di base della sequenza di record."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>non è valido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>non è attivo nel log."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la modifica della sequenza."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record è completa."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un record di log per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, accoda un record di log per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, accoda un record di log per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizzando spazio precedentemente riservato nella sequenza."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Il record accodato utilizzerà spazio precedentemente riservato utilizzando una prenotazione specificata per il `reservations` parametro. Se l&quot;accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell &quot; area verrà rimossa dalla raccolta.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione che deve essere utilizzata per questo record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, accoda un record di log per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizzando spazio precedentemente riservato nella sequenza."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Il record accodato utilizzerà spazio precedentemente riservato utilizzando una prenotazione specificata per il `reservations` parametro. Se l&quot;accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell &quot; area verrà rimossa dalla raccolta.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione che deve essere utilizzata per questo record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza del primo record valido nell&quot;oggetto <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Numeri di sequenza validi sono maggiori di o uguale al valore BaseSequenceNumber e minore di <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       Il valore di questa proprietà può essere modificato chiamando il <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metodo.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza più basso che corrisponde a un record valido nel <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia asincrono operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione di Accodamento asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia asincrona utilizzando spazio precedentemente riservato nella sequenza di operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione di Accodamento asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia asincrona utilizzando spazio precedentemente riservato nella sequenza di operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Il record accodato utilizzerà spazio precedentemente riservato utilizzando una prenotazione specificata per il `reservations` parametro. Se l&quot;accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell &quot; area verrà rimossa dalla raccolta.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione che deve essere utilizzata per questo record."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione di Accodamento asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia asincrona utilizzando spazio precedentemente riservato nella sequenza di operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Il record accodato utilizzerà spazio precedentemente riservato utilizzando una prenotazione specificata per il `reservations` parametro. Se l&quot;accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell &quot; area verrà rimossa dalla raccolta.       In genere, questo metodo viene completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione che deve essere utilizzata per questo record."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione di Accodamento asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia un&quot;operazione di scaricamento asincrona utilizzando spazio precedentemente riservato nella sequenza."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito dal metodo corrente per il <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metodo per assicurarsi che lo scaricamento venga completato e le risorse vengano liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Se si verifica un errore durante un&quot;operazione di scaricamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       Chiamare questo metodo garantisce che tutti i record che sono stati accodati per il <xref:System.IO.Log.IRecordSequence>sono scritti in modo durevole.</xref:System.IO.Log.IRecordSequence>       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di scaricamento asincrono, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza dell&quot;ultimo record che deve essere scritto. Se questo <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> non è valido, devono essere scritti tutti i record."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando lo scaricamento è stato completato."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica richiesta di scaricamento asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione di scaricamento asincrono, che potrebbe ancora essere in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante lo scaricamento dei dati."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia un&quot;asincrona di prenotazione e operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Le prenotazioni specificate vengono aggiunte alla prenotazione fornita insieme in un&quot;operazione atomica con un record di operazione di Accodamento. Se l&quot;operazione di accodamento non riesce, verrà riservato alcuno spazio.       In genere, questo metodo può essere completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Raccolta di prenotazioni di cui effettuare prenotazioni."
    - id: reservations
      type: System.Int64[]
      description: "Prenotazioni da fare, in byte."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record, oppure per la prenotazione."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia un&quot;asincrona di prenotazione e operazione di Accodamento."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo per assicurarsi che l&quot;operazione di accodamento è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un accodamento asincrono, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Le prenotazioni specificate vengono aggiunte alla prenotazione fornita insieme in un&quot;operazione atomica con un record di operazione di Accodamento. Se l&quot;operazione di accodamento non riesce, verrà riservato alcuno spazio.       In genere, questo metodo può essere completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Raccolta di prenotazioni di cui effettuare prenotazioni."
    - id: reservations
      type: System.Int64[]
      description: "Prenotazioni da fare, in byte."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando l&quot;accodamento è completo."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica asincrona di accodamento richiesta da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione asincrona, che può essere ancora in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record, oppure per la prenotazione."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia un&quot;operazione di scrittura asincrona riavvio area, utilizzando spazio precedentemente riservato nella sequenza."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>(metodo), per assicurare che l&quot;operazione di scrittura area di riavvio è stata completata e le risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un&quot;operazione di scrittura asincrona riavvio area, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Quando l&quot;operazione è stata completata correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili.       Se un <xref:System.IO.Log.ReservationCollection>viene specificato, l&quot;area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</xref:System.IO.Log.ReservationCollection> Se il metodo riesce, utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione da utilizzare per questa area di riavvio."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando la scrittura dell&quot;area di riavvio è stata completata."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa richiesta di scrittura area particolare riavvio asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione asincrona riavvio area scrittura, che potrebbe ancora essere in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, inizia un&quot;operazione di scrittura asincrona riavvio area, utilizzando spazio precedentemente riservato nella sequenza."
  remarks: "È necessario passare il <xref:System.IAsyncResult>restituito da questo metodo per il <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodo per assicurarsi che l&quot;operazione di scrittura area di riavvio è stata completata e risorse possono essere liberate in modo appropriato.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se si è verificato un errore durante un&quot;operazione di scrittura asincrona riavvio area, fino a quando non viene generata un&quot;eccezione di <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodo viene chiamato con il <xref:System.IAsyncResult>restituito da questo metodo.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Quando l&quot;operazione è stata completata correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili.       Se un <xref:System.IO.Log.ReservationCollection>viene specificato, l&quot;area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</xref:System.IO.Log.ReservationCollection> Se il metodo riesce, utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione da utilizzare per questa area di riavvio."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando la scrittura dell&quot;area di riavvio è stata completata."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa richiesta di scrittura area particolare riavvio asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Un <xref:System.IAsyncResult>che rappresenta l&quot;operazione asincrona riavvio area scrittura, che potrebbe ancora essere in sospeso.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, crea un nuovo <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "L&quot;oggetto appena creato <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, termina un&quot;asincrona operazione di Accodamento."
  remarks: "Questo metodo si blocca fino a quando non è stata completata l&quot;operazione dei / o. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, diventano visibili quando viene chiamato EndAppend.       Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>restituito dal <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>metodo.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Un riferimento alla richiesta dei / o asincrona in sospeso."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, termina un&quot;operazione di scaricamento asincrona."
  remarks: "Questo metodo si blocca fino a quando non è stata completata l&quot;operazione dei / o. Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta dei / o, diventano visibili quando viene chiamato EndFlush.       Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>restituito da di <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>metodo.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Un riferimento alla richiesta dei / o asincrona in sospeso."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza dell&quot;ultimo record scritto."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, termina un&quot;asincrona riserva e operazione di Accodamento."
  remarks: "Questo metodo si blocca fino a quando non è stata completata l&quot;operazione dei / o. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, diventano visibili quando viene chiamato EndReserveAndAppend.       Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>restituito dal <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>metodo.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Un riferimento alla richiesta dei / o asincrona in sospeso."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, termina un&quot;operazione di scrittura area di riavvio asincrona."
  remarks: "Questo metodo si blocca fino a quando non è stata completata l&quot;operazione dei / o. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, diventano visibili quando viene chiamato EndWriteRestartArea.       Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>restituito dal <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>metodo.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Un riferimento alla richiesta dei / o asincrona in sospeso."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log scritto."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, assicura che tutti i record accodati siano stati scritti."
  remarks: "Chiamare questo metodo garantisce che tutti i record che sono stati accodati per il <xref:System.IO.Log.IRecordSequence>sono stati scritti in modo durevole.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza dell&quot;ultimo record scritto."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante lo scaricamento dei dati."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, assicura che tutti i record aggiunti fino a e record con il numero di sequenza specificato incluso siano stati scritti in modo durevole."
  remarks: "Chiamare a che questo metodo garantisce che tutti i record con sequenza di numeri fino e il numero di sequenza specificato incluso siano stati scritti in modo durevole."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza dell&quot;ultimo record che deve essere scritto. Se questo <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> non è valido, devono essere scritti tutti i record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza dell&quot;ultimo record scritto."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante lo scaricamento dei dati."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza maggiore dell&quot;ultimo record accodato."
  remarks: "Questa proprietà contiene un numero di sequenza è garantito che siano maggiori rispetto al numero di sequenza dell&quot;ultimo record accodato. Numeri di sequenza validi sono maggiori di o uguale a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>e minore di LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > Quando si utilizza un&quot; <xref:System.IO.Log.LogRecordSequence>istanza, il <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>valore può diventare obsoleti fino a quando non vengono scaricati i record del log.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> Vedere <xref:System.IO.Log.IRecordSequence.Flush%2A>e <xref:System.IO.Log.RecordAppendOptions>Per ulteriori informazioni sullo scaricamento dei record...</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Una numero di sequenza maggiore dell&quot;ultimo record accodato."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, ottiene la dimensione del record più grande che può essere aggiunto alla sequenza o letto da questo, in byte."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Le dimensioni del record più grande che può essere aggiunto alla sequenza o letto da questo, in byte."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record nella sequenza."
  remarks: "Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record nella sequenza. L&quot;ordine dei record enumerati dipende dal valore del `logRecordEnum` parametro."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del primo record in cui viene avviata la lettura."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Un valido <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> valore che specifica il modo (vale a dire, Avanti o indietro) in cui i record devono essere letto da un <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Raccolta enumerabile di record nella sequenza."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la lettura del record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile delle aree di riavvio nella sequenza."
  remarks: "Le aree di riavvio sono enumerate in ordine inverso, ovvero dal numero di sequenza più alto al numero di sequenza più basso. Solo aree di riavvio con numeri di sequenza tra l&quot;ultimo numero di sequenza e il numero di sequenza di base vengono enumerati.      > [!NOTE] > Se l&quot;extent di log contenente il <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>diventa danneggiato, questo metodo può generare un <xref:System.IO.IOException>con il messaggio di errore &quot;non è stato possibile eseguire la richiesta a causa di un&quot;eccezione dei / o imprevista.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> È stato restituito il codice di errore seguente: &quot;80070026&quot; &quot;."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Raccolta enumerabile delle aree di riavvio nella sequenza."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la lettura del record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Sottoposto a override in una classe derivata, crea automaticamente una singola prenotazione e accoda un record alla sequenza."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Le prenotazioni specificate vengono aggiunte alla prenotazione fornita insieme in un&quot;operazione atomica con un record di operazione di Accodamento. Se l&quot;operazione di accodamento non riesce, verrà riservato alcuno spazio.       In genere, questo metodo può essere completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> che contiene la raccolta di cui effettuare prenotazioni."
    - id: reservations
      type: System.Int64[]
      description: "Prenotazioni da fare, in byte."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record, oppure per la prenotazione."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Sottoposto a override in una classe derivata, crea automaticamente una singola prenotazione e accoda un record alla sequenza."
  remarks: "Dati contenuti nel `data` parametro verrà concatenato in una matrice a singolo byte accodati come record. Tuttavia, non preveda per suddividere dati in segmenti della matrice quando viene letto il record.       Le prenotazioni specificate vengono aggiunte alla prenotazione fornita insieme in un&quot;operazione atomica con un record di operazione di Accodamento. Se l&quot;operazione di accodamento non riesce, verrà riservato alcuno spazio.       In genere, questo metodo può essere completato prima che il record è stato scritto. Per garantire che un record è stato scritto, specificare il <xref:System.IO.Log.RecordAppendOptions>flag utilizzando il `recordAppendOptions` parametro oppure chiamare il <xref:System.IO.Log.IRecordSequence.Flush%2A>metodo.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine specificato dall&quot;utente."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record successivo nell&quot;ordine precedente."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Un valore valido di <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> che specifica come scrivere i dati."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Raccolta di prenotazioni di cui effettuare prenotazioni."
    - id: reservations
      type: System.Int64[]
      description: "Prenotazioni da fare, in byte."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza del record del log accodato."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante l&quot;accodamento del record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere il nuovo record, oppure per la prenotazione."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, ottiene il numero totale di byte che sono stati riservati."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "Le dimensioni totali di tutte le prenotazioni effettuate in questa sequenza di record."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza dell&quot;area di riavvio scritta più recentemente."
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Area di riavvio il numero di sequenza di scritta più recentemente."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ottiene o imposta un valore che indica se viene aggiunto vengono ripetute automaticamente nel caso il registro è pieno."
  remarks: "Se il valore di questa proprietà è `true`e un <xref:System.IO.Log.IRecordSequence.Append%2A>chiamata ha esito negativo poiché non vi è spazio sufficiente nella sequenza, la sequenza di record tenterà di liberare spazio, quindi ripetere l&quot;operazione di Accodamento.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se aggiunge vengono ripetute automaticamente nel caso il registro è pieno. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "La proprietà è stata eseguita dopo che la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Si verifica quando la sequenza di record determina che la coda deve essere spostata in avanti."
  remarks: "Si può generare questo evento quando la sequenza di record ha esaurito lo spazio. Quando viene generato questo evento, la parte finale della sequenza (ovvero, il numero di sequenza di base) viene spostata in avanti per liberare spazio."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Da aggiungere."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Common Log File System (CLFS) gestisce che due aree di riavvio per garantire che almeno un&quot;area valida sia sempre disponibile. Quando è necessario un ripristino, CLFS legge l&quot;area di riavvio e tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino.       Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       I dati in segmenti della matrice di byte verranno concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino. Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       I dati in segmenti della matrice di byte verranno concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> e aggiorna il numero di sequenza di base"
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino. Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando viene scritta un&quot;area di riavvio, i dati in segmenti della matrice di byte vengono concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio.       Quando questo metodo viene completato correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> e aggiorna il numero di sequenza di base."
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino. Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando viene scritta un&quot;area di riavvio, i dati in segmenti della matrice di byte vengono concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio.       Quando questo metodo viene completato correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> utilizzando una prenotazione e aggiorna il numero di sequenza di base"
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino. Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando viene scritta un&quot;area di riavvio, i dati in segmenti della matrice di byte vengono concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio.       Se viene specificata una prenotazione, l&quot;area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se il metodo riesce, utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.       Quando questo metodo viene completato correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili.       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione da utilizzare per questa area di riavvio."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando sottoposto a override in una classe derivata, scrive un&quot;area di riavvio per il <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> utilizzando una prenotazione e aggiorna il numero di sequenza di base."
  remarks: "Un&quot;area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l&quot;ultima operazione di checkpoint del client. Quando è necessario un ripristino, è possibile analizzare l&quot;area di riavvio per recuperare tutti i dati dall&quot;ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e tabella del file aperto così da utilizzarle nel processo di ripristino. Un&quot;area di riavvio può essere letto utilizzando il <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metodo.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando viene scritta un&quot;area di riavvio, i dati in segmenti della matrice di byte vengono concatenati in una matrice a singolo byte accodati come record. Non viene effettuata per suddividere dati in segmenti della matrice quando viene letta l&quot;area di riavvio.       Se viene specificata una prenotazione, l&quot;area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se il metodo riesce, utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.       Quando questo metodo viene completato correttamente, il numero di sequenza di base è stato aggiornato. Tutti registro record con numeri di sequenza inferiori al nuovo numero di sequenza di base sono inaccessibili.       Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all&quot;interno di questa operazione. Gli errori verificatisi durante una richiesta di Accodamento asincrona, ad esempio, un errore del disco durante una richiesta dei / o, comporterà un&quot;eccezione viene generata quando il <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodo viene chiamato.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Un elenco di segmenti della matrice di byte verranno concatenati e accodati come record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Il nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Oggetto <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> contenente la prenotazione da utilizzare per questa area di riavvio."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Il numero di sequenza di scritta l&quot;area di riavvio."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Uno o più argomenti non è valido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si è verificato un errore dei / o durante la scrittura dell&quot;area di riavvio."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "La sequenza di record non esegua spazio libero sufficiente per contenere la nuova area di riavvio."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il metodo è stato chiamato dopo la sequenza è stata eliminata."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
