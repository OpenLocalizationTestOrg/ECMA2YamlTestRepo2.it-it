### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "Rappresenta una raccolta di last-in-first-out (LIFO) non generico semplice degli oggetti."
  remarks: "Per la versione generica di questa raccolta, vedere <xref:System.Collections.Generic.Stack%601?displayProperty=fullName>.</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       La capacità di uno Stack è il numero di elementi che dello Stack può contenere. Se gli elementi vengono aggiunti a uno Stack, la capacità viene aumentata automaticamente in base alle necessità, tramite riallocazione.       Se <xref:System.Collections.Stack.Count%2A>è inferiore alla capacità dello stack, <xref:System.Collections.Stack.Push%2A>è un&quot;operazione o (1).</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> Se la capacità deve essere incrementata per far posto al nuovo elemento <xref:System.Collections.Stack.Push%2A>diventa un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>è un&quot;operazione o (1).</xref:System.Collections.Stack.Pop%2A>       Stack accetta `null` come un valore valido e consente elementi duplicati."
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Stack&quot;> </xref> classe vuota e con capacità iniziale predefinita."
  remarks: "La capacità di un <xref:System.Collections.Stack>è il numero di elementi che la <xref:System.Collections.Stack>può contenere.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Quando gli elementi vengono aggiunti a un <xref:System.Collections.Stack>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</xref:System.Collections.Stack>       Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale si elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l&quot;aggiunta di elementi a <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Questo costruttore è un&quot;operazione o (1)."
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Stack&quot;> </xref> classe che contiene gli elementi copiati dalla raccolta specificata e ha la stessa capacità iniziale come numero di elementi copiati."
  remarks: "La capacità di un <xref:System.Collections.Stack>è il numero di elementi che la <xref:System.Collections.Stack>può contenere.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Quando gli elementi vengono aggiunti a un <xref:System.Collections.Stack>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</xref:System.Collections.Stack>       Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale si elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l&quot;aggiunta di elementi a <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Gli elementi vengono copiati nello <xref:System.Collections.Stack>nello stesso ordine in cui vengono letti dalla <xref:System.Collections.IEnumerator> <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Stack>       Questo costruttore è un&quot;operazione O (`n`) operazione, in cui `n` è il numero di elementi in `col`."
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "Il <xref:System.Collections.ICollection>per copiare gli elementi.</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Collections.Stack&quot;> </xref> classe che è vuota e ha la capacità iniziale specificata o la capacità iniziale predefinita, a seconda del valore maggiore."
  remarks: "La capacità di un <xref:System.Collections.Stack>è il numero di elementi che la <xref:System.Collections.Stack>può contenere.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Quando gli elementi vengono aggiunti a un <xref:System.Collections.Stack>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</xref:System.Collections.Stack>       Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale si elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l&quot;aggiunta di elementi a <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Questo costruttore è un&quot;operazione O (`n`) operazione, in cui `n` è `initialCapacity`."
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "Il numero iniziale di elementi che la <xref href=&quot;System.Collections.Stack&quot;> </xref> può contenere."
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>è minore di zero."
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Rimuove tutti gli oggetti dal <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "<xref:System.Collections.Stack.Count%2A>è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.</xref:System.Collections.Stack.Count%2A>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Crea una copia superficiale del <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Una copia superficiale di un insieme copia solo gli elementi della raccolta, indipendentemente che siano tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a. I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nella raccolta originale.       Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Una copia dei riferimenti di <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Determina se un elemento è incluso il <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Questo metodo determina l&quot;uguaglianza chiamando il <xref:System.Object.Equals%2A?displayProperty=fullName>metodo.</xref:System.Object.Equals%2A?displayProperty=fullName>       Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>       A partire da .NET Framework 2.0, questo metodo testa l&quot;uguaglianza passando il `obj` argomento per il <xref:System.Object.Equals%2A>metodo dei singoli oggetti nella raccolta.</xref:System.Object.Equals%2A> Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando passa i singoli elementi della raccolta per il <xref:System.Object.Equals%2A>metodo il `obj` argomento.</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Oggetto da individuare nel <xref href=&quot;System.Collections.Stack&quot;> </xref>. Il valore può essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copie di <xref href=&quot;System.Collections.Stack&quot;> </xref> unidimensionale esistente <xref:System.Array>, a partire dall&quot;indice di matrice specificato.</xref:System.Array>"
  remarks: "Gli elementi vengono copiati nella matrice last-in-first-out (LIFO) ordinamento, analogamente agli elementi restituiti da una sequenza di chiamate a <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Oggetto unidimensionale <xref:System.Array>che rappresenta la destinazione degli elementi copiati da <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Array> Il <xref:System.Array>deve avere un&quot;indicizzazione in base zero.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "Indice in base zero `array` da cui avviare la copia."
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>è minore di zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>è multidimensionale.       - oppure - il numero di elementi nell&quot;origine <xref href=&quot;System.Collections.Stack&quot;> </xref> è maggiore dello spazio disponibile da <code>index</code> alla fine della destinazione <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Il tipo di origine <xref href=&quot;System.Collections.Stack&quot;> </xref> non può essere eseguire automaticamente il cast al tipo della destinazione <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene il numero di elementi contenuti nella <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "La capacità è il numero di elementi che la <xref:System.Collections.Stack>archiviabili.</xref:System.Collections.Stack> Conteggio indica il numero di elementi effettivamente contenuti nella <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       La capacità è sempre maggiore di o uguale al numero specificato. Se il conteggio supera la capacità durante l&quot;aggiunta di elementi, la capacità viene automaticamente aumentata tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.       Il recupero del valore di questa proprietà è un&quot;operazione o (1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Il numero di elementi contenuti nella <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce un <xref:System.Collections.IEnumerator>per il <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic, c#]       Il `foreach` istruzione del linguaggio c# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, l&quot;utilizzo `foreach` è consigliabile, anziché la modifica diretta dell&quot;enumeratore.       È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non possono essere utilizzati per modificare la raccolta sottostante.       Inizialmente l&quot;enumeratore è posizionato prima del primo elemento nella raccolta. <xref:System.Collections.IEnumerator.Reset%2A>riporta l&quot;enumeratore in questa posizione.</xref:System.Collections.IEnumerator.Reset%2A>  In questa posizione, <xref:System.Collections.IEnumerator.Current%2A>è definito.</xref:System.Collections.IEnumerator.Current%2A> Pertanto, è necessario chiamare <xref:System.Collections.IEnumerator.MoveNext%2A>per passare l&quot;enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A>o <xref:System.Collections.IEnumerator.Reset%2A>viene chiamato.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>imposta <xref:System.Collections.IEnumerator.Current%2A>all&quot;elemento successivo.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>raggiunge la fine della raccolta, l&quot;enumeratore è posizionato dopo l&quot;ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A>restituisce `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando l&quot;enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A>restituire anche `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se l&quot;ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A>restituito `false`, <xref:System.Collections.IEnumerator.Current%2A>è definito.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Per impostare <xref:System.Collections.IEnumerator.Current%2A>il primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A>seguito dal <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Un enumeratore rimane valido fino a quando la raccolta rimane invariata. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l&quot;enumeratore viene invalidato e il relativo comportamento sarà indefinito.       L&quot;enumeratore non dispone di accesso esclusivo alla raccolta. Pertanto, l&quot;enumerazione di una raccolta non è quindi una procedura thread-safe.  Per garantire la protezione dei thread durante l&quot;enumerazione, è possibile bloccare la raccolta per l&quot;intera enumerazione.  Per consentire la raccolta a cui accedere da più thread per la lettura e scrittura, è necessario implementare la propria sincronizzazione.       Questo metodo è un&quot;operazione o (1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene un valore che indica se l&quot;accesso per il <xref href=&quot;System.Collections.Stack&quot;> </xref> è sincronizzato (thread-safe)."
  remarks: "Per garantire la thread-safe di <xref:System.Collections.Stack>, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <xref:System.Collections.Stack.Synchronized%2A>metodo.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.       Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.Stack.SyncRoot%2A>durante l&quot;intera enumerazione.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ] il recupero del valore di questa proprietà è un&quot;operazione o (1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, se l&quot;accesso al <xref href=&quot;System.Collections.Stack&quot;> </xref> è sincronizzato (thread-safe); in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Il valore predefinito è <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce l&quot;oggetto in cima il <xref href=&quot;System.Collections.Stack&quot;> </xref> senza rimuoverlo."
  remarks: "Questo metodo è analogo al <xref:System.Collections.Stack.Pop%2A>metodo, ma l&quot;anteprima non modifica la <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Pop%2A>       `null`può essere inserito il <xref:System.Collections.Stack>come segnaposto, se necessario.</xref:System.Collections.Stack> Per distinguere tra un valore null e la fine dello stack, controllare il <xref:System.Collections.Stack.Count%2A>proprietà o intercettare il <xref:System.InvalidOperationException>, che viene generato quando il <xref:System.Collections.Stack>è vuoto.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Questo metodo è un&quot;operazione o (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Il <xref:System.Object>in cima il <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref href=&quot;System.Collections.Stack&quot;> </xref> è vuoto."
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Rimuove e restituisce l&quot;oggetto in cima il <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Questo metodo è analogo al <xref:System.Collections.Stack.Peek%2A>metodo, ma <xref:System.Collections.Stack.Peek%2A>non modifica la <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Peek%2A> </xref:System.Collections.Stack.Peek%2A>       `null`può essere inserito il <xref:System.Collections.Stack>come segnaposto, se necessario.</xref:System.Collections.Stack> Per distinguere tra un valore null e la fine dello stack, controllare il <xref:System.Collections.Stack.Count%2A>proprietà o intercettare il <xref:System.InvalidOperationException>, che viene generato quando il <xref:System.Collections.Stack>è vuoto.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Questo metodo è un&quot;operazione o (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "Il <xref:System.Object>rimosso dalla parte superiore del <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il <xref href=&quot;System.Collections.Stack&quot;> </xref> è vuoto."
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inserisce un oggetto in cima il <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Se <xref:System.Collections.Stack.Count%2A>è già pari alla capacità, la capacità del <xref:System.Collections.Stack>viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`può essere inserito il <xref:System.Collections.Stack>come segnaposto, se necessario.</xref:System.Collections.Stack> Occupa uno slot nello stack e viene trattato come qualsiasi altro oggetto.       Se <xref:System.Collections.Stack.Count%2A>è minore della capacità dello stack, Push è un&quot;operazione o (1).</xref:System.Collections.Stack.Count%2A> Se la capacità deve essere incrementata per far posto al nuovo elemento, Push diventa un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Il <xref:System.Object>da inserire nel <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object> Il valore può essere <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Restituisce un oggetto sincronizzato wrapper (thread-safe) per il <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Per garantire la thread-safe di <xref:System.Collections.Stack>, tutte le operazioni devono essere eseguite tramite questo wrapper.</xref:System.Collections.Stack>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.       Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.Stack.SyncRoot%2A>durante l&quot;intera enumerazione.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ] questo metodo è un&quot;operazione o (1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "Il <xref href=&quot;System.Collections.Stack&quot;> </xref> per la sincronizzazione."
    return:
      type: System.Collections.Stack
      description: "Un wrapper di sincronizzazione per il <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ottiene un oggetto che può essere utilizzato per sincronizzare l&quot;accesso al <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Per creare una versione sincronizzata del <xref:System.Collections.Stack>, utilizzare il <xref:System.Collections.Stack.Synchronized%2A>metodo.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> Tuttavia, le classi derivate possono fornire una propria versione sincronizzata del <xref:System.Collections.Stack>utilizzando la proprietà SyncRoot.</xref:System.Collections.Stack> Il codice di sincronizzazione deve essere eseguite nella radice di sincronizzazione del <xref:System.Collections.Stack>, non direttamente sulla <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente il <xref:System.Collections.Stack>oggetto.</xref:System.Collections.Stack>       L&quot;enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread possa comunque modificare la raccolta, che determina l&quot;enumeratore generare un&quot;eccezione. Per garantire la protezione dei thread durante l&quot;enumerazione, bloccare la raccolta per l&quot;intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.       Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando SyncRoot durante l&quot;intera enumerazione.       [!code-cpp[Classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[classico Stack.IsSynchronized esempio n.&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ] il recupero del valore di questa proprietà è un&quot;operazione o (1).    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Un <xref:System.Object>che può essere utilizzato per sincronizzare l&quot;accesso per il <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copie di <xref href=&quot;System.Collections.Stack&quot;> </xref> in una nuova matrice."
  remarks: "Gli elementi vengono copiati nella matrice last-in-first-out (LIFO) ordinamento, analogamente agli elementi restituiti da una sequenza di chiamate a <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Questo metodo è un&quot;operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Nuova matrice che contiene copie degli elementi del <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
