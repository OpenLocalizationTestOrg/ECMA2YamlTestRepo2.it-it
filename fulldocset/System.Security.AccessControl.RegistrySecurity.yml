### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.RegistrySecurity
  id: RegistrySecurity
  children:
  - System.Security.AccessControl.RegistrySecurity.#ctor
  - System.Security.AccessControl.RegistrySecurity.AccessRightType
  - System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.RegistrySecurity.AccessRuleType
  - System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleType
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  langs:
  - csharp
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
  type: Class
  summary: "Rappresenta il controllo di accesso di Windows per una chiave del Registro di sistema. Questa classe non può essere ereditata."
  remarks: "Un oggetto RegistrySecurity specifica i diritti di accesso per una chiave del Registro di sistema e inoltre specifica come vengono controllati i tentativi di accesso. Diritti di accesso alla chiave del Registro di sistema sono espressi come regole, con ogni regola di accesso rappresentato da un <xref:System.Security.AccessControl.RegistryAccessRule>oggetto.</xref:System.Security.AccessControl.RegistryAccessRule> Ogni regola di controllo è rappresentato da un <xref:System.Security.AccessControl.RegistryAuditRule>oggetto.</xref:System.Security.AccessControl.RegistryAuditRule>       Questa situazione rispecchia il sistema di sicurezza di Windows sottostante, in cui ogni oggetto a protezione diretta dispone al massimo un controllo di accesso discrezionale elenco di controllo (DACL) che controlla l&quot;accesso per l&quot;oggetto protetto e al massimo di un elenco di controllo di accesso di sistema (SACL) che specifica quali tentativi di accesso vengono controllati. Gli elenchi DACL e SACL sono elenchi ordinati di voci di controllo di accesso (ACE) che specificano l&quot;accesso e controllo per utenti e gruppi. Oggetto <xref:System.Security.AccessControl.RegistryAccessRule>o <xref:System.Security.AccessControl.RegistryAuditRule>oggetto potrebbe rappresentare più di una voce ACE.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Del controllo di accesso di Windows può essere applicato solo alle chiavi del Registro di sistema. Non può essere applicato alle coppie chiave/valore singoli archiviate in una chiave.       RegistrySecurity, <xref:System.Security.AccessControl.RegistryAccessRule>, e <xref:System.Security.AccessControl.RegistryAuditRule>classi nascondono i dettagli di implementazione degli elenchi ACL e ACE.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule> Consentono di ignorare i diversi tipi ACE diciassette e la complessità della gestione corretta di ereditarietà e propagazione di diritti di accesso. Questi oggetti sono progettati anche per evitare gli errori di controllo accesso comuni seguenti:-creazione di un descrittore di sicurezza con un elenco DACL. Un riferimento null a un elenco DACL consente agli utenti di aggiungere le regole di accesso a un oggetto, potenzialmente la creazione di un attacco denial of service. Un nuovo oggetto RegistrySecurity inizia sempre con un elenco DACL vuoto, con cui viene negato l&quot;accesso per tutti gli utenti.      -Violazione dell&quot;ordine canonico delle voci ACE. Se l&quot;elenco di voci ACE nell&quot;elenco DACL non viene mantenuta in ordine canonico, potrebbe essere inavvertitamente concesso l&quot;accesso all&quot;oggetto protetto. Ad esempio, i diritti di accesso negato devono trovarsi sempre prima diritti di accesso consentito. Oggetti RegistrySecurity mantengono l&quot;ordine corretto internamente.      -La manipolazione dei flag del descrittore di sicurezza, che deve essere controllata resource manager solo.      -Creazione di combinazioni di flag ACE non valide.      -La modifica di voci ACE ereditate. Ereditarietà e propagazione vengono gestiti dal gestore delle risorse, in risposta alle modifiche apportate alle regole di accesso e controllo.      -Inserimento di voci ACE non significative in ACL.       Le uniche funzionalità non supportate dagli oggetti di sicurezza .NET sono le attività pericolose che dovrebbero essere evitate dalla maggior parte degli sviluppatori di applicazioni, ad esempio le operazioni seguenti:-attività di basso livello che sono in genere eseguita dal gestore delle risorse.      -Aggiunta o rimozione di voci di controllo di accesso in modo che non manutenzione l&quot;ordinamento canonico.       Per modificare il controllo di accesso di Windows per una chiave del Registro di sistema, usare il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>metodo per ottenere l&quot;oggetto RegistrySecurity.</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> Modificare l&quot;oggetto di sicurezza aggiungendo e rimuovendo le regole e quindi utilizzare il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metodo di ricollegare tale</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > Le modifiche apportate a un oggetto RegistrySecurity non influiscono sui livelli di accesso della chiave del Registro di sistema finché non si chiama il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metodo a cui assegnare l&quot;oggetto di sicurezza modificato alla chiave del Registro di sistema.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>       Per copiare la sicurezza del controllo di accesso da una chiave del registro a altro, utilizzare il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>per ottenere un oggetto RegistrySecurity che rappresenta le regole di accesso e controllo per la prima chiave del Registro di sistema e quindi utilizzare il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metodo a cui assegnare tali regole per la seconda chiave del Registro di sistema.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> È inoltre possibile assegnare le regole a una seconda chiave del Registro di sistema con un <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>o <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName>metodo che accetta un parametro dell&quot;oggetto RegistrySecurity.</xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>       Gli utenti con un investimento nel linguaggio di definizione descrittore di sicurezza (SDDL) possono usare il <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>per impostare le regole di accesso per una chiave del Registro di sistema e <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>metodo per ottenere una stringa che rappresenta le regole di accesso in formato SDDL.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Questa operazione è sconsigliata per i nuovi sviluppi."
  example:
  - "This section contains two code examples. The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.  \n  \n Example 1  \n  \n The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a RegistrySecurity object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the RegistrySecurity object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the RegistrySecurity object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the RegistrySecurity object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_15_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_15_1.cs)]  \n  \n Example 2  \n  \n The following code example demonstrates access rules with inheritance and propagation. The example creates a RegistrySecurity object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags> flag. The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags> and <xref:System.Security.AccessControl.PropagationFlags>.  \n  \n The program displays the rules in the RegistrySecurity object, and then uses the RegistrySecurity object to create a subkey. The program creates a child subkey and a grandchild subkey, then displays the security for each subkey. Finally, the program deletes the test keys.  \n  \n [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/visualbasic/t-system.security.access_15_2.vb)]\n [!code-cs[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/csharp/t-system.security.access_15_2.cs)]"
  syntax:
    content: 'public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> classe con i valori predefiniti."
  remarks: "Un nuovo <xref:System.Security.AccessControl.RegistrySecurity>oggetto inizia sempre con un elenco vuoto di accesso discrezionale (DACL), che nega l&quot;accesso per tutti gli utenti.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public RegistrySecurity ();
    parameters: []
  overload: System.Security.AccessControl.RegistrySecurity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Ottiene il tipo di enumerazione che il <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> classe viene utilizzato per rappresentare i diritti di accesso."
  remarks: "Le classi che derivano dalla <xref:System.Security.AccessControl.ObjectSecurity>classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di accesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di enumerazione appropriata da utilizzare con ogni oggetto di sicurezza."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "Oggetto <xref:System.Type>oggetto che rappresenta il <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> enumerazione.</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Crea una nuova regola di controllo di accesso per l&quot;utente specificato, con i diritti di accesso specificato, il controllo di accesso e i flag."
  remarks: "Il metodo consigliato per creare regole di controllo di accesso consiste nell&quot;utilizzare i costruttori di <xref:System.Security.AccessControl.RegistryAccessRule>classe.</xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Sebbene sia possibile specificare il <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>flag, è presente alcun punto questa azione necessaria.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> Ai fini di controllo di accesso, le coppie nome/valore in una sottochiave non sono oggetti separati. Diritti di accesso alle coppie nome/valore sono controllati dai diritti della sottochiave. Inoltre, poiché tutte le sottochiavi sono contenitori (vale a dire può contenere altre sottochiavi), non sono influenzati dal <xref:System.Security.AccessControl.InheritanceFlags>flag.</xref:System.Security.AccessControl.InheritanceFlags> Infine, se si specifica il <xref:System.Security.AccessControl.InheritanceFlags>flag inutilmente complica la gestione delle regole, perché interferisce con la combinazione normale di regole compatibili.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Un <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> che identifica l&quot;utente o gruppo, la regola viene applicata."
    - id: accessMask
      type: System.Int32
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> valori che specificano i diritti di accesso per consentire o negare, di cui è stato eseguito il cast a un numero intero."
    - id: isInherited
      type: System.Boolean
      description: "Valore booleano che specifica se la regola viene ereditata."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> valori che specificano come la regola è ereditata dalle sottochiavi."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> valori che modificano il modo in cui la regola viene ereditata dalle sottochiavi. Non è significativa se il valore di `inheritanceFlags` è <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "Uno del <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> valori che specificano se i diritti sono concesse o negati."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> oggetto che rappresenta i diritti specificati per l&quot;utente specificato."
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, o <code>type</code> specifica un valore non valido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - oppure - <code>accessMask</code> è zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>non è di tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, né di un tipo, ad esempio <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> che può essere convertito nel tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Ottiene il tipo di <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> classe viene utilizzato per rappresentare le regole di accesso."
  remarks: "Le classi che derivano dalla <xref:System.Security.AccessControl.ObjectSecurity>classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>proprietà e restituiscono il tipo utilizzato per rappresentare le regole di accesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di accesso corretto da utilizzare con ogni oggetto di sicurezza."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "Oggetto <xref:System.Type>oggetto che rappresenta il <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una corrispondenza con la quale è possibile unire la nuova regola di controllo degli accessi. Se non vengono rilevati, aggiunge la nuova regola."
  remarks: "Il metodo AddAccessRule cerca le regole con lo stesso utente o gruppo e lo stesso <xref:System.Security.AccessControl.AccessControlType>come `rule`.</xref:System.Security.AccessControl.AccessControlType> Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, i diritti in `rule` vengono unite con la regola esistente.       Regole non possono essere unite se dispongono di flag di ereditarietà diversi. Ad esempio, se un utente è consentito l&quot;accesso in lettura senza flag di ereditarietà e AddAccessRule viene utilizzato per aggiungere una regola che l&quot;utente accesso in scrittura con ereditarietà per le sottochiavi (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), non è possibile unire le due regole.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>       Le regole con diversi <xref:System.Security.AccessControl.AccessControlType>valori non vengono mai uniti.</xref:System.Security.AccessControl.AccessControlType>       Le regole esprimono i diritti in modo più economico. Ad esempio, se un utente dispone di <xref:System.Security.AccessControl.RegistryRights>, <xref:System.Security.AccessControl.RegistryRights>e <xref:System.Security.AccessControl.RegistryRights>diritti e si aggiunge una regola che concede <xref:System.Security.AccessControl.RegistryRights>diritti, l&quot;utente ha tutte le parti costitutive del <xref:System.Security.AccessControl.RegistryRights>rights.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> Se si esegue una query dei diritti dell&quot;utente, si noterà una regola contenente <xref:System.Security.AccessControl.RegistryRights>rights.</xref:System.Security.AccessControl.RegistryRights> Analogamente, se si rimuove <xref:System.Security.AccessControl.RegistryRights>diritti, gli altri componenti del <xref:System.Security.AccessControl.RegistryRights>diritti verranno visualizzato nuovamente.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights>"
  example:
  - "The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/csharp/0595520c-e456-4072-a959-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/0595520c-e456-4072-a959-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "La regola di controllo di accesso da aggiungere."
  overload: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una regola di controllo con cui è possibile unire la nuova regola. Se non vengono rilevati, aggiunge la nuova regola."
  remarks: "Il metodo AddAuditRule cerca le regole con lo stesso utente o gruppo di `rule`. Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, il flag in `rule` vengono unite alla regola esistente.       Regole non possono essere unite se dispongono di flag di ereditarietà diversi. Ad esempio, se per un determinato utente senza flag di ereditarietà, vengono controllati i tentativi non riusciti per scrivere una chiave e AddAuditRule viene utilizzata per aggiungere una regola che specifica che non tenta di modificare le autorizzazioni sono da controllare per lo stesso utente, ma con ereditarietà per le sottochiavi (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), non è possibile unire le due regole.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "Regola di controllo da aggiungere. L&quot;utente specificato da questa regola determina la ricerca."
  overload: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Crea una nuova regola di controllo, specificando l&quot;utente che viene applicata la regola, i diritti di accesso al controllo, l&quot;ereditarietà e la propagazione della regola e il risultato che attiva la regola."
  remarks: "Il metodo consigliato per creare regole di controllo consiste nell&quot;utilizzare i costruttori di <xref:System.Security.AccessControl.RegistryAuditRule>classe.</xref:System.Security.AccessControl.RegistryAuditRule>      > [!NOTE] > Sebbene sia possibile specificare il <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>flag, è presente alcun punto questa azione necessaria.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> Per motivi di controllo, le coppie nome/valore in una sottochiave non sono oggetti separati. I diritti di controllo per coppie nome/valore sono controllati dai diritti della sottochiave. Inoltre, poiché tutte le sottochiavi sono contenitori (vale a dire può contenere altre sottochiavi), non sono influenzati dal <xref:System.Security.AccessControl.InheritanceFlags>flag.</xref:System.Security.AccessControl.InheritanceFlags> Infine, se si specifica il <xref:System.Security.AccessControl.InheritanceFlags>flag inutilmente complica la gestione delle regole, perché interferisce con la combinazione normale di regole compatibili.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Un <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> che identifica l&quot;utente o gruppo, la regola viene applicata."
    - id: accessMask
      type: System.Int32
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> valori che specificano i diritti di accesso da controllare, eseguire il cast in un intero."
    - id: isInherited
      type: System.Boolean
      description: "Valore booleano che specifica se la regola viene ereditata."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> valori che specificano come la regola è ereditata dalle sottochiavi."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> valori che modificano il modo in cui la regola viene ereditata dalle sottochiavi. Non è significativa se il valore di `inheritanceFlags` è <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "Combinazione bit per bit di <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valori che specificano se controllare l&quot;accesso riuscito, l&quot;accesso non riuscito o entrambi."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> oggetto che rappresenta la regola di controllo specificato per l&quot;utente specificato, con i flag specificati. Il tipo restituito del metodo è la classe base, <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, ma il valore restituito può essere cast alla classe derivata."
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, o <code>flags</code> specifica un valore non valido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - oppure - <code>accessMask</code> è zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>non è di tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, né di un tipo, ad esempio <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> che può essere convertito nel tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Ottiene il tipo di <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> classe viene utilizzato per rappresentare le regole di controllo."
  remarks: "Le classi che derivano dalla <xref:System.Security.AccessControl.ObjectSecurity>classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di controllo.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di controllo appropriata da utilizzare con ogni oggetto di sicurezza."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "Oggetto <xref:System.Type>oggetto che rappresenta il <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una regola di controllo di accesso con lo stesso utente e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (Consenti o Nega) della regola di accesso specificato e con ereditarietà compatibile e il flag di propagazione; se viene trovata una regola, i diritti contenuti nella regola di accesso specificata vengono rimossi da esso."
  remarks: "Corrente <xref:System.Security.AccessControl.RegistrySecurity>viene cercata una regola con lo stesso utente e la stessa <xref:System.Security.AccessControl.AccessControlType>valore come `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l&quot;intera regola viene rimosso dall&quot;oggetto corrente <xref:System.Security.AccessControl.RegistrySecurity>oggetto.</xref:System.Security.AccessControl.RegistrySecurity>"
  example:
  - "The following code example shows how the RemoveAccessRule method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the RemoveAccessRule method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the RemoveAccessRule method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/797f5ef0-d4da-43dd-bbe9-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/797f5ef0-d4da-43dd-bbe9-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> che specifica l&quot;utente e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> da cercare e un set di flag di ereditarietà e propagazione di una regola corrispondente, se trovato, devono essere compatibili con. Specifica i diritti da rimuovere dalla regola compatibile, se trovato."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se viene trovata una regola compatibile. in caso contrario <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca tutte le regole di controllo con lo stesso utente di accesso e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (Consenti o Nega) come specificato regola e, se lo trova, rimuove tali."
  remarks: "Corrente <xref:System.Security.AccessControl.RegistrySecurity>viene eseguita la ricerca per le regole che presentano lo stesso utente e lo stesso <xref:System.Security.AccessControl.AccessControlType>valore come `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da `rule` vengono ignorati quando si esegue la ricerca. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione.       Ad esempio, se un utente dispone di più regole che concedono diritti diversi con ereditarietà diversa e i flag di propagazione, è possibile rimuovere tutte queste regole creando un <xref:System.Security.AccessControl.RegistryAccessRule>oggetto che specifica l&quot;utente e <xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName>, con eventuali diritti arbitrari e flag e passando tale regola per il metodo RemoveAccessRuleAll.</xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName> </xref:System.Security.AccessControl.RegistryAccessRule>"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user to take ownership, and passes that rule to the RemoveAccessRuleAll method to remove the two rules that allow access.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/2ba6e9de-1f41-4d05-af76-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/2ba6e9de-1f41-4d05-af76-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> che specifica l&quot;utente e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> per la ricerca. Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da questa regola vengono ignorati."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una regola di controllo di accesso che corrisponde esattamente al valore specificato regola e, se lo trova, rimuove il."
  remarks: "La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Le altre regole con lo stesso utente e <xref:System.Security.AccessControl.AccessControlType>non sono interessate.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > Una regola rappresenta uno o più sottostante voci controllo di accesso (ACE) e queste voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di accesso per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell&quot;aggiunta e in tal caso il metodo RemoveAccessRuleSpecific non è possibile rimuoverlo."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method removes a rule only if it matches exactly.  \n  \n The example creates two rules that allow different rights. The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first. The example calls the RemoveAccessRuleSpecific method, specifying the first rule, but because the rules are merged there is no rule that matches. The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the RemoveAccessRuleSpecific method to remove the first rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/9819c0cd-2b26-4472-a333-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/9819c0cd-2b26-4472-a333-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "Il <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> da rimuovere."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una regola di controllo con lo stesso utente della regola specificata e con ereditarietà compatibile e il flag di propagazione. Se viene trovata una regola compatibile, i diritti contenuti nella regola specificata vengono rimossi da esso."
  remarks: "Corrente <xref:System.Security.AccessControl.RegistrySecurity>viene cercata una regola di controllo con lo stesso utente `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l&quot;intera regola viene rimosso dall&quot;oggetto corrente <xref:System.Security.AccessControl.RegistrySecurity>oggetto.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> che specifica l&quot;utente per la ricerca e un set di flag di ereditarietà e propagazione di una regola corrispondente, se trovato, devono essere compatibili con. Specifica i diritti da rimuovere dalla regola compatibile, se trovato."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se viene trovata una regola compatibile. in caso contrario, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca tutte le regole con lo stesso utente della regola specificata di controllo e, se trovato, vengono rimosse."
  remarks: "Corrente <xref:System.Security.AccessControl.RegistrySecurity>viene eseguita la ricerca per le regole di controllo con lo stesso utente `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da `rule` vengono ignorati quando si esegue la ricerca. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "Oggetto <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> che specifica l&quot;utente per la ricerca. Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da questa regola vengono ignorati."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cerca una regola di controllo che corrisponde esattamente al valore specificato regola e, se lo trova, rimuove il."
  remarks: "La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Altre regole di controllo per lo stesso utente non sono interessate.      > [!IMPORTANT] > Una regola rappresenta uno o più sottostante voci controllo di accesso (ACE) e queste voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di controllo per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell&quot;aggiunta e in tal caso il metodo RemoveAuditRuleSpecific non è possibile rimuoverlo."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "Il <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> da rimuovere."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Rimuove tutte le regole di controllo di accesso con lo stesso utente della regola specificata, indipendentemente dal valore <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>e quindi aggiunge la regola specificata."
  remarks: "Se non sono presenti regole di accesso il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the ResetAccessRule method to remove the all rules for the user and replace them with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/csharp/80c97a6c-33e0-43c8-8894-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/80c97a6c-33e0-43c8-8894-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. L&quot;utente specificato da questa regola determina le regole da rimuovere prima di aggiungere questa regola."
  overload: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Rimuove tutte le regole di controllo di accesso con lo stesso utente e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (Consenti o Nega) della regola specificata e quindi aggiunge la regola specificata."
  remarks: "Se la regola specificata è <xref:System.Security.AccessControl.AccessControlType>, l&quot;effetto di questo metodo consiste nel rimuovere tutti <xref:System.Security.AccessControl.AccessControlType>regole per l&quot;utente specificato, sostituirli con la regola specificata.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> Se la regola specificata dispone <xref:System.Security.AccessControl.AccessControlType>tutti <xref:System.Security.AccessControl.AccessControlType>vengono sostituite le regole per l&quot;utente specificato con la regola specificata.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       Se non esistono regole il cui utente e <xref:System.Security.AccessControl.AccessControlType>corrispondono alla regola specificata, `rule` viene aggiunto.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows that the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the SetAccessRule method to remove the two rules that allow access and to replace them with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/908f14bb-fbc5-4e71-ac82-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/csharp/908f14bb-fbc5-4e71-ac82-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. L&quot;utente e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> di questa regola determinano le regole da rimuovere prima di aggiunta questa regola."
  overload: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Rimuove tutte le regole con lo stesso utente della regola specificata, indipendentemente di controllo di <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valore e quindi aggiunge la regola specificata."
  remarks: "Se non sono presenti regole di controllo il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref> to add. L&quot;utente specificato da questa regola determina le regole da rimuovere prima di aggiungere questa regola."
  overload: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistryAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAccessRule
  nameWithType: RegistryAccessRule
  fullName: System.Security.AccessControl.RegistryAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistryAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAuditRule
  nameWithType: RegistryAuditRule
  fullName: System.Security.AccessControl.RegistryAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.#ctor*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity.RegistrySecurity
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: RegistrySecurity.AccessRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: RegistrySecurity.AddAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: RegistrySecurity.AddAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: RegistrySecurity.AuditRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: RegistrySecurity.RemoveAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: RegistrySecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: RegistrySecurity.RemoveAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: RegistrySecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: RegistrySecurity.ResetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: RegistrySecurity.SetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: RegistrySecurity.SetAuditRule
