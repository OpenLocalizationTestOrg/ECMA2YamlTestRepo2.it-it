### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "Aggiunge un livello di buffer per la lettura e operazioni di scrittura su un altro flusso. Questa classe non può essere ereditata."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.BufferedStream&quot;> </xref> classe con una dimensione del buffer di 4096 byte."
  remarks: "Un buffer di lettura/scrittura condivisa viene allocato la prima volta un `BufferedStream` oggetto viene inizializzato con questo costruttore. Il buffer condiviso non viene utilizzato se tutte le letture e scritture sono maggiore o uguale a `bufferSize`."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Il flusso corrente."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inizializza una nuova istanza di <xref href=&quot;System.IO.BufferedStream&quot;> </xref> classe con le dimensioni del buffer specificato."
  remarks: "Un buffer di lettura/scrittura condivisa viene allocato la prima volta un `BufferedStream` oggetto viene inizializzato con questo costruttore. Il buffer condiviso non viene utilizzato se tutte le letture e scritture sono maggiore o uguale a `bufferSize`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Il flusso corrente."
    - id: bufferSize
      type: System.Int32
      description: "La dimensione del buffer in byte."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>è negativo."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Avvia un&quot;operazione di lettura asincrona. (È consigliabile utilizzare <xref:System.IO.BufferedStream.ReadAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.Stream.BeginRead%2A>e <xref:System.IO.Stream.EndRead%2A>per implementare operazioni asincrone sui file.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>deve essere chiamato esattamente una volta per ogni chiamata a BeginRead.</xref:System.IO.BufferedStream.EndWrite%2A> Impossibile terminare un processo di lettura prima di iniziare la lettura di un altro può causare un comportamento indesiderato, ad esempio i deadlock.      > [!NOTE] > Utilizzare il <xref:System.IO.BufferedStream.CanRead%2A>proprietà per determinare se l&quot;istanza corrente supporta la lettura.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>deve essere chiamato con questo <xref:System.IAsyncResult>per verificare il numero di byte letti.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Il buffer per leggere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in `buffer` in corrispondenza del quale iniziare la scrittura dei dati letti dal flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da leggere."
    - id: callback
      type: System.AsyncCallback
      description: "Callback asincrono facoltativo, da chiamare quando la lettura è completa."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa specifica richiesta di lettura asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Oggetto che rappresenta la lettura asincrona, che può essere ancora in sospeso."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Tentativo di lettura asincrona oltre la fine del flusso."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La lunghezza del buffer meno <code> offset </code> è minore di <code> count </code>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso corrente supporta l&quot;operazione di lettura."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Avvia un&quot;operazione di scrittura asincrona. (È consigliabile utilizzare <xref:System.IO.BufferedStream.WriteAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.Stream.BeginWrite%2A>e <xref:System.IO.Stream.EndWrite%2A>per implementare operazioni asincrone sui file.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult>da BeginWrite.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>verrà bloccata finché non viene completata l&quot;operazione dei / o.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Buffer contenente i dati da scrivere nel flusso corrente."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in base zero in `buffer` in corrispondenza del quale iniziare la copia dei byte nel flusso corrente."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da scrivere."
    - id: callback
      type: System.AsyncCallback
      description: "Il metodo da chiamare quando l&quot;operazione di scrittura asincrona viene completata."
    - id: state
      type: System.Object
      description: "Oggetto fornito dall&quot;utente che distingue questa richiesta particolare di scrittura asincrona da altre richieste."
    return:
      type: System.IAsyncResult
      description: "Oggetto che fa riferimento alla scrittura asincrona che può essere ancora in sospeso."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>la lunghezza di meno <code>offset</code> è minore di <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la lettura."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la lettura, le chiamate al <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>e `Peek` metodi di <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>e <xref:System.IO.TextReader>Genera un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la lettura. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o è stato aperto con accesso in sola scrittura."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la ricerca."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la ricerca, le chiamate a <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>e <xref:System.IO.BufferedStream.Seek%2A>Genera un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la ricerca. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o se il flusso è stato costruito da un handle del sistema operativo, ad esempio un pipe o un output alla console."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene un valore che indica se il flusso corrente supporta la scrittura."
  remarks: "Se una classe derivata da <xref:System.IO.Stream>non supporta la scrittura, una chiamata a <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, o <xref:System.IO.BufferedStream.WriteByte%2A>Genera un <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       Se il flusso è chiuso, questa proprietà restituisce `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se il flusso supporta la scrittura; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se il flusso è chiuso o è stato aperto con accesso in sola lettura."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "Da aggiungere."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Attende che l&quot;operazione di lettura asincrono in sospeso da completare. (È consigliabile utilizzare <xref:System.IO.BufferedStream.ReadAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.Stream.BeginRead%2A>e <xref:System.IO.Stream.EndRead%2A>per implementare operazioni asincrone sui file.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       EndRead deve essere chiamato con questo <xref:System.IAsyncResult>per verificare il numero di byte letti.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Il riferimento alla richiesta asincrona in sospeso da attendere."
    return:
      type: System.Int32
      description: "Il numero di byte letti dal flusso, tra 0 (zero) e il numero di byte richiesto. I flussi restituiscono 0 solo alla fine del flusso solo, in caso contrario, si devono bloccare fino a quando non è disponibile almeno 1 byte."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Questo <xref:System.IAsyncResult>oggetto non è stato creato chiamando <xref:System.IO.BufferedStream.BeginRead*>su questa classe.</xref:System.IO.BufferedStream.BeginRead*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Termina un&quot;operazione di scrittura asincrona, rimanendo bloccato fino a quando non è stata completata l&quot;operazione dei / o. (È consigliabile utilizzare <xref:System.IO.BufferedStream.WriteAsync*>; vedere la sezione Osservazioni.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <xref:System.IO.Stream.BeginWrite%2A>e <xref:System.IO.Stream.EndWrite%2A>per implementare operazioni asincrone sui file.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida è implementare operazioni asincrone sui file più facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       EndWrite deve essere chiamato esattamente una volta per ogni chiamata a <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> Impossibile terminare un processo di lettura prima di iniziare un&quot;altra operazione di lettura può provocare deadlock o altri comportamenti indesiderati."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "La richiesta asincrona in sospeso."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Questo <xref:System.IAsyncResult>oggetto non è stato creato chiamando <xref:System.IO.BufferedStream.BeginWrite*>su questa classe.</xref:System.IO.BufferedStream.BeginWrite*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Cancella tutti i buffer del flusso e fa sì che tutti i dati memorizzati nel buffer da scrivere nel dispositivo sottostante."
  remarks: "La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non chiama in modo esplicito `Flush` o <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       Se si utilizza il <xref:System.IO.BufferedStream.%23ctor%2A>costruttore, pertanto specificando le dimensioni del buffer durante la creazione di `BufferedStream` dell&quot;oggetto, il contenuto viene scaricato quando raggiunge la dimensione del buffer.</xref:System.IO.BufferedStream.%23ctor%2A> Esempio di codice, ad esempio `BufferedStream bs = new BufferedStream(bs, 5)` svuoterà il contenuto quando le dimensioni del buffer raggiungono 5 byte.       Tutti i metodi di lettura e scrittura di `BufferedStream` gestisce automaticamente il buffer, pertanto non è necessario richiamare `Flush` quando si passa avanti e indietro tra lettura e scrittura."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "L&quot;origine dati o il repository non è aperto."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Cancella tutti i buffer del flusso, determina la scrittura di dati da scrivere nel dispositivo sottostante e monitora le richieste di annullamento in modo asincrono."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Attività che rappresenta l&quot;operazione di scaricamento asincrona."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene la lunghezza del flusso in byte."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "La lunghezza del flusso in byte."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso sottostante è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> o chiuso."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la ricerca."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ottiene la posizione all&quot;interno del flusso corrente."
  remarks: "Il `get` della funzione di accesso richiama <xref:System.IO.BufferedStream.Seek%2A>per ottenere la posizione corrente all&quot;interno del flusso sottostante e quindi modifica tale valore in base alla posizione corrente all&quot;interno del buffer.</xref:System.IO.BufferedStream.Seek%2A>       Il `set` copia tutti i dati precedentemente scritti nel buffer nel flusso sottostante e quindi richiama <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Posizione all&quot;interno del flusso corrente."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Il valore passato a <xref:System.IO.BufferedStream.Seek*>è negativo.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si verifica un errore dei / o, ad esempio la chiusura del flusso."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la ricerca."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Copia i byte dal flusso memorizzato nel buffer corrente in una matrice."
  remarks: "Il `Read` metodo restituirà 0 solo se viene raggiunta la fine del flusso. In tutti gli altri casi, `Read` legge sempre almeno un byte dal flusso prima della restituzione. Per definizione, se non sono disponibili dati dal flusso dopo una chiamata a `Read`, `Read` metodo restituisce 0 (raggiunta la fine del flusso viene automaticamente). Un&quot;implementazione è gratuita restituire un numero di byte rispetto a quello richiesto, anche se non è stata raggiunta la fine del flusso.       Utilizzare <xref:System.IO.BinaryReader>per la lettura dei tipi di dati primitivi.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Il buffer a cui si desidera copiare byte."
    - id: offset
      type: System.Int32
      description: "Offset dei byte nel buffer da cui iniziare la lettura dei byte."
    - id: count
      type: System.Int32
      description: "Il numero di byte da leggere."
    return:
      type: System.Int32
      description: "Il numero totale di byte letti in <code> array </code>. Questo può essere minore del numero di byte richiesti se di numero di byte non è attualmente disponibili oppure 0 se è stata raggiunta la fine del flusso prima che i dati possono essere letti."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la lettura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Legge in modo asincrono una sequenza di byte dal flusso corrente, fa avanzare la posizione all&quot;interno del flusso del numero di byte letti e monitora le richieste di annullamento."
  remarks: "È possibile creare un token di annullamento viene creata un&quot;istanza del <xref:System.Threading.CancellationTokenSource>classe e passando il <xref:System.Threading.CancellationTokenSource.Token%2A>proprietà come il `cancellationToken` parametro.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Buffer in cui scrivere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in `buffer` in corrispondenza del quale iniziare la scrittura dei dati dal flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da leggere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operazione di lettura di un&quot;attività che rappresenta asincrona. Il valore di <code> TResult </code> parametro contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere inferiore al numero di byte richiesti se il numero di byte attualmente disponibili è minore del numero di richiesto o può essere 0 (zero) se è stata raggiunta la fine del flusso."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La somma di <code> offset </code> e <code> count </code> è maggiore della lunghezza del buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la lettura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il flusso è attualmente in uso da un&quot;operazione di lettura precedente."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Legge un byte dal flusso sottostante e restituisce il cast di byte in un <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, o restituisce -1 se la lettura dalla fine del flusso."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Cast di byte su un <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, oppure -1 se la lettura dalla fine del flusso."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Si verifica un errore dei / o, ad esempio la chiusura del flusso."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la lettura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Imposta la posizione all&quot;interno del flusso memorizzato nel buffer corrente."
  remarks: "Se `offset` è negativo, la nuova posizione precederà la posizione specificata da `origin` per il numero di byte specificato da `offset`. Se `offset` è 0, la nuova posizione sarà quella specificata da `origin`. Se `offset` è positivo, la nuova posizione seguirà la posizione specificata da `origin` per il numero di byte specificato da `offset`.       Quando un <xref:System.IO.BufferedStream>oggetto è il flusso di base per un <xref:System.IO.StreamReader>dell&quot;oggetto, chiamare il metodo Seek può causare la posizione del flusso per la corrispondenza non è più la posizione del buffer interno nel lettore.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Offset di byte relativo `origin`."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Un valore di tipo <xref:System.IO.SeekOrigin>che indica il punto di riferimento da cui ottenere la nuova posizione.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nuova posizione all&quot;interno del flusso memorizzato nel buffer corrente."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la ricerca."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Imposta la lunghezza del flusso memorizzato nel buffer."
  remarks: "Il buffer viene scaricato prima di impostare la lunghezza dell&quot;origine dati sottostante o repository. Se il valore specificato è minore della lunghezza corrente del flusso memorizzato nel buffer, viene troncato il flusso memorizzato nel buffer. Se il valore specificato è maggiore della lunghezza corrente del flusso memorizzato nel buffer, viene espanso il flusso memorizzato nel buffer. Se il flusso memorizzato nel buffer è espanso, il contenuto del flusso memorizzato nel buffer tra il vecchio e la nuova lunghezza non definito.       `SetLength`Se necessario, Scarica memorizzato nel buffer scritture.       Un flusso deve supportare sia la ricerca per la scrittura `SetLength` a funzionare."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Valore intero che indica la lunghezza desiderata del flusso memorizzato nel buffer corrente in byte."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o è <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura e ricerca."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Copia i byte nel flusso memorizzato nel buffer e fa avanzare la posizione corrente all&quot;interno del flusso memorizzato nel buffer il numero di byte scritti."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Matrice di byte da cui copiare `count` byte nel flusso memorizzato nel buffer corrente."
    - id: offset
      type: System.Int32
      description: "Offset nel buffer da cui iniziare la copia dei byte nel flusso memorizzato nel buffer corrente."
    - id: count
      type: System.Int32
      description: "Il numero di byte da scrivere nel flusso memorizzato nel buffer corrente."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Il flusso è chiuso o <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Scrive una sequenza di byte nel flusso corrente, fa avanzare la posizione corrente nel flusso del numero di byte scritti e monitora le richieste di annullamento in modo asincrono."
  remarks: "È possibile creare un token di annullamento viene creata un&quot;istanza del <xref:System.Threading.CancellationTokenSource>classe e passando il <xref:System.Threading.CancellationTokenSource.Token%2A>proprietà come il `cancellationToken` parametro.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Buffer in cui scrivere i dati."
    - id: offset
      type: System.Int32
      description: "Offset dei byte in base zero in `buffer` da cui iniziare la copia dei byte nel flusso."
    - id: count
      type: System.Int32
      description: "Numero massimo di byte da scrivere."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token da monitorare per le richieste di annullamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Un&quot;attività che rappresenta l&quot;operazione di scrittura asincrona."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>o <code>count</code> è negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "La somma di <code> offset </code> e <code> count </code> è maggiore della lunghezza del buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Il flusso è stato eliminato."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Il flusso è attualmente in uso da un&quot;operazione di scrittura precedente."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Scrive un byte la posizione corrente nel flusso memorizzato nel buffer."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Byte da scrivere nel flusso."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Il flusso non supporta la scrittura."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Sono stati chiamati dei metodi dopo la chiusura del flusso."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
